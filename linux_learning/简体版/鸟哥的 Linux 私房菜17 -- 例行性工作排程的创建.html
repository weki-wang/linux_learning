
<!-- saved from url=(0050)http://cn.linux.vbird.org/linux_basic/0430cron.php -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
	
	<meta name="Author" content="2011/04/20,white">
	<meta name="Description" content="包括了 crontab 与 at 这两支程序啦！">
	<title>鸟哥的 Linux 私房菜 -- 例行性工作排程的创建</title>
    <script src="./鸟哥的 Linux 私房菜17 -- 例行性工作排程的创建_files/SpryMenuBar.js" type="text/javascript"></script>
	<script src="./鸟哥的 Linux 私房菜17 -- 例行性工作排程的创建_files/index.js" type="text/javascript"></script>
	<link href="./鸟哥的 Linux 私房菜17 -- 例行性工作排程的创建_files/SpryMenuBarHorizontal.css" rel="stylesheet" type="text/css">
    <link href="./鸟哥的 Linux 私房菜17 -- 例行性工作排程的创建_files/main.css" rel="stylesheet" type="text/css">
    </head><body style="margin: 0pt; padding: 0pt;" class="table" onload="MM_preloadImages(&#39;image/title_19.png&#39;,&#39;image/title_26.png&#39;,&#39;image/title_27.png&#39;,&#39;image/title_28.png&#39;,&#39;image/title_06.png&#39;,&#39;image/title_08.png&#39;,&#39;image/title_10.png&#39;,&#39;image/title_12.png&#39;)">

<center>
<div id="apDiv5">
<div> <link rel="SHORTCUT ICON" href="http://cn.linux.vbird.org/linux_basic/favicon.ico">
<!-- ImageReady Slices (title3.ai) -->
<table id="___01" width="898" height="81" border="0" align="center" cellpadding="0" cellspacing="0" ;="">
	<tbody><tr>
		<td colspan="15">
			<img src="./鸟哥的 Linux 私房菜17 -- 例行性工作排程的创建_files/title_01.png" width="900" height="1" alt=""></td>
	</tr>
	<tr>
		<td rowspan="4" bgcolor="#182448"><p><img src="./鸟哥的 Linux 私房菜17 -- 例行性工作排程的创建_files/Count.cgi" width="93" align="left" title="計數器"></p>
	    <p><font color="#FFFFFF" size="-1">since2012/04/23</font></p></td>
		<td rowspan="4" align="left" valign="top"><a href="http://cn.linux.vbird.org/"><img src="./鸟哥的 Linux 私房菜17 -- 例行性工作排程的创建_files/title_03.png" alt="" width="263" height="79" border="0"></a></td>
		<td colspan="13">
			<img src="./鸟哥的 Linux 私房菜17 -- 例行性工作排程的创建_files/title_04.png" alt="" width="535" height="9" border="0"></td>
	</tr>
	<tr>
		<td rowspan="3">
			<img src="./鸟哥的 Linux 私房菜17 -- 例行性工作排程的创建_files/title_05.png" alt="" width="53" height="70" border="0"></td>
		<td colspan="2" align="left" valign="top"><a href="http://cn.linux.vbird.org/linux_basic/0110whatislinux.php" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage(&#39;Image51&#39;,&#39;&#39;,&#39;image/title/title_06.png&#39;,1)"><img src="./鸟哥的 Linux 私房菜17 -- 例行性工作排程的创建_files/title3_06.png" name="Image51" width="106" height="25" border="0" id="Image51" alt=""></a></td>
		<td rowspan="2">
			<img src="./鸟哥的 Linux 私房菜17 -- 例行性工作排程的创建_files/title_07.png" alt="" width="27" height="37" border="0"></td>
		<td colspan="3" align="left" valign="top"><a href="http://cn.linux.vbird.org/linux_server/0110network_basic.php" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage(&#39;Image52&#39;,&#39;&#39;,&#39;image/title/title_08.png&#39;,1)"><img src="./鸟哥的 Linux 私房菜17 -- 例行性工作排程的创建_files/title3_08.png" name="Image52" width="107" height="25" border="0" id="Image52" alt=""></a></td>
		<td rowspan="2">
			<img src="./鸟哥的 Linux 私房菜17 -- 例行性工作排程的创建_files/title_09.png" alt="" width="37" height="37" border="0"></td>
		<td colspan="2" align="left" valign="top"><a href="http://cn.linux.vbird.org/about.php" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage(&#39;Image53&#39;,&#39;&#39;,&#39;image/title/title_10.png&#39;,1)"><img src="./鸟哥的 Linux 私房菜17 -- 例行性工作排程的创建_files/title3_10.png" name="Image53" width="75" height="25" border="0" id="Image53" alt=""></a></td>
		<td rowspan="3">
			<img src="./鸟哥的 Linux 私房菜17 -- 例行性工作排程的创建_files/title_11.png" alt="" width="35" height="70" border="0"></td>
		<td align="left" valign="top"><a href="mailto:vbird@mail.vbird.idv.tw" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage(&#39;Image54&#39;,&#39;&#39;,&#39;image/title/title_12.png&#39;,1)"><img src="./鸟哥的 Linux 私房菜17 -- 例行性工作排程的创建_files/title3_12.png" name="Image54" width="74" height="25" border="0" id="Image54" alt=""></a></td>
		<td rowspan="3">
			<img src="./鸟哥的 Linux 私房菜17 -- 例行性工作排程的创建_files/title_13.png" alt="" width="21" height="70" border="0"></td>
	</tr>
	<tr>
		<td colspan="2">
			<img src="./鸟哥的 Linux 私房菜17 -- 例行性工作排程的创建_files/title_14.png" alt="" width="106" height="12" border="0"></td>
		<td colspan="3">
			<img src="./鸟哥的 Linux 私房菜17 -- 例行性工作排程的创建_files/title_15.png" alt="" width="107" height="12" border="0"></td>
		<td colspan="2">
			<img src="./鸟哥的 Linux 私房菜17 -- 例行性工作排程的创建_files/title_16.png" width="75" height="12" alt=""></td>
		<td rowspan="2">
			<img src="./鸟哥的 Linux 私房菜17 -- 例行性工作排程的创建_files/title_17.png" alt="" width="74" height="45" border="0"></td>
	</tr>
	<tr>
		<td>
			<img src="./鸟哥的 Linux 私房菜17 -- 例行性工作排程的创建_files/title_18.png" alt="" width="15" height="33" border="0"></td>
		<td colspan="3" align="left" valign="top"><ul id="MenuBar1" class="MenuBarHorizontal">
	  <li><a href="http://cn.linux.vbird.org/linux_basic/linux_basic.php" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage(&#39;Image44&#39;,&#39;&#39;,&#39;image/title/title_19.png&#39;,1)" class="MenuBarItemSubmenu"><img src="./鸟哥的 Linux 私房菜17 -- 例行性工作排程的创建_files/title3_19.png" name="Image44" width="123" height="33" border="0" id="Image44"></a>
			    <ul>
			      <li><a href="http://cn.linux.vbird.org/linux_basic/Mandrake9.0/mandrake9.0.php" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage(&#39;Image46&#39;,&#39;&#39;,&#39;image/title/title_26.png&#39;,1)"><img src="./鸟哥的 Linux 私房菜17 -- 例行性工作排程的创建_files/title_23.png" name="Image46" width="120" height="26" border="0" id="Image46" alt=""></a></li>
                  <li><a href="http://cn.linux.vbird.org/linux_basic/fedora_4/fc4.php" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage(&#39;Image47&#39;,&#39;&#39;,&#39;image/title/title_27.png&#39;,1)"><img src="./鸟哥的 Linux 私房菜17 -- 例行性工作排程的创建_files/title_24.png" name="Image47" width="120" height="26" border="0" id="Image47" alt=""></a></li>
                  <li><a href="http://cn.linux.vbird.org/linux_basic/linux_basic.php" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage(&#39;Image48&#39;,&#39;&#39;,&#39;image/title/title_28.png&#39;,1)"><img src="./鸟哥的 Linux 私房菜17 -- 例行性工作排程的创建_files/title_25.png" name="Image48" width="120" height="26" border="0" id="Image48" alt=""></a></li>
                </ul>
		      </li>
		</ul></td>
		<td>
			<img src="./鸟哥的 Linux 私房菜17 -- 例行性工作排程的创建_files/title_20.png" alt="" width="42" height="33" border="0"></td>
		<td colspan="3" align="left" valign="top"><ul id="MenuBar2" class="MenuBarHorizontal">
	  <li><a href="http://cn.linux.vbird.org/linux_server/" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage(&#39;Image45&#39;,&#39;&#39;,&#39;image/title/title_21.png&#39;,1)" class="MenuBarItemSubmenu"><img src="./鸟哥的 Linux 私房菜17 -- 例行性工作排程的创建_files/title3_21.png" name="Image45" width="125" height="33" border="0" id="Image45"></a>
			    <ul>
			      <li><a href="http://cn.linux.vbird.org/linux_server/linux_redhat9/redhat9.php" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage(&#39;Image43&#39;,&#39;&#39;,&#39;image/title/title_26.png&#39;,1)"><img src="./鸟哥的 Linux 私房菜17 -- 例行性工作排程的创建_files/title_23.png" name="Image43" width="120" height="26" border="0" id="Image43" alt=""></a></li>
			      <li><a href="http://cn.linux.vbird.org/linux_server/centos4.php" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage(&#39;Image49&#39;,&#39;&#39;,&#39;image/title/title_27.png&#39;,1)"><img src="./鸟哥的 Linux 私房菜17 -- 例行性工作排程的创建_files/title_24.png" name="Image49" width="120" height="26" border="0" id="Image49" alt=""></a></li>
			      <li><a href="http://cn.linux.vbird.org/linux_server/" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage(&#39;Image50&#39;,&#39;&#39;,&#39;image/title/title_28.png&#39;,1)"><img src="./鸟哥的 Linux 私房菜17 -- 例行性工作排程的创建_files/title_25.png" name="Image50" width="120" height="26" border="0" id="Image50" alt=""></a></li>
		        </ul>
		      </li>
		</ul></td>
		<td>
			<img src="./鸟哥的 Linux 私房菜17 -- 例行性工作排程的创建_files/title_22.png" alt="" width="47" height="33" border="0"></td>
	</tr>
	<tr>
		<td>
			<img src="./鸟哥的 Linux 私房菜17 -- 例行性工作排程的创建_files/Spacer.gif" width="101" height="1" alt=""></td>
		<td>
			<img src="./鸟哥的 Linux 私房菜17 -- 例行性工作排程的创建_files/Spacer.gif" width="263" height="1" alt=""></td>
		<td>
			<img src="./鸟哥的 Linux 私房菜17 -- 例行性工作排程的创建_files/Spacer.gif" width="53" height="1" alt=""></td>
		<td>
			<img src="./鸟哥的 Linux 私房菜17 -- 例行性工作排程的创建_files/Spacer.gif" width="15" height="1" alt=""></td>
		<td>
			<img src="./鸟哥的 Linux 私房菜17 -- 例行性工作排程的创建_files/Spacer.gif" width="91" height="1" alt=""></td>
		<td>
			<img src="./鸟哥的 Linux 私房菜17 -- 例行性工作排程的创建_files/Spacer.gif" width="27" height="1" alt=""></td>
		<td>
			<img src="./鸟哥的 Linux 私房菜17 -- 例行性工作排程的创建_files/Spacer.gif" width="5" height="1" alt=""></td>
		<td>
			<img src="./鸟哥的 Linux 私房菜17 -- 例行性工作排程的创建_files/Spacer.gif" width="42" height="1" alt=""></td>
		<td>
			<img src="./鸟哥的 Linux 私房菜17 -- 例行性工作排程的创建_files/Spacer.gif" width="60" height="1" alt=""></td>
		<td>
			<img src="./鸟哥的 Linux 私房菜17 -- 例行性工作排程的创建_files/Spacer.gif" width="37" height="1" alt=""></td>
		<td>
			<img src="./鸟哥的 Linux 私房菜17 -- 例行性工作排程的创建_files/Spacer.gif" width="28" height="1" alt=""></td>
		<td>
			<img src="./鸟哥的 Linux 私房菜17 -- 例行性工作排程的创建_files/Spacer.gif" width="47" height="1" alt=""></td>
		<td>
			<img src="./鸟哥的 Linux 私房菜17 -- 例行性工作排程的创建_files/Spacer.gif" width="35" height="1" alt=""></td>
		<td>
			<img src="./鸟哥的 Linux 私房菜17 -- 例行性工作排程的创建_files/Spacer.gif" width="74" height="1" alt=""></td>
		<td>
			<img src="./鸟哥的 Linux 私房菜17 -- 例行性工作排程的创建_files/Spacer.gif" width="22" height="1" alt=""></td>
	</tr>
</tbody></table>
<!-- End ImageReady Slices -->
<script type="text/javascript">
<!--
var MenuBar1 = new Spry.Widget.MenuBar("MenuBar1", {imgDown:"SpryAssets/SpryMenuBarDownHover.gif", imgRight:"SpryAssets/SpryMenuBarRightHover.gif"});
var MenuBar2 = new Spry.Widget.MenuBar("MenuBar2", {imgDown:"SpryAssets/SpryMenuBarDownHover.gif", imgRight:"SpryAssets/SpryMenuBarRightHover.gif"});
//-->
</script>
</div>
<table summary="本文内容的排版" style="width: 898px;" border="0" cellpadding="0" cellspacing="0">
<tbody><tr><td style="width: 16px; height: 16px;">　</td>
    <td style="width: 866px; height: 16px;">　</td>
    <td style="width: 16px; height: 16px;">　</td></tr>
<tr><td style="width: 16px; font-size: 6px;">　</td>
    <td width="866">

<!-- 本文的档头部分 -->
<div style="text-align: center;">
    <a href="http://cn.linux.vbird.org/linux_basic/0430cron.php">
    <span class="text_head0">第十六章、例行性工作排程<span class="text_head_en"> (crontab)</span></span></a><br>
</div>
    <div style="text-align: right;">
        <span class="text_history">最近升级日期：2009/09/11</span>
    </div>

<!-- 本文的档头部分 -->
<center><table class="head1" summary="排版：文章档头的说明"><tbody><tr><td class="head1">
	学习了基础篇也一阵子了，你会发现到为什么系统常常会主动的进行一些任务？这些任务到底是谁在配置工作的？
	如果你想要让自己设计的备份程序可以自动的在系统底下运行，而不需要手动来启动他，又该如何处置？
	这些例行的工作可能又分为『单一』工作与『循环』工作，在系统内又是哪些服务在负责？
	还有还有，如果你想要每年在老婆的生日前一天就发出一封信件提醒自己不要忘记，可以办的到吗？
	嘿嘿！这些种种要如何处理，就看看这一章先！
</td></tr></tbody></table></center><br>

<!-- 本文的连结区部分 -->
<div class="block1">
<span class="text_h1">
1. <a href="http://cn.linux.vbird.org/linux_basic/0430cron.php#whatiscron">什么是例行性工作排程</a><br>
	<span class="text_h2">
	　　1.1 <a href="http://cn.linux.vbird.org/linux_basic/0430cron.php#whatiscron_type">Linux 工作排程的种类： at, crontab</a><br>
	　　1.2 <a href="http://cn.linux.vbird.org/linux_basic/0430cron.php#whatiscron_linux">Linux 上常见的例行性工作</a><br>
	</span>
2. <a href="http://cn.linux.vbird.org/linux_basic/0430cron.php#atjob">仅运行一次的工作排程</a><br>
	<span class="text_h2">
	　　2.1 <a href="http://cn.linux.vbird.org/linux_basic/0430cron.php#atjob_how">atd 的启动与 at 运行的方式</a>： <a href="http://cn.linux.vbird.org/linux_basic/0430cron.php#at_deny">/etc/at.deny</a><br>
	　　2.2 <a href="http://cn.linux.vbird.org/linux_basic/0430cron.php#atjob_work">实际运行单一工作排程</a>： <a href="http://cn.linux.vbird.org/linux_basic/0430cron.php#at">at</a>,
		<a href="http://cn.linux.vbird.org/linux_basic/0430cron.php#atq_atrm">atq &amp; atrm</a>, <a href="http://cn.linux.vbird.org/linux_basic/0430cron.php#batch">batch</a><br>
	</span>
3. <a href="http://cn.linux.vbird.org/linux_basic/0430cron.php#cron">循环运行的例行性工作排程</a><br>
	<span class="text_h2">
	　　3.1 <a href="http://cn.linux.vbird.org/linux_basic/0430cron.php#crontab_user">使用者的配置</a>： <a href="http://cn.linux.vbird.org/linux_basic/0430cron.php#cron_deny">/etc/cron.deny</a>, <a href="http://cn.linux.vbird.org/linux_basic/0430cron.php#crontab">crontab</a><br>
	　　3.2 <a href="http://cn.linux.vbird.org/linux_basic/0430cron.php#etc_crontab1">系统的配置档</a>： <a href="http://cn.linux.vbird.org/linux_basic/0430cron.php#etc_crontab">/etc/crontab</a><br>
	　　3.3 <a href="http://cn.linux.vbird.org/linux_basic/0430cron.php#security">一些注意事项</a><br>
	</span>
4. <a href="http://cn.linux.vbird.org/linux_basic/0430cron.php#anacron_1">可唤醒停机期间的工作任务</a><br>
	<span class="text_h2">
	　　4.1 <a href="http://cn.linux.vbird.org/linux_basic/0430cron.php#anacron_what">什么是 anacron</a><br>
	　　4.2 <a href="http://cn.linux.vbird.org/linux_basic/0430cron.php#anacron">anacron 与 /etc/anacrontab</a><br>
	</span>
5. <a href="http://cn.linux.vbird.org/linux_basic/hint">重点回顾</a><br>
6. <a href="http://cn.linux.vbird.org/linux_basic/0430cron.php#ex">本章习题</a><br>
<span class="text_h2">
7. <a href="http://phorum.vbird.org/viewtopic.php?t=23889" target="_blank">针对本文的建议：http://phorum.vbird.org/viewtopic.php?t=23889</a>
</span>
</span>
</div>


<!-- 本文的正式部分 -->
<hr><a name="whatiscron"></a><img src="./鸟哥的 Linux 私房菜17 -- 例行性工作排程的创建_files/logo.png" alt="大标题的图示" width="35" align="middle" height="34"><span class="text_h1">什么是例行性工作排程</span><br>
<div class="block1">
	<p>每个人或多或少都有一些约会或者是工作，<span class="text_import2">有的工作是例行性的</span>，
	例如每年一次的加薪、每个月一次的工作报告、每周一次的午餐会报、每天需要的打卡等等；
	<span class="text_import2">有的工作则是临时发生的</span>，例如刚好总公司有高官来访，需要你准备演讲器材等等！
	用在生活上面，例如每年的爱人的生日、每天的起床时间等等、还有突发性的计算机大降价 (啊！真希望天天都有！) 
	等等罗。</p>

	<p>像上面这些例行性工作，通常你得要记录在行事历上面才能避免忘记！不过，由於我们常常在计算机前面的缘故，
	如果计算机系统能够主动的通知我们的话，那么不就轻松多了！嘿嘿！这个时候 Linux 的例行性工作排程就可以派上场了！
	在不考虑硬件与我们服务器的连结状态下，我们的 Linux 可以帮你提醒很多任务，例如：每一天早上 
	8:00 钟要服务器连接上音响，并启动音乐来唤你起床；而中午
	12:00 希望 Linux 可以发一封信到你的邮件信箱，提醒你可以去吃午餐了；
	另外，在每年的你爱人生日的前一天，先发封信提醒你，以免忘记这么重要的一天。</p>

	<p>那么 Linux 的例行性工作是如何进行排程的呢？所谓的排程就是将这些工作安排运行的流程之意！
	咱们的 Linux 排程就是透过 crontab 与 at 这两个东西！这两个玩意儿有啥异同？就让我们来瞧瞧先！<br><br></p>

	<hr><a name="whatiscron_type"></a><img src="./鸟哥的 Linux 私房菜17 -- 例行性工作排程的创建_files/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">Linux 工作排程的种类： 
	at, cron</span><br>
	<div class="block2">
		<p>从上面的说明当中，我们可以很清楚的发现两种工作排程的方式：</p>

		<ul>
		<li>一种是例行性的，就是每隔一定的周期要来办的事项；</li>
		<li>一种是突发性的，就是这次做完以后就没有的那一种 (计算机大降价...)</li>
		</ul>

		<p>那么在 Linux 底下如何达到这两个功能呢？那就得使用 at 与 crontab 这两个好东西罗！</p>

		<ul>
		<li><span class="text_import1">at</span> ：at 是个可以处理仅运行一次就结束排程的命令，不过要运行 at 时，
		必须要有 atd 这个<a href="http://cn.linux.vbird.org/linux_basic/0560daemons.php">服务 (第十八章)</a> 的支持才行。在某些新版的 distributions 
		中，atd 可能默认并没有启动，那么 at 这个命令就会失效呢！不过我们的 CentOS 默认是启动的！<br><br></li>

		<li><span class="text_import1">crontab</span> ：crontab 这个命令所配置的工作将会循环的一直进行下去！
		可循环的时间为分钟、小时、每周、每月或每年等。crontab 除了可以使用命令运行外，亦可编辑 /etc/crontab 来支持。
		至於让 crontab 可以生效的服务则是 crond 这个服务喔！</li>
		</ul>

		<p>底下我们先来谈一谈 Linux 的系统到底在做什么事情，怎么有若干多的工作排程在进行呢？然后再回来谈一谈
		at 与 crontab 这两个好东西！</p>
	</div>

	<hr><a name="whatiscron_linux"></a><img src="./鸟哥的 Linux 私房菜17 -- 例行性工作排程的创建_files/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">Linux 上常见的例行性工作</span><br>
	<div class="block2">
		<p>如果你曾经使用过 Linux 一阵子了，那么你大概会发现到 Linux 会主动的帮我们进行一些工作呢！
		比方说自动的进行线上升级 (on-line update)、自动的进行 updatedb (<a href="http://cn.linux.vbird.org/linux_basic/0220filemanager.php#locate">第七章谈到的 locate 命令</a>) 升级档名数据库、自动的作登录档分析
		(所以 root 常常会收到标题为 logwatch 的信件) 等等。这是由於系统要正常运行的话，
		某些在背景底下的工作必须要定时进行的缘故。基本上 Linux 系统常见的例行性任务有：</p>

		<ul style="padding-left: 25px;">
		<li><span class="text_import2">进行登录档的轮替 (log rotate)</span>：<br>
		Linux 会主动的将系统所发生的各种资讯都记录下来，这就是<a href="http://cn.linux.vbird.org/linux_basic/0570syslog.php">登录档 (第十九章)</a>。
		由於系统会一直记录登录资讯，所以登录档将会越来越大！我们知道大型文件不但占容量还会造成读写效能的困扰，
		因此适时的将登录档数据挪一挪，让旧的数据与新的数据分别存放，则比较可以有效的记录登录资讯。这就是 log rotate 
		的任务！这也是系统必要的例行任务；<br><br></li>

		<li><span class="text_import2">登录档分析 logwatch 的任务</span>：<br>
		如果系统发生了软件问题、硬件错误、资安问题等，绝大部分的错误资讯都会被记录到登录档中，
		因此系统管理员的重要任务之一就是分析登录档。但你不可能手动透过 vim 等软件去检视登录档，因为数据太复杂了！
		我们的 CentOS 提供了一只程序『 logwatch 』来主动分析登录资讯，所以你会发现，你的 root 老是会收到标题为 logwatch
		的信件，那是正常的！你最好也能够看看该信件的内容喔！<br><br></li>

		<li><span class="text_import2">创建 locate 的数据库</span>：<br>
		在第七章我们谈到的 <a href="http://cn.linux.vbird.org/linux_basic/0220filemanager.php#locate">locate</a> 命令时，
		我们知道该命令是透过已经存在的档名数据库来进行系统上档名的查询。我们的档名数据库是放置到 /var/lib/mlocate/ 中。
		问题是，这个数据库怎么会自动升级啊？嘿嘿！这就是系统的例行性工作所产生的效果啦！系统会主动的进行
		updatedb 喔！<br><br></li>

		<li><span class="text_import2">whatis 数据库的创建</span>：<br>
		与 locate 数据库类似的，whatis 也是个数据库，这个 whatis 是与
		<a href="http://cn.linux.vbird.org/linux_basic/0160startlinux.php#manual_man">man page</a> 有关的一个查询命令，不过要使用 whatis 命令时，
		必须要拥有 whatis 数据库，而这个数据库也是透过系统的例行性工作排程来自动运行的哩！<br><br></li>

		<li><span class="text_import2">RPM 软件登录档的创建</span>：<br>
		RPM (<a href="http://cn.linux.vbird.org/linux_basic/0520rpm_and_srpm.php">第二十三章</a>) 是一种软件管理的机制。由於系统可能会常常变更软件，
		包括软件的新安装、非经常性升级等，都会造成软件档名的差异。为了方便未来追踪，系统也帮我们将档名作个排序的记录呢！
		有时候系统也会透过排程来帮忙 RPM 数据库的重新建置喔！<br><br></li>

		<li><span class="text_import2">移除缓存档</span>：<br>
		某些软件在运行中会产生一些缓存档，但是当这个软件关闭时，这些缓存档可能并不会主动的被移除。
		有些缓存档则有时间性，如果超过一段时间后，这个缓存档就没有效用了，此时移除这些缓存档就是一件重要的工作！
		否则磁碟容量会被耗光。系统透过例行性工作排程运行名为 tmpwatch 的命令来删除这些缓存档呢！<br><br></li>

		<li><span class="text_import2">与网络服务有关的分析行为</span>：<br>
		如果你有安装类似 WWW 服务器软件 (一个名为 apache 的软件)，那么你的 Linux 系统通常就会主动的分析该软件的登录档。
		同时某些凭证与认证的网络资讯是否过期的问题，我们的 Linux 系统也会很亲和的帮你进行自动检查！</li>
		</ul>

		<p>其实你的系统会进行的例行性工作与你安装的软件多寡有关，如果你安装过多的软件，某些服务功能的软件都会附上分析工具，
		那么你的系统就会多出一些例行性工作罗！像鸟哥的主机还多加了很多自己撰写的分析工具，以及其他第三方协力软件的分析软件，
		嘿嘿！俺的 Linux 工作量可是非常大的哩！因为有这么多的工作需要进行，所以我们当然得要了解例行性工作的处理方式罗！</p>
	</div>
</div>


<hr><a name="atjob"></a><img src="./鸟哥的 Linux 私房菜17 -- 例行性工作排程的创建_files/logo.png" alt="大标题的图示" width="35" align="middle" height="34"><span class="text_h1">仅运行一次的工作排程</span><br>
<div class="block1">
	<p>首先，我们先来谈谈单一工作排程的运行，那就是 at 这个命令的运行！<br><br></p>

	<hr><a name="atjob_how"></a><img src="./鸟哥的 Linux 私房菜17 -- 例行性工作排程的创建_files/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">atd 的启动与 at 运行的方式</span><br>
	<div class="block2">
		<p>要使用单一工作排程时，我们的 Linux 系统上面必须要有负责这个排程的服务，那就是 atd 这个玩意儿。
		不过并非所有的 Linux distributions 都默认会把他打开的，所以呢，某些时刻我们必须要手动将他激活才行。
		激活的方法很简单，就是这样：</p>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">/etc/init.d/atd restart</span>
正在停止 atd:                          [  确定  ]
正在启动 atd:                          [  确定  ]

<span class="term_hd"># 再配置一下启动时就启动这个服务，免得每次重新启动都得再来一次！</span>
[root@www ~]# <span class="term_command">chkconfig atd on</span>
</pre></td></tr></tbody></table>

		<p>重点是那个『正在启动(或 starting)』项目的 OK 啦！那表示启动是正常的！这部份我们在<a href="http://cn.linux.vbird.org/linux_basic/0560daemons.php">第十八章</a>会谈及。
		如果您真的有兴趣，那么可以自行到 /etc/init.d/atd 这个 shell script 内去瞧一瞧先！ ^_^。
		至於那个 chkconfig ，你也可以使用 man 先查阅一下啊！我们<a href="http://cn.linux.vbird.org/linux_basic/0560daemons.php#chkconfig">第十八章</a>再介绍啦！<br><br></p>

		<hr><ul class="list1"><li class="text_import1">at 的运行方式</li></ul>

		<p>既然是工作排程，那么应该会有产生工作的方式，并且将这些工作排进行程表中罗！OK！那么产生工作的方式是怎么进行的？
		事实上，<span class="text_import2">我们使用 at 这个命令来产生所要运行的工作，并将这个工作以文字档的方式写入
		/var/spool/at/ 目录内，该工作便能等待 atd 这个服务的取用与运行了</span>。就这么简单。</p>

		<p>不过，并不是所有的人都可以进行 at 工作排程喔！为什么？因为安全的理由啊～
		很多主机被所谓的『绑架』后，最常发现的就是他们的系统当中多了很多的怪客程序 (cracker program)，
		这些程序非常可能运用工作排程来运行或搜集系统资讯，并定时的回报给怪客团体！
		所以罗，除非是你认可的帐号，否则先不要让他们使用 at 吧！那怎么达到使用 at 的列管呢？</p>

		<a name="at_deny"></a>
		<p>我们可以利用 /etc/at.allow 与 /etc/at.deny 这两个文件来进行 at 的使用限制呢！
		加上这两个文件后， at 的工作情况其实是这样的：</p>

		<ol class="text_import2">
		<li>先找寻 <b>/etc/at.allow</b> 这个文件，写在这个文件中的使用者才能使用 at
		，没有在这个文件中的使用者则不能使用 at (即使没有写在 at.deny 当中)；<br><br></li>
		<li>如果 /etc/at.allow 不存在，就寻找<b> /etc/at.deny</b> 这个文件，若写在这个
		at.deny 的使用者则不能使用 at ，而没有在这个 at.deny 文件中的使用者，就可以使用
		at 咯；<br><br></li>
		<li>如果两个文件都不存在，那么只有 root 可以使用 at 这个命令。</li>
		</ol>

		<p>透过这个说明，我们知道 /etc/at.allow 是管理较为严格的方式，而 /etc/at.deny 则较为松散 
		(因为帐号没有在该文件中，就能够运行 at 了)。在一般的 distributions 当中，由於假设系统上的所有用户都是可信任的，
		因此系统通常会保留一个空的 /etc/at.deny 文件，意思是允许所有人使用 at 命令的意思 (您可以自行检查一下该文件)。
		不过，万一你不希望有某些使用者使用 at 的话，将那个使用者的帐号写入 /etc/at.deny 即可！
		一个帐号写一行。</p>
	</div>


	<hr><a name="atjob_work"></a><img src="./鸟哥的 Linux 私房菜17 -- 例行性工作排程的创建_files/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">实际运行单一工作排程</span><br>
	<div class="block2">
		<a name="at"></a>
		<p>单一工作排程的进行就使用 at 这个命令罗！这个命令的运行非常简单！将 at 加上一个时间即可！基本的语法如下：</p>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">at [-mldv] TIME</span>
[root@www ~]# <span class="term_command">at -c 工作号码</span>
<span class="term_say">选项与参数：
-m  ：当 at 的工作完成后，即使没有输出信息，亦以 email 通知使用者该工作已完成。
-l  ：at -l 相当於 atq，列出目前系统上面的所有该使用者的 at 排程；
-d  ：at -d 相当於 atrm ，可以取消一个在 at 排程中的工作；
-v  ：可以使用较明显的时间格式列出 at 排程中的工作列表；
-c  ：可以列出后面接的该项工作的实际命令内容。

TIME：时间格式，这里可以定义出『什么时候要进行 at 这项工作』的时间，格式有：
  HH:MM				ex&gt; 04:00
	在今日的 HH:MM 时刻进行，若该时刻已超过，则明天的 HH:MM 进行此工作。
  HH:MM YYYY-MM-DD		ex&gt; 04:00 2009-03-17
	强制规定在某年某月的某一天的特殊时刻进行该工作！
  HH:MM[am|pm] [Month] [Date]	ex&gt; 04pm March 17
	也是一样，强制在某年某月某日的某时刻进行！
  HH:MM[am|pm] + number [minutes|hours|days|weeks]
	ex&gt; now + 5 minutes	ex&gt; 04pm + 3 days
	就是说，在某个时间点『再加几个时间后』才进行。</span>
</pre></td></tr></tbody></table>

		<p>老实说，这个 at 命令的下达最重要的地方在於『时间』的指定了！鸟哥喜欢使用『 now + ... 』
		的方式来定义现在过多少时间再进行工作，但有时也需要定义特定的时间点来进行！底下的范例先看看罗！</p>

<table class="term"><tbody><tr><td class="term"><pre><span class="term_hd">范例一：再过五分钟后，将 /root/.bashrc 寄给 root 自己</span>
[root@www ~]# <span class="term_command">at now + 5 minutes</span>  <span class="term_note">&lt;==记得单位要加 s 喔！</span>
at&gt; <span class="term_command">/bin/mail root -s "testing at job" &lt; /root/.bashrc</span>
at&gt; &lt;EOT&gt;   <span class="term_note">&lt;==这里输入 [ctrl] + d 就会出现 &lt;EOF&gt; 的字样！代表结束！</span>
job 4 at 2009-03-14 15:38
<span class="term_say"># 上面这行资讯在说明，第 4 个 at 工作将在 2009/03/14 的 15:38 进行！
# 而运行 at 会进入所谓的 at shell 环境，让你下达多重命令等待运行！</span>

<span class="term_hd">范例二：将上述的第 4 项工作内容列出来查阅</span>
[root@www ~]# <span class="term_command">at -c 4</span>
#!/bin/sh               <span class="term_note">&lt;==就是透过 bash shell 的啦！</span>
# atrun uid=0 gid=0
# mail     root 0
umask 22
<span class="term_say">....(中间省略许多的环境变量项目)....</span>
cd /root || {           <span class="term_note">&lt;==可以看出，会到下达 at 时的工作目录去运行命令</span>
         echo 'Execution directory inaccessible' &gt;&amp;2
         exit 1
}

/bin/mail root -s "testing at job" &lt; /root/.bashrc
<span class="term_say"># 你可以看到命令运行的目录 (/root)，还有多个环境变量与实际的命令内容啦！</span>

<span class="term_hd">范例三：由於机房预计於 2009/03/18 停电，我想要在 2009/03/17 23:00 关机？</span>
[root@www ~]# <span class="term_command">at 23:00 2009-03-17</span>
at&gt; <span class="term_write">/bin/sync</span>
at&gt; <span class="term_write">/bin/sync</span>
at&gt; <span class="term_write">/sbin/shutdown -h now</span>
at&gt; &lt;EOT&gt;
job 5 at 2009-03-17 23:00
<span class="term_say"># 您瞧瞧！ at 还可以在一个工作内输入多个命令呢！不错吧！</span>
</pre></td></tr></tbody></table>

		<p>事实上，当我们使用 at 时会进入一个 at shell 的环境来让使用者下达工作命令，此时，<span class="text_import2">建议你最好使用绝对路径来下达你的命令，比较不会有问题喔</span>！由於命令的下达与 PATH 变量有关，
		同时与当时的工作目录也有关连 (如果有牵涉到文件的话)，因此使用绝对路径来下达命令，会是比较一劳永逸的方法。
		为什么呢？举例来说，你在 /tmp 下达『 at now 』然后输入『 mail root -s "test" &lt; .bashrc 』，
		问一下，那个 .bashrc 的文件会是在哪里？答案是『 /tmp/.bashrc 』！因为<span class="text_import2">
		at 在运行时，会跑到当时下达 at 命令的那个工作目录</span>的缘故啊！</p>

		<p>有些朋友会希望『我要在某某时刻，在我的终端机显示出 Hello 的字样』，然后就在 at 里面下达这样的资讯『
		echo "Hello" 』。等到时间到了，却发现没有任何信息在萤幕上显示，这是啥原因啊？<span class="text_import2">这是因为 at 的运行与终端机环境无关，而所有 standard output/standard error output
		都会传送到运行者的 mailbox 去</span>啦！所以在终端机当然看不到任何资讯。那怎办？没关系，
		可以透过终端机的装置来处理！假如你在 tty1 登陆，则可以使用『 echo "Hello" &gt; /dev/tty1 』来取代。</p>

		<div style="padding: 10pt 0pt;" align="right"><table width="90%"><tbody><tr><td><b>Tips:</b><br><span style="color: rgb(0, 144, 0);"><font size="-1">		要注意的是，如果在 at shell 内的命令并没有任何的信息输出，那么 at 默认不会发 email 给运行者的。
		如果你想要让 at 无论如何都发一封 email 告知你是否运行了命令，那么可以使用『 at -m 时间格式 』来下达命令喔！
		at 就会传送一个信息给运行者，而不论该命令运行有无信息输出了！
		</font></span></td><td><img src="./鸟哥的 Linux 私房菜17 -- 例行性工作排程的创建_files/vbird_face.gif" alt="鸟哥的图示" title="鸟哥的图示"></td></tr></tbody></table></div>
		<p>at 有另外一个很棒的优点，那就是『背景运行』的功能了！什么是背景运行啊？很难了解吗？其实与 bash 的 nohup 
		(<a href="http://cn.linux.vbird.org/linux_basic/0440processcontrol.php#nohup">第十七章</a>) 类似啦！
		鸟哥提我自己的几个例子来给您听听，您就了了！</p>

		<ul>
		<li><span class="text_import2">离线继续工作的任务</span>：鸟哥初次接触 Unix 为的是要跑空气品质模式，
		那是一种大型的程序，这个程序在当时的硬件底下跑，一个案例要跑 3 天！由於鸟哥也要进行其他研究工作，因此常常使用 Windows
		98 来连线到 Unix 工作站跑那个 3 天的案例！结果你也该知道， Windows 98 连开三天而不死机的机率是很低的～@_@～
		而死机时，所有在 Windows 上的连线都会中断！包括鸟哥在跑的那个程序也中断了～呜呜～明明再三个钟头就跑完的程序，
		由於死机害我又得跑 3 天！<br><br></li>


		<li>另一个常用的时刻则是例如上面的范例三，由於某个突发状况导致你必须要进行某项工作时，这个 at 就很好用啦！</li>
		</ul>

		<p><span class="text_import2">由於 at 工作排程的使用上，系统会将该项 at 工作独立出你的 bash 环境中，
		直接交给系统的 atd 程序来接管，因此，当你下达了 at 的工作之后就可以立刻离线了，
		剩下的工作就完全交给 Linux 管理即可</span>！所以罗，如果有长时间的网络工作时，嘿嘿！
		使用 at 可以让你免除网络断线后的困扰喔！ ^_^<br><br></p>

		<a name="atq_atrm"></a>
		<hr><ul class="list1"><li class="text_import1">at 工作的管理</li></ul>

		<p>那么万一我下达了 at 之后，才发现命令输入错误，该如何是好？就将他移除啊！利用 atq 与 atrm 吧！</p>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">atq</span>
[root@www ~]# <span class="term_command">atrm (jobnumber)</span>

<span class="term_hd">范例一：查询目前主机上面有多少的 at 工作排程？</span>
[root@www ~]# <span class="term_command">atq</span>
5       2009-03-17 23:00 a root
<span class="term_say"># 上面说的是：『在 2009/03/17 的 23:00 有一项工作，该项工作命令下达者为 
# root』而且，该项工作的工作号码 (jobnumber) 为 5 号喔！</span>

<span class="term_hd">范例二：将上述的第 5 个工作移除！</span>
[root@www ~]# <span class="term_command">atrm 5</span>
[root@www ~]# <span class="term_command">atq</span>
<span class="term_say"># 没有任何资讯，表示该工作被移除了！</span>
</pre></td></tr></tbody></table>

		<p>如此一来，你可以利用 atq 来查询，利用 atrm 来删除错误的命令，利用 at 来直接下达单一工作排程！很简单吧！
		不过，有个问题需要处理一下。<span class="text_import2">如果你是在一个非常忙碌的系统下运行 at ，
		能不能指定你的工作在系统较闲的时候才进行</span>呢？可以的，那就使用 batch 命令吧！<br><br></p>

		<a name="batch"></a>
		<hr><ul class="list1"><li class="text_import1">batch：系统有空时才进行背景任务</li></ul>

		<p>其实 batch 是利用 at 来进行命令的下达啦！只是加入一些控制参数而已。这个 batch 神奇的地方在於：<span class="text_import2">他会在 CPU 工作负载小於 0.8 的时候，才进行你所下达的工作任务</span>啦！
		那什么是负载 0.8 呢？这个负载的意思是： CPU 在单一时间点所负责的工作数量。不是 CPU 的使用率喔！
		举例来说，如果我有一只程序他需要一直使用 CPU 的运算功能，那么此时 CPU 的使用率可能到达 100% ，
		但是 CPU 的工作负载则是趋近於『 1 』，因为 CPU 仅负责一个工作嘛！如果同时运行这样的程序两支呢？
		CPU 的使用率还是 100% ，但是工作负载则变成 2 了！了解乎？</p>

		<p>所以也就是说，当 CPU 的工作负载越大，代表 CPU 必须要在不同的工作之间进行频繁的工作切换。
		这样的 CPU 运行情况我们在第零章有谈过，忘记的话请回去瞧瞧！因为一直切换工作，所以会导致系统忙碌啊！
		系统如果很忙碌，还要额外进行 at ，不太合理！所以才有 batch 命令的产生！</p>

		<p>那么 batch 如何下达命令呢？很简单啊！与 at 相同啦！例如下面的范例：</p>

<table class="term"><tbody><tr><td class="term"><pre><span class="term_hd">范例一：同样是机房停电在 2009/3/17 23:00 关机，但若当时系统负载太高，则暂缓运行</span>
[root@www ~]# <span class="term_command">batch 23:00 2009-3-17</span>
at&gt; <span class="term_command">sync</span>
at&gt; <span class="term_command">sync</span>
at&gt; <span class="term_command">shutdown -h now</span>
at&gt; &lt;EOT&gt;
job 6 at 2009-03-17 23:00

[root@www ~]# <span class="term_command">atq</span>
6       2009-03-17 23:00 b root
[root@www ~]# <span class="term_command">atrm 6</span>
</pre></td></tr></tbody></table>

		<p>你会发现其实 batch 也是使用 atq/atrm 来管理的！这样了解乎？</p>
	</div>
</div>


<hr><a name="cron"></a><img src="./鸟哥的 Linux 私房菜17 -- 例行性工作排程的创建_files/logo.png" alt="大标题的图示" width="35" align="middle" height="34"><span class="text_h1">循环运行的例行性工作排程</span><br>
<div class="block1">
	<p>相对於 at 是仅运行一次的工作，<span class="text_import2">循环运行的例行性工作排程则是由 cron (crond)
	这个系统服务来控制的</span>。刚刚谈过 Linux 系统上面原本就有非常多的例行性工作，因此这个系统服务是默认启动的。另外，
	由於使用者自己也可以进行例行性工作排程，所以罗， Linux 也提供使用者控制例行性工作排程的命令 (crontab)。
	底下我们分别来聊一聊罗！<br><br></p>

	<hr><a name="crontab_user"></a><img src="./鸟哥的 Linux 私房菜17 -- 例行性工作排程的创建_files/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">使用者的配置</span><br>
	<div class="block2">
		<a name="cron_deny"></a>
		<p>使用者想要创建循环型工作排程时，使用的是 crontab 这个命令啦～不过，为了安全性的问题，
		与 at 同样的，我们可以限制使用 crontab 的使用者帐号喔！使用的限制数据有：</p>

		<ul>
		<li><span class="text_import2">/etc/cron.allow</span>：<br>
		将可以使用 crontab 的帐号写入其中，若不在这个文件内的使用者则不可使用 crontab；<br><br></li>

		<li><span class="text_import2">/etc/cron.deny</span>：<br>
		将不可以使用 crontab 的帐号写入其中，若未记录到这个文件当中的使用者，就可以使用 crontab 。</li></ul>

		<p>与 at 很像吧！同样的，以优先顺序来说， /etc/cron.allow 比 /etc/cron.deny 要优先，
		而判断上面，这两个文件只选择一个来限制而已，因此，建议你只要保留一个即可，
		免得影响自己在配置上面的判断！一般来说，系统默认是保留 /etc/cron.deny ，
		你可以将不想让他运行 crontab 的那个使用者写入 /etc/cron.deny 当中，一个帐号一行！</p>

		<p><span class="text_import2">当使用者使用 crontab 这个命令来创建工作排程之后，该项工作就会被纪录到 /var/spool/cron/ 
		里面去了，而且是以帐号来作为判别的喔</span>！举例来说， dmtsai 使用 crontab 后，
		他的工作会被纪录到 /var/spool/cron/dmtsai 里头去！但请注意，<span class="text_import2">不要使用 vi 直接编辑该文件，
		因为可能由於输入语法错误，会导致无法运行 cron 喔</span>！另外， cron 运行的每一项工作都会被纪录到
		/var/log/cron 这个登录档中，所以罗，如果你的 Linux 不知道有否被植入木马时，也可以搜寻一下 /var/log/cron 
		这个登录档呢！</p>

		<a name="crontab"></a>
		<p>好了，那么我们就来聊一聊 crontab 的语法吧！</p>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">crontab [-u username] [-l|-e|-r]</span>
<span class="term_say">选项与参数：
-u  ：只有 root 才能进行这个任务，亦即帮其他使用者创建/移除 crontab 工作排程；
-e  ：编辑 crontab 的工作内容
-l  ：查阅 crontab 的工作内容
-r  ：移除所有的 crontab 的工作内容，若仅要移除一项，请用 -e 去编辑。</span>

<span class="term_hd">范例一：用 dmtsai 的身份在每天的 12:00 发信给自己</span>
[dmtsai@www ~]$ <span class="term_command">crontab -e</span>
<span class="term_say"># 此时会进入 vi 的编辑画面让您编辑工作！注意到，每项工作都是一行。</span>
<span class="term_write">0   12  *  *  * mail dmtsai -s "at 12:00" &lt; /home/dmtsai/.bashrc</span>
<span class="term_say">#分 时 日 月 周 |&lt;==============命令串========================&gt;|</span>
</pre></td></tr></tbody></table>

		<p>默认情况下，任何使用者只要不被列入 /etc/cron.deny 当中，那么他就可以直接下达『 crontab -e 
		』去编辑自己的例行性命令了！整个过程就如同上面提到的，会进入 vi 的编辑画面，
		然后以一个工作一行来编辑，编辑完毕之后输入『 :wq 』储存后离开 vi 就可以了！
		而每项工作 (每行) 的格式都是具有六个栏位，这六个栏位的意义为：</p>

<table bgcolor="lightyellow" border="1" cellpadding="3" cellspacing="0" width="95%">
<tbody><tr align="center" bgcolor="#182448"><td><font color="#FFFFFF">代表意义</font></td><td><font color="#FFFFFF">分钟</font></td><td><font color="#FFFFFF">小时</font></td><td><font color="#FFFFFF">日期</font></td><td><font color="#FFFFFF">月份</font></td><td><font color="#FFFFFF">周</font></td><td><font color="#FFFFFF">命令</font></td></tr>
<tr align="center"><td bgcolor="#182448"><font color="#FFFFFF">数字范围</font></td><td>0-59</td><td>0-23</td><td>1-31</td><td>1-12</td><td>0-7</td>
	<td>呀就命令啊</td></tr>
</tbody></table><br>

		<p>比较有趣的是那个『周』喔！周的数字为 0 或 7 时，都代表『星期天』的意思！另外，
		还有一些辅助的字符，大概有底下这些：</p>

<table bgcolor="lightyellow" border="1" cellpadding="3" cellspacing="0" width="95%">
<tbody><tr align="center" bgcolor="#182448"><td width="70"><font color="#FFFFFF">特殊字符</font></td><td><font color="#FFFFFF">代表意义</font></td></tr>
<tr><td align="center">*(星号)</td><td>代表任何时刻都接受的意思！举例来说，范例一内那个日、月、周都是 * ，
	就代表著『不论何月、何日的礼拜几的 12:00 都运行后续命令』的意思！</td></tr>
<tr><td align="center">,(逗号)</td><td>代表分隔时段的意思。举例来说，如果要下达的工作是 3:00 与 6:00 时，就会是：
	<blockquote class="text_import2" style="font-family: &#39;细明体&#39;;">0 3,6 * * * command</blockquote>
	时间参数还是有五栏，不过第二栏是 3,6 ，代表 3 与 6 都适用！</td></tr>
<tr><td align="center">-(减号)</td><td>代表一段时间范围内，举例来说， 8 点到 12 点之间的每小时的 20 分都进行一项工作：
	<blockquote class="text_import2" style="font-family: &#39;细明体&#39;;">20 8-12 * * * command</blockquote>
	仔细看到第二栏变成 8-12 喔！代表 8,9,10,11,12 都适用的意思！</td></tr>
<tr><td align="center">/n(斜线)</td><td>那个 n 代表数字，亦即是『每隔 n 单位间隔』的意思，例如每五分钟进行一次，则：<br>
	<blockquote class="text_import2" style="font-family: &#39;细明体&#39;;">*/5 * * * * command</blockquote>
	很简单吧！用 * 与 /5 来搭配，也可以写成 0-59/5 ，相同意思！</td></tr>
</tbody></table>

		<p>我们就来搭配几个例子练习看看吧！底下的案例请实际用 dmtsai 
		这个身份作看看喔！后续的动作才能够搭配起来！</p>

<table border="1" cellpadding="5" cellspacing="0" width="90%"><tbody><tr><td>
例题：<div class="block2">
假若你的女朋友生日是 5 月 2 日，你想要在 5 月 1 日的 23:59 发一封信给他，这封信的内容已经写在
/home/dmtsai/lover.txt 内了，该如何进行？
</div>
答：<div class="block2">
直接下达 crontab -e 之后，编辑成为：<blockquote class="text_import2" style="font-family: &#39;细明体&#39;;">
59 23 1 5  *  mail kiki &lt; /home/dmtsai/lover.txt</blockquote>
那样的话，每年 kiki 都会收到你的这封信喔！（当然罗，信的内容就要每年变一变啦！）
</div>
</td></tr></tbody></table><br>

<table border="1" cellpadding="5" cellspacing="0" width="90%"><tbody><tr><td>
例题：<div class="block2">
假如每五分钟需要运行  /home/dmtsai/test.sh 一次，又该如何？
</div>
答：<div class="block2">
同样使用 crontab -e 进入编辑：<blockquote class="text_import2" style="font-family: &#39;细明体&#39;;">
*/5 * * * * /home/dmtsai/test.sh</blockquote>
</div>
</td></tr></tbody></table>

		<p>那个 crontab 每个人都只有一个文件存在，就是在 /var/spool/cron 里面啊！
		还有建议您：『<span class="text_import2">命令下达时，最好使用绝对路径，这样比较不会找不到运行档喔</span>！』</p>

<table border="1" cellpadding="5" cellspacing="0" width="90%"><tbody><tr><td>
例题：<div class="block2">
假如你每星期六都与朋友有约，那么想要每个星期五下午 4:30 告诉你朋友星期六的约会不要忘记，则：
</div>
答：<div class="block2">
还是使用 crontab -e 啊！<blockquote class="text_import2">
30 16 * * 5 mail friend@his.server.name &lt; /home/dmtsai/friend.txt</blockquote>
</div>
</td></tr></tbody></table><br>

		<p>真的是很简单吧！呵呵！那么，该如何查询使用者目前的 crontab 内容呢？我们可以这样来看看：</p>

<table class="term"><tbody><tr><td class="term"><pre>[dmtsai@www ~]$ <span class="term_command">crontab -l</span>
59 23 1 5 * mail kiki &lt; /home/dmtsai/lover.txt
*/5 * * * * /home/dmtsai/test.sh
30 16 * * 5 mail friend@his.server.name &lt; /home/dmtsai/friend.txt

<span class="term_hd"># 注意，若仅想要移除一项工作而已的话，必须要用 crontab -e 去编辑～
# 如果想要全部的工作都移除，才使用 crontab -r 喔！</span>
[dmtsai@www ~]$ <span class="term_command">crontab -r</span>
[dmtsai@www ~]$ <span class="term_command">crontab -l</span>
no crontab for dmtsai
</pre></td></tr></tbody></table>

		<p>看到了吗？ crontab 『整个内容都不见了！』所以请注意：『如果只是要删除某个 
		crontab 的工作项目，那么请使用 crontab -e 来重新编辑即可！』如果使用 -r 的参数，是会将所有的 
		crontab 数据内容都删掉的！千万注意了！</p>
	</div>

	<hr><a name="etc_crontab1"></a><img src="./鸟哥的 Linux 私房菜17 -- 例行性工作排程的创建_files/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">系统的配置档： /etc/crontab</span><br>
	<div class="block2">
		<p>这个『 crontab -e 』是针对使用者的 cron 来设计的，如果是『系统的例行性任务』时，
		该怎么办呢？是否还是需要以 crontab -e 来管理你的例行性工作排程呢？当然不需要，你只要编辑
		<span class="text_import2">/etc/crontab</span> 这个文件就可以啦！有一点需要特别注意喔！那就是
		crontab -e 这个 crontab 其实是 /usr/bin/crontab 这个运行档，但是 /etc/crontab
		可是一个『纯文字档』喔！你可以 root 的身份编辑一下这个文件哩！</p>

		<p>基本上，<span class="text_import2"> cron 这个服务的最低侦测限制是『分钟』，所以『 cron
		会每分钟去读取一次 /etc/crontab 与 /var/spool/cron 里面的数据内容</span>
		』，因此，只要你编辑完 /etc/crontab 这个文件，并且将他储存之后，那么 
		cron 的配置就自动的会来运行了！</p>

		<div style="padding: 10pt 0pt;" align="right"><table width="90%"><tbody><tr><td><b>Tips:</b><br><span style="color: rgb(0, 144, 0);"><font size="-1">		在 Linux 底下的 crontab 会自动的帮我们每分钟重新读取一次 /etc/crontab 
		的例行工作事项，但是某些原因或者是其他的 Unix 系统中，由於 crontab 
		是读到内存当中的，所以在你修改完 /etc/crontab 之后，可能并不会马上运行，
		这个时候请重新启动 crond 这个服务吧！『/etc/init.d/crond restart』
		</font></span></td><td><img src="./鸟哥的 Linux 私房菜17 -- 例行性工作排程的创建_files/vbird_face.gif" alt="鸟哥的图示" title="鸟哥的图示"></td></tr></tbody></table></div>
		<a name="etc_crontab"></a>
		<p>废话少说，我们就来看一下这个 /etc/crontab 的内容吧！</p>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">cat /etc/crontab</span>
SHELL=/bin/bash                     <span class="term_note">&lt;==使用哪种 shell 介面</span>
PATH=/sbin:/bin:/usr/sbin:/usr/bin  <span class="term_note">&lt;==运行档搜寻路径</span>
MAILTO=root                         <span class="term_note">&lt;==若有额外STDOUT，以 email将数据送给谁</span>
HOME=/                              <span class="term_note">&lt;==默认此 shell 的家目录所在</span>

# run-parts
01  *  *  *  *   root      run-parts /etc/cron.hourly   <span class="term_note">&lt;==每小时</span>
02  4  *  *  *   root      run-parts /etc/cron.daily    <span class="term_note">&lt;==每天</span>
22  4  *  *  0   root      run-parts /etc/cron.weekly   <span class="term_note">&lt;==每周日</span>
42  4  1  *  *   root      run-parts /etc/cron.monthly  <span class="term_note">&lt;==每个月 1 号</span>
<span class="term_say">分 时 日 月 周 运行者身份  命令串</span>
</pre></td></tr></tbody></table>

		<p>看到这个文件的内容你大概就了解了吧！呵呵，没错！这个文件与将刚刚我们下达 
		crontab -e 的内容几乎完全一模一样！只是有几个地方不太相同：</p>

		<ul>
		<li><span class="text_import1">MAILTO=root</span>：<br><br>
		这个项目是说，当 /etc/crontab 这个文件中的例行性工作的命令发生错误时，或者是该工作的运行结果有 
		STDOUT/STDERR 时，会将错误信息或者是萤幕显示的信息传给谁？默认当然是由系统直接寄发一封 mail 给 root 啦！不过，
		由於 root 并无法在用户端中以 POP3 之类的软件收信，因此，鸟哥通常都将这个 e-mail 
		改成自己的帐号，好让我随时了解系统的状况！例如： 
		<span class="text_import2">MAILTO=dmtsai@my.host.name</span><br><br></li>

		<li><span class="text_import1">PATH=....</span>：<br><br>
		还记得我们在<a href="http://cn.linux.vbird.org/linux_basic/0320bash.php#env">第十一章的 BASH</a> 当中一直提到的运行档路径问题吧！
		没错啦！这里就是输入运行档的搜寻路径！使用默认的路径配置就已经很足够了！<br><br></li>

		<li><span class="text_import1">01 * * * * root run-parts /etc/cron.hourly</span>：<br><br>
		这个 /etc/crontab 里面预配置义出四项工作任务，分别是每小时、每天、每周及每个月分别进行一次的工作！
		但是在五个栏位后面接的并不是命令，而是一个新的栏位，那就是『<span class="text_import2">运行后面那串命令的身份</span>』为何！这与使用者的 crontab -e 不相同。由於使用者自己的 
		crontab 并不需要指定身份，但 /etc/crontab 里面当然要指定身份啦！以上表的内容来说，系统默认的例行性工作是以 root
		的身份来进行的。<br><br>

		那么后面那串命令是什么呢？你可以使用『 <a href="http://cn.linux.vbird.org/linux_basic/0220filemanager.php#file_find_cmd">which</a> 
		run-parts 』搜寻看看，其实那是一个 bash script 啦！如果你直接进入 /usr/bin/run-parts 去看看，
		会发现这支命令会将后面接的『目录』内的所有文件捉出来运行！这也就是说『<span class="text_import2">
		如果你想让系统每小时主动帮你运行某个命令，将该命令写成 script，并将该文件放置到 /etc/cron.hourly/ 
		目录下即可</span>』的意思！<br><br>

		现在你知道系统是如何进行他默认的一堆例行性工作排程了吗？如果你下达『 ll /etc/cron.daily 』就可以看到一堆文件，
		那些文件就是系统提供的 script ，而这堆 scripts 将会在每天的凌晨 4:02 开始运行！这也是为啥如果你是夜猫族，
		就会发现奇怪的是，Linux 系统为何早上 4:02 开始会很忙碌的发出一些硬盘跑动的声音！因为他必须要进行
		makewhatis, updatedb, rpm rebuild 等等的任务嘛！
		</li></ul>

		<p>由於 CentOS 提供的 run-parts 这个 script 的辅助，因此 /etc/crontab 这个文件里面支持两种下达命令的方式，
		一种是直接下达命令，一种则是以目录来规划，例如：</p>

		<ul>
		<li><span class="text_import1">命令型态</span><br>
		<font face="&#39;细明体&#39;">01 * * * * dmtsai mail -s "testing" kiki &lt; /home/dmtsai/test.txt</font><br>
		以 dmtsai 这个使用者的身份，在每小时运行一次 mail 命令。<br><br></li>

		<li><span class="text_import1">目录规划</span><br>
		<font face="&#39;细明体&#39;">*/5 * * * * root run-parts /root/runcron</font><br>
		创建一个 /root/runcron 的目录，将要每隔五分钟运行的『可运行档』都写到该目录下，
		就可以让系统每五分钟运行一次该目录下的所有可运行档。</li>
		</ul>

		<p>好！你现在大概了解了这一个咚咚吧！OK！假设你现在要作一个目录，让系统可以每 
		2 分钟去运行这个目录下的所有可以运行的文件，你可以写下如下的这一行在 /etc/crontab 中：</p>
		<blockquote class="text_import2"><font face="&#39;细明体&#39;">*/2 * * * * root run-parts 
		/etc/cron.min</font></blockquote>

		<p>当然罗， /etc/cron.min 这个目录是需要存在的喔！那如果我需要运行的是一个『程序』而已，
		不需要用到一个目录呢？该如何是好？例如在侦测网络流量时，我们希望每五分钟侦测分析一次，
		可以这样写：</p>
		<blockquote class="text_import2"><font face="&#39;细明体&#39;">*/5 * * * * root 
		/bin/mrtg /etc/mrtg/mrtg.cfg</font></blockquote>

		<p>如何！创建例行性命令很简单吧！如果你是系统管理员而且你的工作又是系统维护方面的例行任务时，
		直接修改 /etc/crontab 这个文件即可喔！又便利，又方便管理呢！</p>
	</div>

	<hr><a name="security"></a><img src="./鸟哥的 Linux 私房菜17 -- 例行性工作排程的创建_files/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">一些注意事项</span><br>
	<div class="block2">
		<p>有的时候，我们以系统的 cron 来进行例行性工作的创建时，要注意一些使用方面的特性。
		举例来说，如果我们有四个工作都是五分钟要进行一次的，那么是否这四个动作全部都在同一个时间点进行？
		如果同时进行，该四个动作又很耗系统资源，如此一来，每五分钟不是会让系统忙得要死？
		呵呵！此时好好的分配一些运行时间就 OK 啦！所以，注意一下：<br><br></p>

		<hr><ul class="list1"><li class="text_import1">资源分配不均的问题</li></ul>

		<p>当大量使用 crontab 的时候，总是会有问题发生的，最严重的问题就是『系统资源分配不均』的问题，
		以鸟哥的系统为例，我有侦测主机流量的资讯，包括：</p>
		<ul>
		<li>流量</li>
		<li>区域内其他 PC 的流量侦测</li>
		<li>CPU 使用率</li>
		<li>RAM 使用率</li>
		<li>线上人数即时侦测</li></ul>
		<p>如果每个流程都在同一个时间启动的话，那么在某个时段时，我的系统会变的相当的繁忙，
		所以，这个时候就必须要分别配置啦！我可以这样做：</p>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">vi /etc/crontab</span>
1,6,11,16,21,26,31,36,41,46,51,56 * * * * root  CMD1
2,7,12,17,22,27,32,37,42,47,52,57 * * * * root  CMD2
3,8,13,18,23,28,33,38,43,48,53,58 * * * * root  CMD3
4,9,14,19,24,29,34,39,44,49,54,59 * * * * root  CMD4
</pre></td></tr></tbody></table>

		<p>看到了没？那个『 , 』分隔的时候，请注意，不要有空白字节！（连续的意思）如此一来，
		则可以将每五分钟工作的流程分别在不同的时刻来工作！则可以让系统的运行较为顺畅呦！<br><br></p>

		<hr><ul class="list1"><li class="text_import1">取消不要的输出项目</li></ul>

		<p>另外一个困扰发生在『 <span class="text_import2">当有运行成果或者是运行的项目中有输出的数据时，该数据将会
		mail 给 MAILTO 配置的帐号</span> 』，好啦，那么当有一个排程一直出错（例如 DNS
		的侦测系统当中，若 DNS 上一级主机挂掉，那么你就会一直收到错误信息！）怎么办？呵呵！还记得<a href="http://cn.linux.vbird.org/linux_basic/0320bash.php#redirect">十一章谈到的数据流重导向</a>吧？
		直接以『命令重导向』将输出的结果输出到 <span class="text_import2">/dev/null</span> 
		这个垃圾桶当中就好了！<br><br></p>

		<hr><ul class="list1"><li class="text_import1">安全的检验</li></ul>

		<p>很多时候被植入木马都是以例行命令的方式植入的，所以可以藉由检查 /var/log/cron
		的内容来视察是否有『非您配置的 cron 被运行了？』这个时候就需要小心一点罗！<br><br></p>

		<hr><ul class="list1"><li class="text_import1">周与日月不可同时并存</li></ul>

		<p>另一个需要注意的地方在於：『你可以分别以周或者是日月为单位作为循环，但你不可使用「几月几号且为星期几」的模式工作』。
		这个意思是说，你不可以这样编写一个工作排程：</p>

<table class="term"><tbody><tr><td class="term"><pre>30 12 11 9 5 root echo "just test"   <span class="term_note">&lt;==这是错误的写法</span>
</pre></td></tr></tbody></table>

		<p>本来你以为九月十一号且为星期五才会进行这项工作，无奈的是，系统可能会判定每个星期五作一次，或每年的 9 月 11 
		号分别进行，如此一来与你当初的规划就不一样了～所以罗，得要注意这个地方！上述的写法是不对的喔！</p>
	</div>
</div>


<hr><a name="anacron_1"></a><img src="./鸟哥的 Linux 私房菜17 -- 例行性工作排程的创建_files/logo.png" alt="大标题的图示" width="35" align="middle" height="34"><span class="text_h1">可唤醒停机期间的工作任务</span><br>
<div class="block1">
	<p>如果你的 Linux 主机是作为 24 小时全天、全年无休的服务器之用，那么你只要有 atd 与 crond 
	这两个服务来管理你的例行性工作排程即可。如果你的服务器并非 24 小时无间断的启动，那么你该如何进行例行性工作？
	举例来说，如果你每天晚上都要关机，等到白天才启动你的 Linux 主机时，由於 CentOS 默认的工作排程都在
	4:02am 每天进行，唔！如此一来不就一堆系统例行工作都没有人在做了！那可怎么办？此时就得要 anacron 这家伙了！<br><br></p>

	<hr><a name="anacron_what"></a><img src="./鸟哥的 Linux 私房菜17 -- 例行性工作排程的创建_files/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">什么是 anacron</span><br>
	<div class="block2">
		<p>anacron 并不是用来取代 crontab 的，anacron 存在的目的就在於我们上头提到的，在处理非 
		24 小时一直启动的 Linux 系统的 crontab 的运行！所以 anacron 并不能指定何时运行某项任务，
		而是以天为单位或者是在启动后立刻进行 anacron 的动作，他会去侦测停机期间应该进行但是并没有进行的
		crontab 任务，并将该任务运行一遍后，anacron 就会自动停止了。</p>

		<p>由於 anacron 会以一天、七天、一个月为期去侦测系统未进行的 crontab 任务，因此对於某些特殊的使用环境非常有帮助。
		举例来说，如果你的 Linux 主机是放在公司给同仁使用的，因为周末假日大家都不在所以也没有必要开启，
		因此你的 Linux 是周末都会关机两天的。但是 crontab 大多在每天的凌晨以及周日的早上进行各项任务，
		偏偏你又关机了，此时系统很多 crontab 的任务就无法进行。 anacron 刚好可以解决这个问题！</p>

		<p>那么 anacron 又是怎么知道我们的系统啥时关机的呢？这就得要使用 anacron 读取的时间记录档 (timestamps) 了！
		anacron 会去分析现在的时间与时间记录档所记载的上次运行 anacron 的时间，两者比较后若发现有差异，
		那就是在某些时刻没有进行 crontab 罗！此时 anacron 就会开始运行未进行的 crontab 任务了！
		<span class="text_import2">所以 anacron 其实也是透过 crontab 
		来运行的！因此 anacron 运行的时间通常有两个，一个是系统启动期间运行，一个是写入 crontab 的排程中。</span>
		这样才能够在特定时间分析系统未进行的 crontab 工作嘛！了解乎！</p>
	</div>

	<hr><a name="anacron"></a><img src="./鸟哥的 Linux 私房菜17 -- 例行性工作排程的创建_files/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">anacron 与 /etc/anacrontab</span><br>
	<div class="block2">
		<p>anacron 其实是一支程序并非一个服务！这支程序在 CentOS 当中已经进入 crontab 的排程喔！
		不相信吗？你可以这样追踪看看：</p>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">ll /etc/cron*/*ana*</span>
-rwxr-xr-x 1 root root 379 Mar 28  2007 /etc/cron.daily/0anacron
-rwxr-xr-x 1 root root 381 Mar 28  2007 /etc/cron.monthly/0anacron
-rwxr-xr-x 1 root root 380 Mar 28  2007 /etc/cron.weekly/0anacron
<span class="term_say"># 刚好是每天、每周、每月有排程的工作目录！查阅一下每天的任务</span>

[root@www ~]# <span class="term_command">cat /etc/cron.daily/0anacron</span>
if [ ! -e /var/run/anacron.pid ]; then
    anacron -u cron.daily
fi
<span class="term_say"># 所以其实也仅是运行 anacron -u 的命令！因此我们得来谈谈这支程序！</span>
</pre></td></tr></tbody></table>

		<p>基本上， anacron 的语法如下：</p>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">anacron [-sfn] [job]..</span>
[root@www ~]# <span class="term_command">anacron -u [job]..</span>
<span class="term_say">选项与参数：
-s  ：开始一连续的运行各项工作 (job)，会依据时间记录档的数据判断是否进行；
-f  ：强制进行，而不去判断时间记录档的时间戳记；
-n  ：立刻进行未进行的任务，而不延迟 (delay) 等待时间；
-u  ：仅升级时间记录档的时间戳记，不进行任何工作。
job ：由 /etc/anacrontab 定义的各项工作名称。</span>
</pre></td></tr></tbody></table>

		<p>所以我们发现<span class="text_import2">其实 /etc/cron.daily/0anacron 
		仅进行时间戳记的升级，而没有进行任何 anacron 的动作</span>！
		在我们的 CentOS 中，anacron 的进行其实是在启动完成后才进行的一项工作任务，你也可以将 anacron 排入 crontab 
		的排程中。但是为了担心 anacron 误判时间参数，因此 /etc/cron.daily/ 里面的 anacron 才会在档名之前加个 0 
		(0anacron)，让 anacron 最先进行！就是为了让时间戳记先升级！以避免 anacron 误判 crontab 
		尚未进行任何工作的意思。</p>

		<p>接下来我们看一下 /etc/anacrontab 的内容好了：</p>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">cat /etc/anacrontab</span>
SHELL=/bin/sh
PATH=/sbin:/bin:/usr/sbin:/usr/bin
MAILTO=root

<u>1       65      cron.daily     run-parts /etc/cron.daily</u>
7       70      cron.weekly    run-parts /etc/cron.weekly
30      75      cron.monthly   run-parts /etc/cron.monthly
<span class="term_say">天数   延迟时间 工作名称定义   实际要进行的命令串
# 天数单位为天；延迟时间单位为分钟；工作名称定义可自订；
# 命令串则通常与 crontab 的配置相同！</span>

[root@www ~]# <span class="term_command">more /var/spool/anacron/*</span>
::::::::::::::
/var/spool/anacron/cron.daily
::::::::::::::
<u>20090315</u>
::::::::::::::
/var/spool/anacron/cron.monthly
::::::::::::::
20090301
::::::::::::::
/var/spool/anacron/cron.weekly
::::::::::::::
20090315
<span class="term_say"># 上面则是三个工作名称的时间记录档以及记录的时间戳记</span>
</pre></td></tr></tbody></table>

		<p>由於 /etc/cron.daily 内的任务比较多，因此我们使用每天进行的任务来解释一下 anacron 的运行情况好了。
		anacron 若下达『 <span class="text_import2">anacron -s cron.daily</span> 』时，他会这样运行的：</p>

		<ol class="text_import2">
		<li>由 /etc/anacrontab 分析到 cron.daily 这项工作名称的天数为 1 天；</li>
		<li>由 /var/spool/anacron/cron.daily 取出最近一次运行 anacron 的时间戳记；</li>
		<li>由上个步骤与目前的时间比较，若差异天数为 1 天以上 (含 1 天)，就准备进行命令；</li>
		<li>若准备进行命令，根据 /etc/anacrontab 的配置，将延迟 65 分钟</li>
		<li>延迟时间过后，开始运行后续命令，亦即『 run-parts /etc/cron.daily 』这串命令；</li>
		<li>运行完毕后， anacron 程序结束。</li>
		</ol>

		<p>所以说，时间戳记是非常重要的！anacron 是透过该记录与目前的时间差异，了解到是否应该要进行某项任务的工作！
		举例来说，如果我的主机在 2009/03/15(星期天) 18:00 关机，然后在 2009/03/16(星期一) 8:00 启动，由於我的 
		crontab 是在早上 04:00 左右进行各项任务，由於该时刻系统是关机的，因此时间戳记依旧为 20090315 (旧的时间)，
		但是目前时间已经是 20090316 (新的时间)，因此 <span class="text_import2">run-parts /etc/cron.daily 
		就会在启动过 65 分钟后开始运行了</span>。</p>

		<p>所以罗， anacron 并不需要额外的配置，使用默认值即可！只是我们的 CentOS 只有在启动时才会运行
		anacron 就是了。如果要确定 anacron 是否启动时会主动的运行，你可以下达下列命令：</p>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">chkconfig --list anacron</span>
anacron      0:off   1:off   2:on    3:on    4:on    5:on    6:off
<span class="term_say"># 详细的 chkconfig 说明我们会在后续章节提到，注意看 3, 5
# 的项目，都是 on ！那就是有启动啦！启动时才会运行的意思！</span>
</pre></td></tr></tbody></table>

		<p>现在你知道<span class="text_import2">为什么隔了一阵子才将 CentOS 启动，启动过后约 1 
		小时左右系统会有一小段时间的忙碌！而且硬盘会跑个不停！那就是因为 anacron 正在运行过去 crontab 
		未进行的各项工作排程啦！</span>这样对 anacron 有没有概念了呢？ ^_^</p>
	</div>
</div>


<hr><a name="hint"></a><img src="./鸟哥的 Linux 私房菜17 -- 例行性工作排程的创建_files/logo.png" alt="大标题的图示" width="35" align="middle" height="34"><span class="text_h1">重点回顾</span><br>
<div class="block1">
<ul class="text_import2">
	<li>系统可以透过 at 这个命令来排程单一工作的任务！『at TIME』为命令下达的方法，当 at 进入排程后，
	系统运行该排程工作时，会到下达时的目录进行任务；</li>
	<li>at 的运行必须要有 atd 服务的支持，且 /etc/at.deny 为控制是否能够运行的使用者帐号；</li>
	<li>透过 atq, atrm 可以查询与删除 at 的工作排程；</li>
	<li>batch 与 at 相同，不过 batch 可在 CPU 工作负载小於 0.8 时才进行后续的工作排程；</li>
	<li>系统的循环例行性工作排程使用 cron 这个服务，同时利用 crontab -e 及 /etc/crontab 进行排程的安排；</li>
	<li>crontab -e 配置项目分为六栏，『分、时、日、月、周、命令』为其配置依据；</li>
	<li>/etc/crontab 配置分为七栏，『分、时、日、月、周、运行者、命令』为其配置依据；</li>
	<li>anacron 配合 /etc/anacrontab  的配置，可以唤醒停机期间系统未进行的 crontab 任务！</li>
</ul>
</div>


<hr><a name="ex"></a><img src="./鸟哥的 Linux 私房菜17 -- 例行性工作排程的创建_files/logo.png" alt="大标题的图示" width="35" align="middle" height="34"><span class="text_h1">本章习题</span><br>
( 要看答案请将鼠标移动到『答：』底下的空白处，按下左键圈选空白处即可察看 )
<div class="block1">
简答题：
<ul>
	<li>今天假设我有一个命令程序，名称为： ping.sh 这个档名！我想要让系统每三分钟运行这个文件一次，
	但是偏偏这个文件会有很多的信息显示出来，所以我的
	root 帐号每天都会收到差不多四百多封的信件，光是收信就差不多快要疯掉了！
	那么请问应该怎么配置比较好呢？
	<div class="blockex">
		这个涉及数据流重导向的问题，我们可以将他导入文件或者直接丢弃！如果该信息不重要的话，
		那么就予以丢弃，如果信息很重要的话，才将他保留下来！假设今天这个命令不重要，
		所以将他丢弃掉！因此，可以这样写：<blockquote>
		*/3 * * * * root /usr/local/ping.sh &gt; /dev/null 2&gt;&amp;1</blockquote>
	</div></li>

	<li>您预计要在 2010 年的 2 月 14 日寄出一封给 kiki ，只有该年才寄出！该如何下达命令？
	<div class="blockex">
		at 1am 2010-02-14
	</div></li>

	<li>下达 crontab -e 之后，如果输入这一行，代表什么意思？<br>
	* 15 * * 1-5 /usr/local/bin/tea_time.sh
	<div class="blockex">
		在每星期的 1~5 ，下午 3 点的每分钟，共进行 60 次 /usr/local/bin/tea_time.sh 这个文件。
		要特别注意的是，每个星期 1~5 的 3 点都会进行 60 次ㄟ！很麻烦吧～是错误的写法啦～
		应该是要写成：<br>
		30 15 * * 1-5 /usr/local/bin/tea_time.sh
	</div></li>

	<li>我用 vi 编辑 /etc/crontab 这个文件，我编辑的那一行是这样的：<br>
	25 00 * * 0   /usr/local/bin/backup.sh<br>
	这一行代表的意义是什么？
	<div class="blockex">
		这一行代表......没有任何意义！因为语法错误！您必须要了解，在 /etc/crontab 
		当中每一行都必须要有使用者才行！所以，应该要将原本那行改成：<br>
		25 00 * * 0 root  /usr/local/bin/backup.sh
	</div></li>

	<li>请问，您的系统每天、每周、每个月各有进行什么工作？
	<div class="blockex">
		因为 CentOS 系统默认的例行性命令都放置在 /etc/cron.* 里面，所以，你可以自行去：
		/etc/cron.daily/, /etc/cron.week/, /etc/cron.monthly/ 这三个目录内看一看，
		就知道啦！ ^_^
	</div></li>

	<li>每个星期六凌晨三点去系统搜寻一下内有 SUID/SGID 的任何文件！并将结果输出到 /tmp/uidgid.files
	<div class="blockex"><font face="&#39;细明体&#39;">
		vi /etc/crontab<br>
		0 3 * * 6 root find / -perm +6000 &gt; /tmp/uidgid.files
	</font></div></li>
</ul>
</div>


<hr><span class="text_history">
2002/05/30：第一次完成<br>
2003/02/10：重新编排与加入 FAQ<br>
2005/09/07：将旧的文章移动到 <a href="http://linux.vbird.org/linux_basic/0430cron/0430cron.php">此处</a> 。<br>
2005/09/07：呼呼！终於完成风格罗～同时加入一些习题练习。<br>
2009/03/12：将旧的文件移动到<a href="http://linux.vbird.org/linux_basic/0430cron/0430cron-fc4.php">此处</a>。<br>
2009/03/14：加入 <a href="http://cn.linux.vbird.org/linux_basic/0430cron.php#batch">batch</a> 这个项目的说明！与 at 有关！<br>
2009/03/15：加入了 anacron  这玩意的简单说明！<br>
2009/09/11：稍微修订一下说明语气与连结数据。<hr>
</span>
    </td>
    <td style="width: 16px; font-size: 6px;">　</td></tr>
<tr><td style="width: 16px; height: 16px;">　</td>
    <td style="width: 866px; height: 16px;">　</td>
    <td style="width: 16px; height: 16px;">　</td></tr>
</tbody></table>

<div style="padding-top: 0px; text-align: center;">
<span style="font-size: 80%;">
	<a href="http://linux.vbird.org/" target="_top" title="前往鸟哥的首页">http://linux.vbird.org</a>
	is designed by <a href="mailto:vbird@mail.vbird.idv.tw" title="联络鸟哥(我不要广告信！)">VBird</a>
		during 2001-2011. <a href="http://www.ksu.edu.tw/" target="_blank">ksu.edu</a></span>
         ﻿<div id="apDiv4">
      <p>本网页主要以Firefox配合解析度 1024x768 作为设计依据&nbsp;&nbsp;&nbsp;&nbsp; 鸟哥自由软件整合应用研究室</p></div></div>
</div>
</center>

</body></html>