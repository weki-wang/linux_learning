
<!-- saved from url=(0052)http://cn.linux.vbird.org/linux_basic/0540kernel.php -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
	
	<meta name="Author" content="2011/04/21,Airman">
	<meta name="Description" content="关於 Linux 的核心编译流程介绍，与注意事项说明！">
	<title>鸟哥的 Linux 私房菜 -- Linux 核心编译</title>
    <script src="./鸟哥的 Linux 私房菜27 -- Linux 核心编译_files/SpryMenuBar.js" type="text/javascript"></script>
	<script src="./鸟哥的 Linux 私房菜27 -- Linux 核心编译_files/index.js" type="text/javascript"></script>
	<link href="./鸟哥的 Linux 私房菜27 -- Linux 核心编译_files/SpryMenuBarHorizontal.css" rel="stylesheet" type="text/css">
    <link href="./鸟哥的 Linux 私房菜27 -- Linux 核心编译_files/main.css" rel="stylesheet" type="text/css">
    </head><body style="margin: 0pt; padding: 0pt;" class="table" onload="MM_preloadImages(&#39;image/title_19.png&#39;,&#39;image/title_26.png&#39;,&#39;image/title_27.png&#39;,&#39;image/title_28.png&#39;,&#39;image/title_06.png&#39;,&#39;image/title_08.png&#39;,&#39;image/title_10.png&#39;,&#39;image/title_12.png&#39;)">

<center>
<div id="apDiv5">
<div> <link rel="SHORTCUT ICON" href="http://cn.linux.vbird.org/linux_basic/favicon.ico">
<!-- ImageReady Slices (title3.ai) -->
<table id="___01" width="898" height="81" border="0" align="center" cellpadding="0" cellspacing="0" ;="">
	<tbody><tr>
		<td colspan="15">
			<img src="./鸟哥的 Linux 私房菜27 -- Linux 核心编译_files/title_01.png" width="900" height="1" alt=""></td>
	</tr>
	<tr>
		<td rowspan="4" bgcolor="#182448"><p><img src="./鸟哥的 Linux 私房菜27 -- Linux 核心编译_files/Count.cgi" width="93" align="left" title="計數器"></p>
	    <p><font color="#FFFFFF" size="-1">since2012/04/23</font></p></td>
		<td rowspan="4" align="left" valign="top"><a href="http://cn.linux.vbird.org/"><img src="./鸟哥的 Linux 私房菜27 -- Linux 核心编译_files/title_03.png" alt="" width="263" height="79" border="0"></a></td>
		<td colspan="13">
			<img src="./鸟哥的 Linux 私房菜27 -- Linux 核心编译_files/title_04.png" alt="" width="535" height="9" border="0"></td>
	</tr>
	<tr>
		<td rowspan="3">
			<img src="./鸟哥的 Linux 私房菜27 -- Linux 核心编译_files/title_05.png" alt="" width="53" height="70" border="0"></td>
		<td colspan="2" align="left" valign="top"><a href="http://cn.linux.vbird.org/linux_basic/0110whatislinux.php" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage(&#39;Image51&#39;,&#39;&#39;,&#39;image/title/title_06.png&#39;,1)"><img src="./鸟哥的 Linux 私房菜27 -- Linux 核心编译_files/title3_06.png" name="Image51" width="106" height="25" border="0" id="Image51" alt=""></a></td>
		<td rowspan="2">
			<img src="./鸟哥的 Linux 私房菜27 -- Linux 核心编译_files/title_07.png" alt="" width="27" height="37" border="0"></td>
		<td colspan="3" align="left" valign="top"><a href="http://cn.linux.vbird.org/linux_server/0110network_basic.php" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage(&#39;Image52&#39;,&#39;&#39;,&#39;image/title/title_08.png&#39;,1)"><img src="./鸟哥的 Linux 私房菜27 -- Linux 核心编译_files/title3_08.png" name="Image52" width="107" height="25" border="0" id="Image52" alt=""></a></td>
		<td rowspan="2">
			<img src="./鸟哥的 Linux 私房菜27 -- Linux 核心编译_files/title_09.png" alt="" width="37" height="37" border="0"></td>
		<td colspan="2" align="left" valign="top"><a href="http://cn.linux.vbird.org/about.php" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage(&#39;Image53&#39;,&#39;&#39;,&#39;image/title/title_10.png&#39;,1)"><img src="./鸟哥的 Linux 私房菜27 -- Linux 核心编译_files/title3_10.png" name="Image53" width="75" height="25" border="0" id="Image53" alt=""></a></td>
		<td rowspan="3">
			<img src="./鸟哥的 Linux 私房菜27 -- Linux 核心编译_files/title_11.png" alt="" width="35" height="70" border="0"></td>
		<td align="left" valign="top"><a href="mailto:vbird@mail.vbird.idv.tw" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage(&#39;Image54&#39;,&#39;&#39;,&#39;image/title/title_12.png&#39;,1)"><img src="./鸟哥的 Linux 私房菜27 -- Linux 核心编译_files/title3_12.png" name="Image54" width="74" height="25" border="0" id="Image54" alt=""></a></td>
		<td rowspan="3">
			<img src="./鸟哥的 Linux 私房菜27 -- Linux 核心编译_files/title_13.png" alt="" width="21" height="70" border="0"></td>
	</tr>
	<tr>
		<td colspan="2">
			<img src="./鸟哥的 Linux 私房菜27 -- Linux 核心编译_files/title_14.png" alt="" width="106" height="12" border="0"></td>
		<td colspan="3">
			<img src="./鸟哥的 Linux 私房菜27 -- Linux 核心编译_files/title_15.png" alt="" width="107" height="12" border="0"></td>
		<td colspan="2">
			<img src="./鸟哥的 Linux 私房菜27 -- Linux 核心编译_files/title_16.png" width="75" height="12" alt=""></td>
		<td rowspan="2">
			<img src="./鸟哥的 Linux 私房菜27 -- Linux 核心编译_files/title_17.png" alt="" width="74" height="45" border="0"></td>
	</tr>
	<tr>
		<td>
			<img src="./鸟哥的 Linux 私房菜27 -- Linux 核心编译_files/title_18.png" alt="" width="15" height="33" border="0"></td>
		<td colspan="3" align="left" valign="top"><ul id="MenuBar1" class="MenuBarHorizontal">
	  <li><a href="http://cn.linux.vbird.org/linux_basic/linux_basic.php" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage(&#39;Image44&#39;,&#39;&#39;,&#39;image/title/title_19.png&#39;,1)" class="MenuBarItemSubmenu"><img src="./鸟哥的 Linux 私房菜27 -- Linux 核心编译_files/title3_19.png" name="Image44" width="123" height="33" border="0" id="Image44"></a>
			    <ul>
			      <li><a href="http://cn.linux.vbird.org/linux_basic/Mandrake9.0/mandrake9.0.php" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage(&#39;Image46&#39;,&#39;&#39;,&#39;image/title/title_26.png&#39;,1)"><img src="./鸟哥的 Linux 私房菜27 -- Linux 核心编译_files/title_23.png" name="Image46" width="120" height="26" border="0" id="Image46" alt=""></a></li>
                  <li><a href="http://cn.linux.vbird.org/linux_basic/fedora_4/fc4.php" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage(&#39;Image47&#39;,&#39;&#39;,&#39;image/title/title_27.png&#39;,1)"><img src="./鸟哥的 Linux 私房菜27 -- Linux 核心编译_files/title_24.png" name="Image47" width="120" height="26" border="0" id="Image47" alt=""></a></li>
                  <li><a href="http://cn.linux.vbird.org/linux_basic/linux_basic.php" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage(&#39;Image48&#39;,&#39;&#39;,&#39;image/title/title_28.png&#39;,1)"><img src="./鸟哥的 Linux 私房菜27 -- Linux 核心编译_files/title_25.png" name="Image48" width="120" height="26" border="0" id="Image48" alt=""></a></li>
                </ul>
		      </li>
		</ul></td>
		<td>
			<img src="./鸟哥的 Linux 私房菜27 -- Linux 核心编译_files/title_20.png" alt="" width="42" height="33" border="0"></td>
		<td colspan="3" align="left" valign="top"><ul id="MenuBar2" class="MenuBarHorizontal">
	  <li><a href="http://cn.linux.vbird.org/linux_server/" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage(&#39;Image45&#39;,&#39;&#39;,&#39;image/title/title_21.png&#39;,1)" class="MenuBarItemSubmenu"><img src="./鸟哥的 Linux 私房菜27 -- Linux 核心编译_files/title3_21.png" name="Image45" width="125" height="33" border="0" id="Image45"></a>
			    <ul>
			      <li><a href="http://cn.linux.vbird.org/linux_server/linux_redhat9/redhat9.php" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage(&#39;Image43&#39;,&#39;&#39;,&#39;image/title/title_26.png&#39;,1)"><img src="./鸟哥的 Linux 私房菜27 -- Linux 核心编译_files/title_23.png" name="Image43" width="120" height="26" border="0" id="Image43" alt=""></a></li>
			      <li><a href="http://cn.linux.vbird.org/linux_server/centos4.php" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage(&#39;Image49&#39;,&#39;&#39;,&#39;image/title/title_27.png&#39;,1)"><img src="./鸟哥的 Linux 私房菜27 -- Linux 核心编译_files/title_24.png" name="Image49" width="120" height="26" border="0" id="Image49" alt=""></a></li>
			      <li><a href="http://cn.linux.vbird.org/linux_server/" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage(&#39;Image50&#39;,&#39;&#39;,&#39;image/title/title_28.png&#39;,1)"><img src="./鸟哥的 Linux 私房菜27 -- Linux 核心编译_files/title_25.png" name="Image50" width="120" height="26" border="0" id="Image50" alt=""></a></li>
		        </ul>
		      </li>
		</ul></td>
		<td>
			<img src="./鸟哥的 Linux 私房菜27 -- Linux 核心编译_files/title_22.png" alt="" width="47" height="33" border="0"></td>
	</tr>
	<tr>
		<td>
			<img src="./鸟哥的 Linux 私房菜27 -- Linux 核心编译_files/Spacer.gif" width="101" height="1" alt=""></td>
		<td>
			<img src="./鸟哥的 Linux 私房菜27 -- Linux 核心编译_files/Spacer.gif" width="263" height="1" alt=""></td>
		<td>
			<img src="./鸟哥的 Linux 私房菜27 -- Linux 核心编译_files/Spacer.gif" width="53" height="1" alt=""></td>
		<td>
			<img src="./鸟哥的 Linux 私房菜27 -- Linux 核心编译_files/Spacer.gif" width="15" height="1" alt=""></td>
		<td>
			<img src="./鸟哥的 Linux 私房菜27 -- Linux 核心编译_files/Spacer.gif" width="91" height="1" alt=""></td>
		<td>
			<img src="./鸟哥的 Linux 私房菜27 -- Linux 核心编译_files/Spacer.gif" width="27" height="1" alt=""></td>
		<td>
			<img src="./鸟哥的 Linux 私房菜27 -- Linux 核心编译_files/Spacer.gif" width="5" height="1" alt=""></td>
		<td>
			<img src="./鸟哥的 Linux 私房菜27 -- Linux 核心编译_files/Spacer.gif" width="42" height="1" alt=""></td>
		<td>
			<img src="./鸟哥的 Linux 私房菜27 -- Linux 核心编译_files/Spacer.gif" width="60" height="1" alt=""></td>
		<td>
			<img src="./鸟哥的 Linux 私房菜27 -- Linux 核心编译_files/Spacer.gif" width="37" height="1" alt=""></td>
		<td>
			<img src="./鸟哥的 Linux 私房菜27 -- Linux 核心编译_files/Spacer.gif" width="28" height="1" alt=""></td>
		<td>
			<img src="./鸟哥的 Linux 私房菜27 -- Linux 核心编译_files/Spacer.gif" width="47" height="1" alt=""></td>
		<td>
			<img src="./鸟哥的 Linux 私房菜27 -- Linux 核心编译_files/Spacer.gif" width="35" height="1" alt=""></td>
		<td>
			<img src="./鸟哥的 Linux 私房菜27 -- Linux 核心编译_files/Spacer.gif" width="74" height="1" alt=""></td>
		<td>
			<img src="./鸟哥的 Linux 私房菜27 -- Linux 核心编译_files/Spacer.gif" width="22" height="1" alt=""></td>
	</tr>
</tbody></table>
<!-- End ImageReady Slices -->
<script type="text/javascript">
<!--
var MenuBar1 = new Spry.Widget.MenuBar("MenuBar1", {imgDown:"SpryAssets/SpryMenuBarDownHover.gif", imgRight:"SpryAssets/SpryMenuBarRightHover.gif"});
var MenuBar2 = new Spry.Widget.MenuBar("MenuBar2", {imgDown:"SpryAssets/SpryMenuBarDownHover.gif", imgRight:"SpryAssets/SpryMenuBarRightHover.gif"});
//-->
</script>
</div>
<table summary="本文内容的排版" style="width: 898px;" border="0" cellpadding="0" cellspacing="0">
<tbody><tr><td style="width: 16px; height: 16px;">　</td>
    <td style="width: 866px; height: 16px;">　</td>
    <td style="width: 16px; height: 16px;">　</td></tr>
<tr><td style="width: 16px; font-size: 6px;">　</td>
    <td width="866">

<!-- 本文的档头部分 -->
<div style="text-align: center;">
    <a href="http://cn.linux.vbird.org/linux_basic/0540kernel.php">
    <span class="text_head0">第二十六章、<span class="text_head_en">Linux </span>核心编译与管理</span></a><br>
</div>
    <div style="text-align: right;">
        <span class="text_history">最近升级日期：2009/09/18</span>
    </div>

<!-- 本文的档头部分 -->
<center><table class="head1" summary="排版：文章档头的说明"><tbody><tr><td class="head1">
	我们说的 Linux 其实指的就是核心 (kernel) 而已。这个核心控制你主机的所有硬件并提供系统所有的功能，
	所以说，他重不重要啊！我们启动的时候其实就是利用启动管理程序加载这个核心文件来侦测硬件，
	在核心加载适当的驱动程序后，你的系统才能够顺利的运行。现今的系统由於强调线上升级机制，因此非常不建议自订核心编译！
	但是，如果你想要将你的 Linux 安装到 U盘 闪盘、想要将你的 Eee PC 小笔记本计算机安装自己的 Linux ，
	想让你的 Linux 可以驱动你的小家电，此时，核心编译就是相当重要的一个任务了！
	这一篇比较进阶，如果你对系统移植没有兴趣的话，这一篇可以先略过喔！ ^_^
</td></tr></tbody></table></center>

<!-- 本文的连结区部分 -->
<div class="block1">
<span class="text_h1">
1. <a href="http://cn.linux.vbird.org/linux_basic/0540kernel.php#intro">编译前的任务：认识核心与取得核心原始码</a><br>
	<span class="text_h2">
	　　1.1 <a href="http://cn.linux.vbird.org/linux_basic/0540kernel.php#intro_whatiskernel">什么是核心 (Kernel)</a><br>
	　　1.2 <a href="http://cn.linux.vbird.org/linux_basic/0540kernel.php#intro_whyrecompile">升级核心的目的</a><br>
	　　1.3 <a href="http://cn.linux.vbird.org/linux_basic/0540kernel.php#intro_kernel_version">核心的版本</a><br>
	　　1.4 <a href="http://cn.linux.vbird.org/linux_basic/0540kernel.php#kernel_source">核心原始码的取得方式</a>：distributions 默认、最新、patch<br>
	　　1.5 <a href="http://cn.linux.vbird.org/linux_basic/0540kernel.php#kernel_source_install">核心原始码的解压缩/安装/观察</a><br>
	</span>
2. <a href="http://cn.linux.vbird.org/linux_basic/0540kernel.php#config">核心编译的前处理与核心功能选择</a><br>
	<span class="text_h2">
	　　2.1 <a href="http://cn.linux.vbird.org/linux_basic/0540kernel.php#config_hw">硬件环境检视与核心功能要求</a><br>
	　　2.2 <a href="http://cn.linux.vbird.org/linux_basic/0540kernel.php#config_mrproper">保持干净原始码： make mrproper</a><br>
	　　2.3 <a href="http://cn.linux.vbird.org/linux_basic/0540kernel.php#config_config">开始挑选核心功能： make XXconfig</a><br>
	　　2.4 <a href="http://cn.linux.vbird.org/linux_basic/0540kernel.php#config_kernel">核心功能细项选择</a><br>
		<span class="text_import1">
	　　　　a. <a href="http://cn.linux.vbird.org/linux_basic/0540kernel.php#general">一般配置(General setup)</a>：附加版本名称、IPC 通讯、程序相关等<br>
	　　　　b. <a href="http://cn.linux.vbird.org/linux_basic/0540kernel.php#load">核心模块与 block layer 支持</a><br>
	　　　　c. <a href="http://cn.linux.vbird.org/linux_basic/0540kernel.php#cpu">CPU 的类型与功能选择(含虚拟化技术)</a><br>
	　　　　d. <a href="http://cn.linux.vbird.org/linux_basic/0540kernel.php#power">电源管理功能</a><br>
	　　　　e. <a href="http://cn.linux.vbird.org/linux_basic/0540kernel.php#bus">一些汇流排 (bus) 的选项</a><br>
	　　　　f. <a href="http://cn.linux.vbird.org/linux_basic/0540kernel.php#execute">编译后运行档的格式</a><br>
	　　　　g. <a href="http://cn.linux.vbird.org/linux_basic/0540kernel.php#networking">核心的网络功能</a><br>
	　　　　h. <a href="http://cn.linux.vbird.org/linux_basic/0540kernel.php#device">各项装置的驱动程序</a><br>
	　　　　i. <a href="http://cn.linux.vbird.org/linux_basic/0540kernel.php#filesystem">文件系统的支持</a><br>
	　　　　j. <a href="http://cn.linux.vbird.org/linux_basic/0540kernel.php#security">核心黑客、资讯安全、口令应用</a><br>
	　　　　k. <a href="http://cn.linux.vbird.org/linux_basic/0540kernel.php#virt">虚拟化与函式库</a><br>
		</span>
	</span>
3. <a href="http://cn.linux.vbird.org/linux_basic/0540kernel.php#make">核心的编译与安装</a><br>
	<span class="text_h2">
	　　3.1 <a href="http://cn.linux.vbird.org/linux_basic/0540kernel.php#make_kernel">编译核心与核心模块</a><br>
	　　3.2 <a href="http://cn.linux.vbird.org/linux_basic/0540kernel.php#make_module">实际安装模块</a><br>
	　　3.3 <a href="http://cn.linux.vbird.org/linux_basic/0540kernel.php#make_install">开始安装新核心与多重核心菜单 (grub)</a><br>
	</span>
4. <a href="http://cn.linux.vbird.org/linux_basic/0540kernel.php#module">额外(单一)核心模块编译</a><br>
	<span class="text_h2">
	　　4.1 <a href="http://cn.linux.vbird.org/linux_basic/0540kernel.php#module_before">编译前注意事项</a><br>
	　　4.2 <a href="http://cn.linux.vbird.org/linux_basic/0540kernel.php#module_compile">单一模块编译</a><br>
	　　4.3 <a href="http://cn.linux.vbird.org/linux_basic/0540kernel.php#module_mod">核心模块管理</a><br>
	</span>
5. <a href="http://cn.linux.vbird.org/linux_basic/0540kernel.php#hint">重点回顾</a><br>
6. <a href="http://cn.linux.vbird.org/linux_basic/0540kernel.php#ex">本章习题</a><br>
7. <a href="http://cn.linux.vbird.org/linux_basic/0540kernel.php#reference">参考数据与延伸阅读</a><br>
<span class="text_h2">
8. <a href="http://phorum.vbird.org/viewtopic.php?t=23899" target="_blank">针对本文的建议：http://phorum.vbird.org/viewtopic.php?t=23899</a>
</span>
</span>
</div>


<!-- 本文的正式部分 -->
<hr><a name="intro"></a><img src="./鸟哥的 Linux 私房菜27 -- Linux 核心编译_files/logo.png" alt="大标题的图示" width="35" align="middle" height="34"><span class="text_h1">编译前的任务：认识核心与取得核心原始码</span><br>
<div class="block1">
	<p>我们在<a href="http://cn.linux.vbird.org/linux_basic/0110whatislinux.php">第一章</a>里面就谈过 Linux 其实指的是核心！这个『核心 
	(kernel)』是整个操作系统的最底层，他负责了整个硬件的驱动，以及提供各种系统所需的核心功能，包括防火墙机制、是否支持 
	LVM 或 Quota 等文件系统等等，这些都是核心所负责的！所以罗，在<a href="http://cn.linux.vbird.org/linux_basic/0510osloader.php">第二十章</a>的启动流程中，我们也会看到 MBR 内的 loader 加载核心文件来驱动整个系统的硬件呢！
	也就是说，如果你的核心不认识某个最新的硬件，那么该硬件也就无法被驱动，你当然也就无法使用该硬件罗！<br><br></p>

	<hr><a name="intro_whatiskernel"></a><img src="./鸟哥的 Linux 私房菜27 -- Linux 核心编译_files/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">什么是核心 (Kernel)</span><br>
	<div class="block2">
		<p>这已经是整个 Linux 基础的最后一篇了，所以，底下这些数据你应该都要『很有概念』才行～
		不能只是『好像有印象』～好了，那就复习一下核心的相关知识吧！<br><br></p>

		<hr><ul class="list1"><li class="text_import1">Kernel</li></ul>

		<p>还记得我们在<a href="http://cn.linux.vbird.org/linux_basic/0320bash.php">第十一章的 BASH shell</a> 
		提到过：计算机真正在工作的东西其实是『<span class="text_import2">硬件</span>』，
		例如数值运算要使用到 CPU、数据储存要使用到硬盘、图形显示会用到显卡、音乐发声要有音效芯片、连接 Internet 
		可能需要网络卡等等。那么如何控制这些硬件呢？那就是核心的工作了！也就是说，你所希望计算机帮你达成的各项工作，
		都需要透过『<span class="text_import2">核心</span>』的帮助才行！当然罗，如果你想要达成的工作是核心所没有提供的，
		那么你自然就没有办法透过核心来控制计算机使他工作罗！</p>

		<p>举例来说，如果你想要有某个网络功能 (例如核心防火墙机制) ，但是你的核心偏偏忘记加进去这项功能，
		那么不论你如何『卖力』的配置该网络套件，很抱歉！不来电！换句话说，<span class="text_import2">你想要让计算机进行的工作，都必须要『核心有支持』才可以</span>！这个标准不论在 Windows 或 
		Linux 这几个操作系统上都相同！如果有一个人开发出来一个『全新的硬件』，目前的核心不论
		Windows 或 Linux 都不支持，那么不论你用什么系统，哈哈！这个硬件都是英雄无用武之地啦！
		那么是否了解了『核心』的重要了呢？所以我们才需要来了解一下如何编译我们的核心啦！</p>

		<p>那么核心到底是什么啊？<span class="text_import2">其实核心就是系统上面的一个文件而已，
		这个文件包含了驱动主机各项硬件的侦测程序与驱动模块</span>。在<a href="http://cn.linux.vbird.org/linux_basic/0510osloader.php">第二十章的启动流程分析</a>中，我们也提到这个文件被读入主内存的时机，
		当系统读完 BIOS 并加载 MBR 内的启动管理程序后，就能够加载核心到内存当中。然后核心开始侦测硬件，
		挂载根目录并取得核心模块来驱动所有的硬件，之后呼叫 /sbin/init 就能够依序启动所有系统所需要的服务了！</p>

		<p>这个核心文件通常被放置成 /boot/vmlinuz ，不过也不见得，<span class="text_import2">
		因为一部主机上面可以拥有多个核心文件，只是启动的时候仅能选择一个来加载而已</span>。
		甚至我们也可以在一个 distribution 上面放置多个核心，然后以这些核心来做成多重启动呢！<br><br></p>

		<hr><ul class="list1"><li class="text_import1">核心模块 (kernel module) 的用途</li></ul>

		<p>既然核心文件都已经包含了硬件侦测与驱动模块，那么什么是核心模块啊？要注意的是，
		现在的硬件升级速度太快了，如果我的核心比较旧，但我换了新的硬件，那么，这个核心肯定无法支持！
		怎么办？重新拿一个新的核心来处理吗？开玩笑～核心的编译过程可是很麻烦的～</p>

		<p>所以罗，为了这个缘故，我们的 Linux  很早之前就已经开始使用所谓的模块化配置了！
		亦即是将一些不常用的类似驱动程序的咚咚独立出核心，编译成为模块，然后，
		核心可以在系统正常运行的过程当中加载这个模块到核心的支持。如此一来，
		我在不需要更动核心的前提之下，只要编译出适当的核心模块，并且加载他，呵呵！我的 Linux 
		就可以使用这个硬件啦！简单又方便！</p>

		<p>那我的模块放在哪里啊？可恶！怎么会问这个傻问题呢？当然一定要知道的啦！就是 <span class="text_import2" style="font-family: &#39;细明体&#39;;">/lib/modules/$(uname -r)/kernel/</span> 当中啦！<br><br></p>

		<hr><ul class="list1"><li class="text_import1">自制核心 - 核心编译</li></ul>

		<p>刚刚上面谈到的核心其实是一个文件，那么这个文件怎么来的？当然是透过原始码 (source code) 
		编译而成的啊！因为核心是直接被读入到主内存当中的，所以当然要将他编译成为系统可以认识的数据才行！也就是说，
		我们必须要取得核心的原始码，然后利用<a href="http://cn.linux.vbird.org/linux_basic/0520source_code_and_tarball.php">第二十二章 Tarball</a> 
		安装方式提到的编译概念来达成核心的编译才行啊！(这也是本章的重点啊！ ^_^)<br><br></p>

		<hr><ul class="list1"><li class="text_import1">关於驱动程序 - 是厂商的责任还是核心的责任？</li></ul>

		<p>现在我们知道硬件的驱动程序可以编译成为核心模块，所以可以在不改变核心的前提下驱动你的新硬件。
		但是，很多朋友还是常常感到困惑，就是 Linux 上面针对最新硬件的驱动程序总是慢了几个脚步，
		所以觉得好像 Linux 的支持度不足！其实不可以这么说的，为什么呢？因为在 
		Windows 上面，对於最新硬件的驱动程序需求，基本上，也都是厂商提供的驱动程序才能让该硬件工作的，
		因此，<span class="text_import2">在这个『驱动程序开发』的工作上面来说，应该是属於硬件发展厂商的问题</span>，
		因为他要我们买他的硬件，自然就要提供消费者能够使用的驱动程序啦！</p>

		<p>所以，如果大家想要让某个硬件能够在 Linux 上面跑的话，那么似乎可以发起一人一信的方式，强烈要求硬件开发商发展
		Linux 上面的驱动程序！这样一来，也可以促进 Linux 的发展呢！</p>
	</div>

	<hr><a name="intro_whyrecompile"></a><img src="./鸟哥的 Linux 私房菜27 -- Linux 核心编译_files/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">升级核心的目的</span><br>
	<div class="block2">
		<p>除了 BIOS 之外，核心是操作系统中最早被加载到内存的咚咚，
		他包含了所有可以让硬件与软件工作的资讯，所以，如果没有搞定核心的话，
		那么你的系统肯定会有点小问题！好了，那么是不是将『<span class="text_import2">所有目前核心有支持的东西都给他编译进去我的核心中，
		那就可以支持目前所有的硬件与可运行的工作啦！</span>』！</p>

		<p>这话说的是没错啦，但是你是否曾经看过一个为了怕自己今天出门会口渴、会饿、会冷、会热、会被车撞、
		会摔跤、会被性骚扰，而在自己的大包包里面放了大瓶矿泉水、便当、厚外套、短裤、防撞钢梁、止滑垫、
		电击棒....等一大堆东西，结果却累死在半路上的案例吗？当然有！但是很少啦！我相信不太有人会这样做！
		(会这么做的人通常都已经在医院了～) 取而代之的是会看一下天气，冷了就只带外套，
		热了就只带短衣、如果穿的漂亮一点又预计晚点回家就多带个电击棒、
		出远门到没有便利商店的地方才多带矿泉水....</p>

		<p>说这个干什么！对啦！就是要你了解到，核心的编译重点在於『<span class="text_import2">你要你的
		Linux 作什么？</span>』，是啦！如果没有必要的工作，就干脆不要加在你的核心当中了！这样才能让你的
		Linux 跑得更稳、更顺畅！这也是为什么我们要编译核心的最主要原因了！<br><br></p>

		<hr><ul class="list1"><li class="text_import1">Linux 核心特色，与默认核心对终端用户的角色</li></ul>

		<p>Linux 的核心有几个主要的特色，除了『<span class="text_import2">Kernel 
		可以随时、随各人喜好而更动</span>』之外，<span class="text_import2">Kernel
		的『版本更动次数太频繁</span>』也是一个特点！所以罗，除非你有特殊需求，
		否则一次编译成功就可以啦！不需要随时保持最新的核心版本，而且也没有必要
		(编译一次核心要粉久的ㄋㄟ！) 。话说到这里又突然想到今天看到的一篇文章，大意是说老板想要雇用的人会希望是
		Linux 的老手，因为他们比较容易了解问题的所在，除此之外，如果有任何问题发生，由於其使用
		Linux 是可以随时修补漏洞的！但是如果是 Windows 的话，就得要将机器关闭，直到
		MS 推出修补套件后才能再激活～</p>

		<p>那么<span class="text_import2">是否『我就一定需要在安装好了 Linux 之后就赶紧给他编译核心呢？</span>』，
		老实说，『并不需要的』！这是因为几乎每一个 distribution 都已经默认编译好了相当大量的模块了，
		所以使用者常常或者可能会使用到的数据都已经被编译成为模块，也因此，呵呵！
		我们使用者确实不太需要重新来编译核心！尤其是『<span class="text_import2">一般的使用者，
		由於系统已经将核心编译的相当的适合一般使用者使用了，因此一般入门的使用者，基本上，
		不太需要编译核心</span>』。<br><br></p>

		<hr><ul class="list1"><li class="text_import1">核心编译的可能目的</li></ul>

		<p>OK！那么鸟哥闲闲没事干跑来写个什么东西？既然都不需要编译核心还写编译核心的分享文章，
		鸟哥卖弄才学呀？很抱歉，鸟哥虽然是个『不学有术』的混混，却也不会平白无故的写东西请您来指教～
		当然是有需要才会来编译核心啦！编译核心的时机可以归纳为几大类：</p>

		<ul>
		<li><span class="text_import2">新功能的需求</span>：<br>
		我需要新的功能，而这个功能只有在新的核心里面才有，那么为了获得这个功能，只好来重新编译我的核心了。例如 
		iptables 这个防火墙机制只有在 2.4.xx 以后的版本里面才有，而新开发的主板芯片组，
		很多也需要新的核心推出之后，才能正常而且有效率的工作！<br><br></li>

		<li><span class="text_import2">原本核心太过臃肿</span>：<br>
		如果你是那种对於系统『稳定性』很要求的人，对於核心多编译了很多莫名其妙的功能而不太喜欢的时候，
		那么就可以重新编译核心来取消掉该功能罗；<br><br></li>

		<li><span class="text_import2">与硬件搭配的稳定性</span>：<br>
		由於原本 Linux 核心大多是针对 Intel 的 CPU 来作开发的，所以如果你的
		CPU 是 AMD 的系统时，有可能 (注意！只是有可能，不见得一定会如此) 
		会让系统跑得『不太稳！』。此外，核心也可能没有正确的驱动新的硬件，此时就得重新编译核心来让系统取得正确的模块才好。
		<br><br></li>

		<li><span class="text_import2">其他需求 (如嵌入式系统)</span>：<br>
		就是你需要特殊的环境需求时，就得自行设计你的核心罗！( 
		像是一些商业的套装软件系统，由於需要较为小而美的操作系统，
		那么他们的核心就需要更简洁有力了！)</li>
		</ul>

		<p>另外，需要注意重新编译核心虽然可以针对你的硬件作最佳化的步骤 (例如刚刚提到的
		CPU 的问题！) ，不过由於这些最佳化的步骤对於整体效能的影响是很小很小的，
		因此如果是为了添加效能来编译核心的话，基本上，效益不大！然而，如果是针对『系统稳定性』来考量的话，
		那么就有充分的理由来支持你重新编译核心罗！</p>

		<p>『<span class="text_import2">如果系统已经运行很久了，而且也没有什么大问题，
		加上我又不添加冷门的硬件设备，那么建议就不需要重新编译核心了』</span>，
		因为重新编译核心的最主要目的是『想让系统变的更稳！』既然你的
		Linux 主机已经达到这个目的了，何必再编译核心？不过，就如同前面提到的，
		由於默认的核心不见得适合你的需要，加上默认的核心可能并无法与你的硬件配备相配合，
		此时才开始考虑重新编译核心吧！</p>

		<div style="padding: 10pt 0pt;" align="right"><table width="90%"><tbody><tr><td><b>Tips:</b><br><span style="color: rgb(0, 144, 0);"><font size="-1">		早期鸟哥是强调最好重新编译核心的一群啦！不过，最近这个想法改变了～
		既然原本的 distribution  都已经帮我们考虑好如何使用核心了，那么，
		我们也不需要再重新的编译核心啦！尤其是 distribution 都会主动的释出新版的核心 RPM 版本，
		所以，实在不需要自己重新编译的！当然啦，如同前面提到的，
		如果你有特殊需求的话，那就另当别论噜！ ^_^
		</font></span></td><td><img src="./鸟哥的 Linux 私房菜27 -- Linux 核心编译_files/vbird_face.gif" alt="鸟哥的图示" title="鸟哥的图示"></td></tr></tbody></table></div>
		<p>由於『<span class="text_import2">核心的主要工作是在控制硬件</span>！』所以编译核心之前，
		请先了解一下你的硬件配备，与你这部主机的未来功能！由於核心是『<span class="text_import2">越简单越好</span>！』所以只要将这部主机的未来功能给他编进去就好了！
		其他的就不用去理他啦！</p>
	</div>

	<hr><a name="intro_kernel_version"></a><img src="./鸟哥的 Linux 私房菜27 -- Linux 核心编译_files/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">核心的版本</span><br>
	<div class="block2">
		<p>核心的版本问题，我们在<a href="http://cn.linux.vbird.org/linux_basic/0110whatislinux.php#torvalds_team">第一章</a>已经谈论过，
		主要的版本定义为：『<span class="text_import2">[主].[次].[释出]-[修改]</span>』的样式。
		你只要知道 2.6.x 是稳定版本，2.5.x 是测试用版本即可。
		我们要使用最新的核心来重新编译核心时，大多就是使用那种偶数的核心版本啦！不过这里还是要再提一遍！就是『
		<span class="text_import2">2.4.x 与 2.6.x 是两个具有相当大差异的核心版本，
		两者之间使用到的函式库基本上已经不相同了，所以在升级之前，如果你的核心原本是
		2.4.xx 版，那么就升级到 2.4.xx 版本的最新版，不要由 2.4.xx
		直接升级到 2.6.xx 版，否则到时可能会欲哭无泪～～</span>』，
		这个问题在讨论区一再地被提起！这里再次说明！</p>

		<div style="padding: 10pt 0pt;" align="right"><table width="90%"><tbody><tr><td><b>Tips:</b><br><span style="color: rgb(0, 144, 0);"><font size="-1">		为什么不能从 2.4 升级到 2.6 呢？其实还是可以啦！只是过程很复杂！
		我们知道软件 (packages) 是架构在系统核心上面来进行编译、安装与运行的，
		也就是说，这些 packages 与核心之间，是有相关性的！这些 packages 会用到很多核心提供的功能。
		但是不同的[主][次]版本之间，他们提供的功能架构差异太大，因此，若你由 2.4 升级到 2.6 的话，
		那么绝大部分的软件『都需要重新再编译！』这样了解为何不要在不同的版本间升级了吧？
		</font></span></td><td><img src="./鸟哥的 Linux 私房菜27 -- Linux 核心编译_files/vbird_face.gif" alt="鸟哥的图示" title="鸟哥的图示"></td></tr></tbody></table></div>
		<p>此外，2.4.xx 与 2.6.xx 的比较中，<span class="text_import2">并不是
		2.6.xx 就一定比 2.4.xx 还要新</span>，因为这两种版本同时在进行维护与升级的工作！如果有兴趣的话，可以前往
		Linux 核心网站 <a href="http://www.kernel.org/" target="_blank">http://www.kernel.org</a>
		一看究竟，你就可以了解目前的核心变动情况了！</p>

		<p>基本上，目前最新的 distributions ，包括 CentOS, FC, SuSE, Mandriva 等等，都使用 2.6 的核心，
		所以，你可以直接由 <a href="http://www.kernel.org/" target="_blank">http://www.kernel.org</a>
		下载最新的 2.6.xx 版本的核心来尝试编译啊！目前 (2009/07/27) 鸟哥可以查到的最新版本是 2.6.30 ，
		底下我们将主要以这个版本来测试。另外，由於较新的核心版本可能会多出一些选项，
		因此若有不同的项目也没有关系！稍微查看一下说明内容就可以了解啦！</p>
	</div>

	<hr><a name="kernel_source"></a><img src="./鸟哥的 Linux 私房菜27 -- Linux 核心编译_files/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">核心原始码的取得方式</span><br>
	<div class="block2">
		<p>既然核心是个文件，要制作这个文件给系统使用则需要编译，既然要有编译，当然就得要有原始码啊！
		那么原始码怎么来？基本上，依据你的 distributions 去挑选的核心原始码来源主要有：<br><br></p>

		<hr><ul class="list1"><li class="text_import1">原本 distribution 提供的核心原始码文件</li></ul>

		<p>事实上，各主要 distributions 在推出他们的产品时，其实已经都附上了核心原始码了！
		以我们的 CentOS 5.x 为例，你可以在国家高速网络中心网站下载相关的核心 SRPM 的文件！
		由於 CentOS 5.x 一直有在进行升级动作，因此你也可以在 update 的目录底下找到核心原始码喔！如下连结所示：</p>

		<ul>
		<li><a href="http://ftp.twaren.net/Linux/CentOS/5/os/SRPMS/" target="_blank">原始推出核心码：http://ftp.twaren.net/Linux/CentOS/5/os/SRPMS/</a></li>
		<li><a href="http://ftp.twaren.net/Linux/CentOS/5/updates/SRPMS/" target="_blank">升级码：http://ftp.twaren.net/Linux/CentOS/5/updates/SRPMS/</a></li>
		</ul>

		<p>你或许会说：既然要重新编译，那么干嘛还要使用原本 distributions 释出的原始码啊？真没创意～
		话不是这么说，因为原本的 distribution 释出的原始码当中，含有他们配置好的默认配置值，
		所以，我们可以轻易的就了解到当初他们是如何选择与核心及模块有关的各项配置项目的参数值，
		那么就可以利用这些可以配合我们 Linux 系统的默认参数来加以修改，如此一来，
		我们就可以『修改核心，调整到自己喜欢的样子』罗！而且编译的难度也会比较低一点！<br><br></p>

		<hr><ul class="list1"><li class="text_import1">取得最新的稳定版核心原始码</li></ul>

		<p>虽然使用 distribution 释出的核心 source code 来重新编译比较方便，但是，如此一来，
		新硬件所需要的新驱动程序，也就无法藉由原本的核心原始码来编译啊！
		所以罗，如果是站在要升级驱动程序的立场来看，当然使用最新的核心可能会比较好啊！</p>

		<p>Linux 的核心目前是由其发明者 Linus Torvalds 所属团队在负责维护的，而其网站在底下的站址上，在该网站上可以找到最新的
		kernel 资讯！不过，美中不足的是目前的核心越来越大了 (linux-2.6.30.3.tar.bz2
		这一版，这一个文件大约 57MB 了！)，所以如果你的 ISP 连外很慢的话，那么使用台湾的映射站台来下载不失为一个好方法：</p>
		<ul>
		<li><a href="http://www.kernel.org/pub/linux/kernel/" target="_blank">核心官网：http://www.kernel.org/</a></li>
		<li><a href="ftp://linux.cis.nctu.edu.tw/kernel/linux/kernel/" target="_blank">交大资科：ftp://linux.cis.nctu.edu.tw/kernel/linux/kernel/</a></li>
		<li><a href="ftp://ftp.twaren.net/pub/Unix/Kernel/linux/kernel/" target="_blank">国高中心：ftp://ftp.twaren.net/pub/Unix/Kernel/linux/kernel/</a></li>
		</ul><br>

		<hr><ul class="list1"><li class="text_import1">保留原本配置：利用 patch 升级核心原始码</li></ul>

		<p>如果 (1)你曾经自行编译过核心，那么你的系统当中应该已经存在前几个版本的核心原始码，
		以及上次你自行编译的参数配置值才对； (2)如果你只是想要在原本的核心底下加入某些特殊功能，
		而该功能已经针对核心原始码推出 patch 补丁文件时。那你该如何进行核心原始码的升级，以便后续的编译呢？</p>

		<p>其实每一次核心释出时，除了释出完整的核心压缩档之外，也会释出『该版本与前一版本的差异性 patch 文件』，
		关於 patch 的制作我们已经在<a href="http://cn.linux.vbird.org/linux_basic/0520source_code_and_tarball.php#tarball_patch">第二十二章</a>当中提及，
		你可以自行前往参考。这里仅是要提供给你的资讯是，每个核心的 patch 仅有针对前一版的核心来分析而已，
		所以，万一你想要由 2.6.27 升级到 2.6.30 的话，那么你就得要下载
		patch-2.6.28, patch-2.6.29, patch-2.6.30 等文件，然后『依序』一个一个的去进行 patch 的动作后，
		才能够升级到 2.6.30 喔！这个重要！不要忘记了。</p>

		<p>但是，如果你想要升级 2.6.30 的修改版本到 2.6.30.3 时，由於修改版本是针对 2.6.30 来制作的，
		因此你只要下载 patch-2.6.30.3 来直接将 2.6.30 升级至 2.6.30.3 即可。但反过来说，如果你要从 2.6.30.2 升级到
		2.6.30.3 呢？很抱歉的是，并没有 2.6.30.2 到 2.6.30.3 的补丁文件，所以你必须要将 2.6.30.2 还原至 2.6.30，
		然后才能使用 patch-2.6.30.3 来升级 2.6.30 喔！注意这个差异！</p>

		<p>同样的，如果是某个硬件或某些非官方认定的核心添加功能网站所推出的 patch 文件时，你也必须要了解该 patch 
		文件所适用的核心版本，然后才能够进行 patch ，否则容易出现重大错误喔！这个项目对於某些商业公司的工程师来说是很重要的。
		举例来说，鸟哥的一个高中同学在业界服务，他主要是进行类似 Eee PC 开发的计画，然而该计画的硬件是该公司自行推出的！
		因此，该公司必须要自行搭配核心版本来设计他们自己的驱动程序，而该驱动程序并非 GPL 
		授权，因此他们就得要自行将驱动程序整合进核心！如果改天他们要将这个驱动程序释出，那么就得要利用 patch 的方式，
		将硬件驱动程序文件释出，我们就得要自行以 patch 来升级核心啦！</p>

		<p>在进行完 patch 之后，你可以直接检查一下原本的配置值，如果没有问题，
		就可以直接编译，而不需要再重新的选择核心的参数值，这也是一个省时间的方法啊！
		至於 patch file 的下载，同样是在 kernel 的相同目录下，寻找档名是 patch 开头的就是了。</p>
	</div>

	<hr><a name="kernel_source_install"></a><img src="./鸟哥的 Linux 私房菜27 -- Linux 核心编译_files/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">核心原始码的解压缩/安装/观察</span><br>
	<div class="block2">
		<p>由於鸟哥是比较喜欢直接由核心官网取得原始核心的家伙，所以，底下的动作是使用 2.6.30.3 这个版本的核心来安装的！
		如果你想要使用 distributions 提供的 SRPM 来处理的话，得自行找到 SRPM 的相关安装方法来处理罗！
		其实看一下<a href="http://cn.linux.vbird.org/linux_basic/0520source_code_and_tarball.php">第二十二章</a>就知道该如何处理啦。
		总之，本章的核心原始码是由底下的连结取得的：</p>

		<ul><li><a href="ftp://linux.cis.nctu.edu.tw/kernel/linux/kernel/v2.6/linux-2.6.30.3.tar.bz2" target="_blank">ftp://linux.cis.nctu.edu.tw/kernel/linux/kernel/v2.6/linux-2.6.30.3.tar.bz2</a></li></ul><br>

		<hr><ul class="list1"><li class="text_import1">核心原始码的解压缩与放置目录</li></ul>

		<p>鸟哥这里假设你也是下载上述的连结内的文件，然后该文件放置到 /root 底下。由於 2.6.x 核心原始码一般建议放置於
		/usr/src/kernels/ 目录底下，因此你可以这样处理：</p>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">tar -jxvf linux-2.6.30.3.tar.bz2 -C /usr/src/kernels/</span>
</pre></td></tr></tbody></table>

		<p>此时会在 /usr/src/kernels 底下产生一个新的目录，那就是 linux-2.6.30.3 这个目录罗！
		我们在下个小节会谈到的各项编译与配置，都必须要在这个目录底下进行才行喔！好了，那么这个目录底下的相关文件有啥咚咚？
		底下就来谈谈：<br><br></p>

		<hr><ul class="list1"><li class="text_import1">核心原始码下的次目录</li></ul>

		<p>在上述核心目录下含有哪些重要数据呢？基本上有底下这些东西：</p>

		<ul style="font-family: &#39;细明体&#39;;">
		<li>arch ：与硬件平台有关的项目，大部分指的是 CPU 的类别，例如 x86, x86_64, Xen 虚拟支持等；</li>
		<li>block ：与区块装置较相关的配置数据，区块数据通常指的是大量储存媒体！还包括类似 ext3 等文件系统的支持是否允许等。</li>
		<li>crypto ：核心所支持的加密的技术，例如 md5 或者是 des 等等；</li>
		<li>Documentation ：与核心有关的一堆说明文件，若对核心有极大的兴趣，要瞧瞧这里！</li>
		<li>drivers ：一些硬件的驱动程序，例如显卡、网络卡、PCI 相关硬件等等；</li>
		<li>firmware ：一些旧式硬件的微命令码 (韧体) 数据；</li>
		<li>fs ：核心所支持的 filesystems ，例如 vfat, reiserfs, nfs 等等；</li>
		<li>include ：一些可让其他程序呼叫的标头 (header) 定义数据；</li>
		<li>init ：一些核心初始化的定义功能，包括挂载与 init 程序的呼叫等；</li>
		<li>ipc ：定义 Linux 操作系统内各程序的沟通；</li>
		<li>kernel ：定义核心的程序、核心状态、运行绪、程序的排程 (schedule)、程序的讯号 (signle) 等</li>
		<li>lib ：一些函式库；</li>
		<li>mm ：与内存单元有关的各项数据，包括 swap 与虚拟内存等；</li>
		<li>net ：与网络有关的各项协议数据，还有防火墙模块 (net/ipv4/netfilter/*) 等等；</li>
		<li>security ：包括 selinux 等在内的安全性配置；</li>
		<li>sound ：与音效有关的各项模块；</li>
		<li>virt ：与虚拟化机器有关的资讯，目前核心支持的是 KVM (Kernel base Virtual Machine)</li>
		</ul>

		<p>这些数据先大致有个印象即可，至少未来如果你想要使用 patch 的方法加入额外的新功能时，
		你要将你的原始码放置於何处？这里就能够提供一些指引了。当然，最好还是跑到 Documentation 那个目录底下去瞧瞧正确的说明，
		对你的核心编译会更有帮助喔！</p>
	</div>
</div>


<hr><a name="config"></a><img src="./鸟哥的 Linux 私房菜27 -- Linux 核心编译_files/logo.png" alt="大标题的图示" width="35" align="middle" height="34"><span class="text_h1">核心编译的前处理与核心功能选择</span><br>
<div class="block1">
	<p>什么？核心编译还要进行前处理？没错啦！事实上，核心的目的在管理硬件与提供系统核心功能，因此你必须要先找到你的系统硬件，
	并且规划你的主机未来的任务，这样才能够编译出适合你这部主机的核心！所以，整个核心编译的重要工作就是在『挑选你想要的功能』。
	底下鸟哥就以自己的一部主机软/硬件环境来说明，解释一下如何处理核心编译罗！<br><br></p>

	<hr><a name="config_hw"></a><img src="./鸟哥的 Linux 私房菜27 -- Linux 核心编译_files/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">硬件环境检视与核心功能要求</span><br>
	<div class="block2">
		<p>鸟哥的一部主机硬件环境如下 (透过 /proc/cpuinfo  及 lspci 观察)：</p>
		<ul>
		<li>CPU：AMD 的 Athlon64 3000+ (旧式，不含虚拟化功能)</li>
		<li>主板芯片组： ALi M1689 K8 北桥 及 M5249, M1563 南桥芯片 (较冷门的硬件)</li>
		<li>显卡： AGP 8X 的 NVidia GeForce 6600LE</li>
		<li>内存： 2.0GB 内存</li>
		<li>硬盘： WD 2.5GB 硬盘，使用 ALi, ULi 5289 SATA 介面</li>
		<li>电源控制器： ALi M7101 Power Management Controller (PMU)</li>
		<li>网络卡： 3Com 3c905C-TX/TX-M (对外)</li>
		<li>网络卡： Realtek Semiconductor RTL-8139/8139C/8139C+</li>
		</ul>
		<p>硬件大致如上，至於这部主机的需求，是希望做为未来在鸟哥上课时，可以透过虚拟化功能来处理学生的练习用虚拟机器。
		这部主机也是鸟哥用来放置学校上课教材的机器，因此，这部主机的 I/O 需求须要好一点，未来还需要开启防火墙、
		WWW 服务器功能、FTP 服务器功能等，基本上，用途就是一部小型的服务器环境罗。大致上需要这样的功能啦！</p>
	</div>

	<hr><a name="config_mrproper"></a><img src="./鸟哥的 Linux 私房菜27 -- Linux 核心编译_files/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">保持干净原始码： make mrproper</span><br>
	<div class="block2">
		<p>了解了硬件相关的数据后，我们还得要处理一下核心原始码底下的残留文件才行！假设我们是第一次编译，
		但是我们不清楚到底下载下来的原始码当中有没有保留目标文件 (*.o) 以及相关的配置档存在，
		此时我们可以透过底下的方式来处理掉这些编译过程的目标文件以及配置档：</p>

<table class="term"><tbody><tr><td class="term"><pre>[root@www linux-2.6.30.3]# <span class="term_command">make mrproper</span>
</pre></td></tr></tbody></table>

		<p>请注意，<span class="text_import2">这个动作会将你以前进行过的核心功能选择文件也删除掉</span>，
		所以几乎只有第一次运行核心编译前才进行这个动作，其余的时刻，你想要删除前一次编译过程的残留数据，
		只要下达：</p>

<table class="term"><tbody><tr><td class="term"><pre>[root@www linux-2.6.30.3]# <span class="term_command">make clean</span>
</pre></td></tr></tbody></table>

		<p>因为 make clean 仅会删除类似目标档之类的编译过程产生的中间文件，而不会删除配置档！
		很重要的！千万不要搞乱了喔！好了，既然我们是第一次进行编译，因此，请下达『make mrproper』吧！</p>
	</div>

	<hr><a name="config_config"></a><img src="./鸟哥的 Linux 私房菜27 -- Linux 核心编译_files/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">开始挑选核心功能： make XXconfig</span><br>
	<div class="block2">
		<p>不知道你有没有发现 /boot/ 底下存在一个名为 config-xxx 的文件？那个文件其实就是核心功能列表档！
		我们底下要进行的动作，其实就是作出该文件！而我们后续小节所要进行的编译动作，其实也就是透过这个文件来处理的！
		核心功能的挑选，最后会在 /usr/src/kernels/linux-2.6.30.3/ 底下产生一个名为 .config 的隐藏档，
		这个文件就是 /boot/config-xxx 的文件啦！那么这个文件如何创建呢？你可以透过非常多的方法来创建这个文件！
		常见的方法有：(<a href="http://cn.linux.vbird.org/linux_basic/0540kernel.php#ps1">注1</a>)</p>

		<ul>
		<li><span class="text_import2">make menuconfig</span><br>
		最常使用的，是文字模式底下可以显示类似图形介面的方式，不需要启动 X Window 就能够挑选核心功能菜单！<br><br></li>
		<li><span class="text_import2">make oldconfig</span><br>
		透过使用已存在的 ./.config 文件内容，使用该文件内的配置值为默认值，只将新版本核心内的新功能选项列出让使用者选择，
		可以简化核心功能的挑选过程！对於作为升级核心原始码后的功能挑选来说，是非常好用的一个项目！<br><br></li>
		<li><span class="text_import2">make xconfig</span><br>
		透过以 Qt 为图形介面基础功能的图形化介面显示，需要具有 X window 的支持。例如 KDE 就是透过 Qt 来设计的 X
		Window，因此你如果在 KDE 画面中，可以使用此一项目。<br><br></li>
		<li><span class="text_import2">make gconfig</span><br>
		透过以 Gtk 为图形介面基础功能的图形化介面显示，需要具有 X window 的支持。例如 GNOME 就是透过 Gtk 来设计的 X
		Window，因此你如果在 GNOME 画面中，可以使用此一项目。<br><br></li>
		<li><span class="text_import2">make config</span><br>
		最旧式的功能挑选方法，每个项目都以条列式一条一条的列出让你选择，如果配置错误只能够再次选择，很不人性化啊！</li>
		</ul>

		<p>大致的功能选择有上述的方法，不过鸟哥个人比较偏好 make menuconfig 这个项目啦！如果你喜欢使用图形介面，
		然后使用鼠标去挑选所需要的功能时，也能使用 make xconfig 或 make gconfig ，不过需要有相关的图形介面支持！
		如果你是升级核心原始码并且需要重新编译，那么使用 make oldconfig 会比较适当！好了，那么如何选择呢？
		以 make menuconfig 来说，出现的画面会有点像这样：</p>

		<center><img src="./鸟哥的 Linux 私房菜27 -- Linux 核心编译_files/menuconfig_1.jpg" alt="make menuconfig 核心功能挑选菜单示意图" title="make menuconfig 核心功能挑选菜单示意图" border="1"><br>
		图 2.3.1 、 make menuconfig 核心功能挑选菜单示意图<br></center>

		<p>看到上面的图示之后，你会发现画面主要分为两大部分，一个是大框框内的反白光柱，另一个则是底下的小框框，
		里面有 select, exit 与 help 三个选项的内容。这几个组件的大致用法如下：</p>

		<ul class="text_import2">
		<li>『左右方向键』：可以移动最底下的 &lt;Select&gt;, &lt;Exit&gt;, &lt;Help&gt;项目；</li>
		<li>『上下方向键』：可以移动上面大框框部分的反白光柱，若该行有箭头 (---&gt;) 
		则表示该行内部还有其他细项需要来配置的意思；</li>
		<li>选定项目：以『上下键』选择好想要配置的项目之后，并以『左右键』选择 &lt;Select&gt; 之后，
		按下『 Enter 』就可以进入该项目去作更进一步的细部配置罗；</li>
		<li>可挑选之功能：在细部项目的配置当中，如果前面有 [ ] 或 &lt; &gt; 符号时，该项目才可以选择，
		而选择可以使用『空白键』来选择；</li>
		<li>若为 [*] &lt;*&gt; 则表示编译进核心；若为 &lt;M&gt; 则表示编译成模块！
		尽量在不知道该项目为何时，且有模块可以选，那么就可以直接选择为模块罗！</li>
		<li>当在细项目选择 &lt;Exit&gt; 后，并按下 Enter ，那么就可以离开该细部项目罗！</li>
		</ul>

		<p>基本上建议只要『上下左右的方向键、空白键、Enter』这六个按键就好了！不要使用 Esc 
		，否则一不小心就有可能按错的！另外，关於整个核心功能的选择上面，建议你可以这样思考：</p>

		<ul class="text_import2">
		<li>『肯定』核心一定要的功能，直接编译进核心内；</li>
		<li>『可能在未来会用到』的功能，那么尽量编译成为模块；</li>
		<li>『不知道那个东西要干嘛的，看 help 也看不懂』的话，那么就保留默认值，或者将他编译成为模块；</li>
		</ul>

		<p>总之，尽量保持核心小而美，剩下的功能就编译成为模块，尤其是『需要考虑到未来扩充性』，
		像鸟哥之前认为螃蟹卡就够我用的了，结果，后来竟然网站流量大增，鸟哥只好改换 3Com 的网络卡。
		不过，我的核心却没有相关的模块可以使用～因为.....鸟哥自己编译的核心忘记加入这个模块了。
		最后，只好重新编译一次核心的模块，呵呵！真是惨痛的教训啊！</p>
	</div>

	<hr><a name="config_kernel"></a><img src="./鸟哥的 Linux 私房菜27 -- Linux 核心编译_files/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">核心功能细项选择</span><br>
	<div class="block2">
		<p>由上面的图示当中，我们知道核心的可以选择的项目有很多啊！光是第一面，就有 16 
		个项目，每个项目内还有不同的细项！哇！真是很麻烦啊～每个项目其实都可能有 &lt;Help&gt; 
		的说明，所以，如果看到不懂的项目，务必要使用 Help 查阅查阅！
		好了，底下我们就一个一个项目来看看如何选择吧！<br><br></p>

		<a name="general"></a>
		<hr><ul class="list1"><li class="text_import1">General setup</li></ul>

		<p>与 Linux 最相关的程序互动、核心版本说明、是否使用发展中程序码等资讯都在这里配置的。
		这里的项目主要都是针对核心与程序之间的相关性来设计的，基本上，保留默认值即可！
		不要随便取消底下的任何一个项目，因为可能会造成某些程序无法被同时运行的困境喔！
		不过底下有非常多新的功能，如果你有不清楚的地方，可以按 &lt;Help&gt; 
		进入查阅，里面会有一些建议！ 你可以依据 Help 的建议来选择新功能的启动与否！</p>

<table class="term"><tbody><tr><td class="term"><pre>[ ] Prompt for development and/or incomplete code/drivers
    <span class="term_say"># 这个建议不要选择，因为我们不是核心专家，不需要使用发展中或不完整的程序码！</span>
(<span class="term_write">vbird</span>)  Local version - append to kernel release
[<span class="term_write">*</span>] Automatically append version information to the version string
    <span class="term_say"># 我希望我的核心版本成为 2.6.30.3.vbird ，那这里可以就这样配置！</span>
    Kernel compression mode (<span class="term_write">Bzip2</span>)  ---&gt;
    <span class="term_say"># 建议选择成为 Bzip2 即可，因为压缩比较佳！</span>
[<span class="term_write">*</span>] Support for paging of anonymous memory (swap)
    <span class="term_say"># 任何人均可存取 swap 是合理的！所以这里务必要勾选！</span>
[<span class="term_write">*</span>] System V IPC
    <span class="term_say"># IPC 是 Inter Process Communication (程序通讯) 缩写，与程序沟通有关，要选！</span>
[<span class="term_write">*</span>] BSD Process Accounting
[ ]   BSD Process Accounting version 3 file format
    <span class="term_say"># 与标准 Unix (BSD) 的程序支持有关，但不要支持 version 3 ，可能有兼容性问题</span>
[ ] Export task/process statistics through netlink (EXPERIMENTAL)
    <span class="term_say"># 这个额外的进阶选项可以将他取消的！</span>
[<span class="term_write">*</span>] Auditing support
[<span class="term_write">*</span>]   Enable system-call auditing support
    <span class="term_say"># 上面这两个是额外核心功能 (如 SELinux) 加载时所需要的配置！务必选择</span>
    RCU Subsystem  ---&gt;
      RCU Implementation (<span class="term_write">Classic RCU</span>)  ---&gt;
    <span class="term_say"># 选择标准 RCU 即可，不需要使用大量 CPU 的整合功能。</span>
&lt;<span class="term_write">M</span>&gt; Kernel .config support
[ ]   Enable access to .config through /proc/config.gz (NEW)
    <span class="term_say"># 让 .config 这个核心功能列表可以写入实际的核心文件中！</span>
(<span class="term_write">17</span>) Kernel log buffer size (16 =&gt; 64KB, 17 =&gt; 128KB)
[ ] Control Group support (NEW)  ---&gt;
    <span class="term_say"># 整合 CPU 或分离装置的功能，属於进阶配置，我们先不要使用这功能。</span>
[<span class="term_write">*</span>] Create deprecated sysfs layout for older userspace tools (NEW)
    <span class="term_say"># 如果使用支持旧式装置，如 /sys/devices 者，这里要勾选！但如果是 2008 
    # 年后的 distribution ，这里可能需要取消喔！ CentOS 5.x 要选的！</span>
-*- Kernel-&gt;user space relay support (formerly relayfs)
-*- Namespaces support
[<span class="term_write">*</span>]   UTS namespace (NEW)
[<span class="term_write">*</span>]   IPC namespace (NEW)
    <span class="term_say"># 使用 uname 时，会输出较多的资讯，所以可以尝试选择看看。</span>
[<span class="term_write">*</span>] Initial RAM filesystem and RAM disk (initramfs/initrd) support
()    Initramfs source file(s)
    <span class="term_say"># 这是一定要的！因为要支持启动时加载 initail RAM disk 嘛！</span>
[<span class="term_write">*</span>] Optimize for size  
    <span class="term_say"># 可以减低核心的文件大小，其实是 gcc 参数使用 -Os 而不是 -O2</span>
[ ] Configure standard kernel features (for small systems)  ---&gt;
    <span class="term_say"># 给嵌入式系统使用的，我们用 PC ，所以这里不选。</span>
[ ] Strip assembler-generated symbols during link (NEW)
[ ] Disable heap randomization (NEW)
    <span class="term_say"># 2000 年后推出的版本，可以取消这个项目！</span>
    Choose SLAB allocator (<span class="term_write">SLAB</span>)  ---&gt;
[<span class="term_write">*</span>] Profiling support (EXPERIMENTAL)
[ ] Activate markers (NEW)
&lt;<span class="term_write">M</span>&gt; OProfile system profiling (EXPERIMENTAL)
[ ]   OProfile AMD IBS support (EXPERIMENTAL) (NEW)
[<span class="term_write">*</span>] Kprobes
</pre></td></tr></tbody></table><br>

		<a name="load"></a>
		<hr><ul class="list1"><li class="text_import1">loadable module + block layer</li></ul>

		<p>要让你的核心能够支持动态的核心模块，那么底下的第一个配置就得要启动才行！至於第二个 block layer 则默认是启动的，
		你也可以进入该项目的细项配置，选择其中你认为需要的功能即可！</p>

<table class="term"><tbody><tr><td class="term"><pre>[<span class="term_write">*</span>] Enable loadable module support  ---&gt; <span class="term_note">&lt;==底下为细项</span>
  --- Enable loadable module support
  [ ]   Forced module loading     <span class="term_note">&lt;==大概就是这个不要选，其他的都选起来！</span>
  [<span class="term_write">*</span>]   Module unloading
  [<span class="term_write">*</span>]   Module versioning support
  [<span class="term_write">*</span>]   Source checksum for all module
<span class="term_say">================================================================================</span>
-*- Enable the block layer  ---&gt;  <span class="term_note">&lt;==看吧！默认就是已经选择了！底下为细项</span>
  [ ]   Block layer data integrity support  <span class="term_note">&lt;==特殊储存装置支持，可以不选</span>
        IO Schedulers  ---&gt;
         &lt;<span class="term_write">*</span>&gt; Anticipatory I/O scheduler  <span class="term_note">&lt;==较复杂的一种I/O排程</span>
         &lt;<span class="term_write">*</span>&gt; Deadline I/O scheduler      <span class="term_note">&lt;==较适用於 database 的加载</span>
         &lt;<span class="term_write">*</span>&gt; CFQ I/O scheduler           <span class="term_note">&lt;==较适用於 desktop 的环境</span>
             Default I/O scheduler (<span class="term_write">Deadline</span>)  ---&gt; <span class="term_note">&lt;==适用於鸟哥环境</span>
</pre></td></tr></tbody></table><br>

		<a name="cpu"></a>
		<hr><ul class="list1"><li class="text_import1">CPU 的类型与功能选择</li></ul>

		<p>进入『Processor type and features』后，请挑选你主机的实际 CPU 形式。鸟哥这里使用的是 Athlon 64 的 CPU，
		而且鸟哥的主机还有启动 Xen 这个虚拟化的服务 (在一部主机上面同时启动多个操作系统)，因此，所以底下的选择是这样的：</p>

<table class="term"><tbody><tr><td class="term"><pre>[<span class="term_write">*</span>] Tickless System (Dynamic Ticks)    <span class="term_note">&lt;==可添加些许省电功能</span>
[ ] High Resolution Timer Support
[<span class="term_write">*</span>] Symmetric multi-processing support <span class="term_note">&lt;==多核心 CPU 环境必选</span>
[ ] Support sparse irq numbering
[<span class="term_write">*</span>] Enable MPS table                   <span class="term_note">&lt;==让多 CPU 支持 ACPI</span>
[ ] Support for extended (non-PC) x86 platforms
[<span class="term_write">*</span>] Single-depth WCHAN output
[<span class="term_write">*</span>] Paravirtualized guest support  ---&gt;  <span class="term_note">&lt;==支持半虚拟化功能</span>
     --- Paravirtualized guest support <span class="term_note">&lt;==底下为 Xen 与 KVM 两种虚拟机器支持！</span>
     [<span class="term_write">*</span>]   Xen guest support
     (<span class="term_write">32</span>)    Maximum allowed size of a domain in gigabytes
     [<span class="term_write">*</span>]     Enable Xen debug and tuning parameters in debugfs
     [<span class="term_write">*</span>]   KVM paravirtualized clock
     [<span class="term_write">*</span>]   KVM Guest support
     -*-   Enable paravirtualization code
<span class="term_say">================================================================================</span>
[ ] paravirt-ops debugging (NEW)  <span class="term_note">&lt;==不需要具有 debug 的功能</span>
[ ] Memtest
    Processor family (<span class="term_write">Opteron/Athlon64/Hammer/K8</span>)  ---&gt; <span class="term_note">&lt;==要选对啊！</span>
[<span class="term_write">*</span>] AMD IOMMU support <span class="term_note">&lt;==启动 AMD 的 IOMMU 功能！</span>
(<span class="term_write">8</span>) Maximum number of CPUs
[ ] SMT (Hyperthreading) scheduler support <span class="term_note">&lt;==Intel CPU 的超运行绪功能</span>
[<span class="term_write">*</span>] Multi-core scheduler support <span class="term_note">&lt;==多核心功能的支持</span>
    Preemption Model (<span class="term_write">No Forced Preemption (Server)</span>)  ---&gt;
    <span class="term_say"># 这是与程序有关的配置项目，鸟哥这里创建 Server 主机，因此选这项！
    # 如果是桌上型计算机的使用，建议进入选择 desktop 项目。</span>
[ ] Reroute for broken boot IRQs
[<span class="term_write">*</span>] Machine Check Exception <span class="term_note">&lt;==可将核心侦测之错误回报到终端机显示！</span>
[<span class="term_write">*</span>]   Intel MCE features (NEW)
[<span class="term_write">*</span>]   AMD MCE features (NEW)
&lt; &gt; Dell laptop support
&lt;<span class="term_write">M</span>&gt; /dev/cpu/microcode - microcode support
[ ]   Intel microcode patch loading support
[<span class="term_write">*</span>]   AMD microcode patch loading support
&lt;<span class="term_write">M</span>&gt; /dev/cpu/*/msr - Model-specific register support
&lt;<span class="term_write">*</span>&gt; /dev/cpu/*/cpuid - CPU information support
&lt; &gt; /sys/kernel/debug/x86/cpu/* - CPU Debug support
[ ] Numa Memory Allocation and Scheduler Support
    Memory model (Sparse Memory)  ---&gt;
[<span class="term_write">*</span>] Sparse Memory virtual memmap <span class="term_note">&lt;==可强化些许核心效能</span>
[ ] Allow for memory hot-add
[<span class="term_write">*</span>] Add LRU list to track non-evictable pages
(<span class="term_write">65536</span>) Low address space to protect from user allocation
[ ] Check for low memory corruption
[<span class="term_write">*</span>] Reserve low 64K of RAM on AMI/Phoenix BIOSen <span class="term_note">&lt;==重新侦测 BIOS 资讯</span>
[<span class="term_write">*</span>] MTRR (Memory Type Range Register) support
    <span class="term_say"># 可以让 CPU 具有读取内存特殊区块的能力，尤其在高效能的显卡方面，
    # 可以增进不少效能。这个项目会产生 /proc/mtrr ，X 会读取这个咚咚喔。</span>
[<span class="term_write">*</span>]   MTRR cleanup support
(<span class="term_write">0</span>)     MTRR cleanup enable value (0-1)
(<span class="term_write">1</span>)     MTRR cleanup spare reg num (0-7)
[ ]   x86 PAT support
[ ] EFI runtime service support
[<span class="term_write">*</span>] Enable seccomp to safely compute untrusted bytecode
    Timer frequency (<span class="term_write">300 HZ</span>)  ---&gt;
    <span class="term_say"># 这个项目则与核心针对某个事件立即回应的速度有关。Server 用途可以调整到
    # 300Hz 即可，如果是桌上型计算机使用，需要调整高一点，例如 1000Hz 较佳！</span>
[<span class="term_write">*</span>] kexec system call
[ ] kernel crash dumps
-*- Support for hot-pluggable CPUs
[ ] Compat VDSO support  <span class="term_note">&lt;==旧式功能，可以不要选择</span>
[ ] Built-in kernel command line <span class="term_note">&lt;==正常启动菜单 (grub) 环境，不需要此项功能</span>
</pre></td></tr></tbody></table><br>

		<a name="power"></a>
		<hr><ul class="list1"><li class="text_import1">电源管理功能</li></ul>

		<p>如果选择了『Power management and ACPI options』之后，就会进入系统的电源管理机制中。
		其实电源管理机制还需要搭配主板以及 CPU 的相关省电功能，才能够实际达到省电的效率啦！
		不论是 Server 还是 Desktop 的使用，在目前电力不足的情况下，能省电就加以省电吧！</p>

<table class="term"><tbody><tr><td class="term"><pre>[<span class="term_write">*</span>] Power Management support
[ ]   Power Management Debug Support
[<span class="term_write">*</span>] Suspend to RAM and standby
[ ] Hibernation (aka 'suspend to disk')
[<span class="term_write">*</span>] ACPI (Advanced Configuration and Power Interface) Support  ---&gt;
    <span class="term_say"># 这是个较新的电源管理模块，由於选择后会添加核心约 70K ，所以
    # 对嵌入式系统来说，可能需要考虑考虑。至於 desktop/server 当然就选择啊</span>
    --- ACPI (Advanced Configuration and Power Interface) Support
    [ ]   Deprecated /proc/acpi files
    [<span class="term_write">*</span>]   Deprecated power /proc/acpi directories
    [<span class="term_write">*</span>]   Future power /sys interface
    [<span class="term_write">*</span>]   Deprecated /proc/acpi/event support
    &lt;<span class="term_write">M</span>&gt;   AC Adapter
    &lt;<span class="term_write">M</span>&gt;   Battery
    &lt;<span class="term_write">M</span>&gt;   Button
    -M-   Video
    &lt;<span class="term_write">*</span>&gt;   Fan
    &lt;<span class="term_write">*</span>&gt;   Processor
    &lt;<span class="term_write">*</span>&gt;     Thermal Zone
    [ ]   Debug Statements
    &lt;<span class="term_write">M</span>&gt;   PCI slot detection driver
    &lt;<span class="term_write">M</span>&gt;   Smart Battery System
<span class="term_say">================================================================================</span>
    CPU Frequency scaling  ---&gt;
    <span class="term_say"># 可以经过核心修改 CPU 的运行频率，在说明档当中也提及，还需要启动底下的
    # dynamic cpufreq governor 才可以顺利的启动这个项目。</span>
    [<span class="term_write">*</span>] CPU Frequency scaling
    [<span class="term_write">*</span>]   Enable CPUfreq debugging
    &lt;<span class="term_write">M</span>&gt;   CPU frequency translation statistics
    [<span class="term_write">*</span>]     CPU frequency translation statistics details
          Default CPUFreq governor (userspace)  ---&gt;
    -*-   'performance' governor
    &lt;<span class="term_write">M</span>&gt;   'powersave' governor
    &lt;<span class="term_write">M</span>&gt;   'userspace' governor for userspace frequency scaling
    &lt;<span class="term_write">M</span>&gt;   'ondemand' cpufreq policy governor
    -*-   'conservative' cpufreq governor
          *** CPUFreq processor drivers ***
    &lt;<span class="term_write">M</span>&gt;   ACPI Processor P-States driver
    &lt;<span class="term_write">*</span>&gt;   AMD Opteron/Athlon64 PowerNow!  <span class="term_note">&lt;==因为我们是 AMD 的 CPU 啊！</span>
    &lt;<span class="term_write">M</span>&gt;   Intel Enhanced SpeedStep (deprecated)
    &lt; &gt;   Intel Pentium 4 clock modulation
<span class="term_say">================================================================================</span>
-*- CPU idle PM support
    Memory power savings  ---&gt;
</pre></td></tr></tbody></table><br>

		<a name="bus"></a>
		<hr><ul class="list1"><li class="text_import1">一些汇流排 (bus) 的选项</li></ul>

		<p>这个项目则与汇流排有关啦！分为最常见的 PCI 与 PCI-express 的支持，还有笔记本计算机常见的 PCMCIA 
		插卡啊！要记住的是，那个 PCI-E 的介面务必要选取！不然你的新显卡可能会捉不到！</p>

<table class="term"><tbody><tr><td class="term"><pre>[<span class="term_write">*</span>] PCI support
[<span class="term_write">*</span>]   Support mmconfig PCI config space access
[<span class="term_write">*</span>] PCI Express support
&lt;<span class="term_write">M</span>&gt;   PCI Express Hotplug driver
[<span class="term_write">*</span>]   Root Port Advanced Error Reporting support
-*- Message Signaled Interrupts (MSI and MSI-X)
[<span class="term_write">*</span>] Enable deprecated pci_find_* API
[ ] PCI Debugging
&lt;<span class="term_write">M</span>&gt; PCI Stub driver
[<span class="term_write">*</span>] Interrupts on hypertransport devices
[<span class="term_write">*</span>] PCI IOV support  <span class="term_note">&lt;==与虚拟化有关！请加选此项！</span>
&lt; &gt; PCCard (PCMCIA/CardBus) support  ---&gt; <span class="term_note">&lt;==鸟哥的主机不是 notebook，所以不选。</span>
&lt;<span class="term_write">*</span>&gt; Support for PCI Hotplug  ---&gt;  <span class="term_note">&lt;==不关机情况下，热拔插 PCI 装置</span>
    --- Support for PCI Hotplug
    &lt;<span class="term_write">M</span>&gt;   Fake PCI Hotplug driver
    &lt;<span class="term_write">M</span>&gt;   ACPI PCI Hotplug driver
    &lt;<span class="term_write">M</span>&gt;     ACPI PCI Hotplug driver IBM extensions
    [ ]   CompactPCI Hotplug driver
    &lt;<span class="term_write">M</span>&gt;   SHPC PCI Hotplug driver
</pre></td></tr></tbody></table><br>

		<a name="execute"></a>
		<hr><ul class="list1"><li class="text_import1">编译后运行档的格式</li></ul>

		<p>选择『Executable file formats / Emulations』会见到如下选项。
		底下的选项必须要勾选才行喔！因为是给 Linux 核心运行运行档之用的数据。通常是与编译行为有关啦！</p>

<table class="term"><tbody><tr><td class="term"><pre>[<span class="term_write">*</span>] Kernel support for ELF binaries
[ ] Write ELF core dumps with partial segments
&lt;<span class="term_write">*</span>&gt; Kernel support for MISC binaries
[<span class="term_write">*</span>] IA32 Emulation  <span class="term_note">&lt;==因为我们这里是 64 位，因此 32 位为模拟结果</span>
&lt;<span class="term_write">M</span>&gt;   IA32 a.out support
</pre></td></tr></tbody></table><br>

		<a name="networking"></a>
		<hr><ul class="list1"><li class="text_import1">核心的网络功能</li></ul>

		<p>这个『Networking support』项目是相当重要的选项，因为他还包含了防火墙相关的项目！就是未来在服务器篇会谈到的防火墙 
		iptables 这个数据啊！所以，千万注意了！在这个配置项目当中，很多东西其实我们在基础篇还没有讲到，
		因为大部分的参数都与网络、防火墙有关！由於防火墙是在启动网络之后再配置即可，所以<span class="text_import2">绝大部分的内容都可以被编译成为模块，而且也建议你编成模块</span>！有用到再加载到核心即可啊！</p>

<table class="term"><tbody><tr><td class="term"><pre>--- Networking support
      Networking options  ---&gt;
      <span class="term_say"># 就是这个光啊！里面的数据全部都是重要的防火墙项目！尽量编成模块罗！
      # 至於不晓得功能的部分，就尽量保留默认值即可！</span>
      &lt;<span class="term_write">*</span>&gt; Packet socket          <span class="term_note">&lt;==网络封包，当然要选择啊！</span>
      [<span class="term_write">*</span>]   Packet socket: mmapped IO
      &lt;<span class="term_write">*</span>&gt; Unix domain sockets    <span class="term_note">&lt;==Unix 插槽档，也一定要选择啊！</span>
      &lt;<span class="term_write">*</span>&gt; Transformation user configuration interface
      &lt;<span class="term_write">M</span>&gt; PF_KEY sockets
      [<span class="term_write">*</span>] TCP/IP networking      <span class="term_note">&lt;==能不选择 TCP/IP 吗？</span>
      [<span class="term_write">*</span>]   IP: multicasting
      [<span class="term_write">*</span>]   IP: advanced router
             Choose IP: FIB lookup algorithm (FIB_HASH)  ---&gt;
      [<span class="term_write">*</span>]   IP: policy routing
      [<span class="term_write">*</span>]   IP: equal cost multipath
      [<span class="term_write">*</span>]   IP: verbose route monitoring
      [ ]   IP: kernel level autoconfiguration
      &lt;<span class="term_write">M</span>&gt;   IP: tunneling
      &lt;<span class="term_write">M</span>&gt;   IP: GRE tunnels over IP
      [<span class="term_write">*</span>]     IP: broadcast GRE over IP
      [<span class="term_write">*</span>]   IP: multicast routing
      [<span class="term_write">*</span>]     IP: PIM-SM version 1 support
      [<span class="term_write">*</span>]     IP: PIM-SM version 2 support
      [<span class="term_write">*</span>]   IP: TCP syncookie support (disabled per default)
      &lt;<span class="term_write">M</span>&gt;   IP: AH transformation
      &lt;<span class="term_write">M</span>&gt;   IP: ESP transformation
      &lt;<span class="term_write">M</span>&gt;   IP: IPComp transformation
      &lt;<span class="term_write">M</span>&gt;   IP: IPsec transport mode
      &lt;<span class="term_write">M</span>&gt;   IP: IPsec tunnel mode
      &lt;<span class="term_write">*</span>&gt;   IP: IPsec BEET mode
      -*-   Large Receive Offload (ipv4/tcp)
      &lt;<span class="term_write">M</span>&gt;   INET: socket monitoring interface
      [<span class="term_write">*</span>]   TCP: advanced congestion control  ---&gt; <span class="term_note">&lt;==内部细项全为模块</span>
      &lt;<span class="term_write">M</span>&gt;   The IPv6 protocol  ---&gt; <span class="term_note">&lt;==除必选外，内部细项全为模块</span>
      [<span class="term_write">*</span>]   NetLabel subsystem support
      -*- Security Marking
      <u>[<span class="term_write">*</span>] Network packet filtering framework (Netfilter)  ---&gt;</u>
      <span class="term_say"># 这个就是我们一直讲的防火墙部分！里面细项几乎全选择成为模块！</span>
          --- Network packet filtering framework (Netfilter)
          [ ]   Network packet filtering debugging  <span class="term_note">&lt;==debug 部分不选！</span>
          [<span class="term_write">*</span>]   Advanced netfilter configuration
          [<span class="term_write">*</span>]     Bridged IP/ARP packets filtering
                Core Netfilter Configuration  ---&gt;
          &lt;<span class="term_write">M</span>&gt;   IP virtual server support  ---&gt;
                <u>IP: Netfilter Configuration  ---&gt;</u>
                IPv6: Netfilter Configuration  ---&gt;
          &lt;<span class="term_write">M</span>&gt;   Ethernet Bridge tables (ebtables) support  ---&gt;
          <span class="term_say"># 上面的细项，除了必选外其他的都编成模块喔！原始没选的也请选为模块</span>
<span class="term_say">================================================================================</span>
      &lt;<span class="term_write">M</span>&gt; Asynchronous Transfer Mode (ATM)
      &lt;<span class="term_write">M</span>&gt;   Classical IP over ATM
      [ ]     Do NOT send ICMP if no neighbour
      &lt;<span class="term_write">M</span>&gt;   LAN Emulation (LANE) support
      &lt; &gt;     Multi-Protocol Over ATM (MPOA) support
      &lt;<span class="term_write">M</span>&gt;   RFC1483/2684 Bridged protocols
      [ ]     Per-VC IP filter kludge
      &lt;<span class="term_write">M</span>&gt; 802.1d Ethernet Bridging
      &lt;<span class="term_write">M</span>&gt; 802.1Q VLAN Support
      [ ]   GVRP (GARP VLAN Registration Protocol) support
      &lt;<span class="term_write">M</span>&gt; DECnet Support
      &lt;<span class="term_write">M</span>&gt; ANSI/IEEE 802.2 LLC type 2 Support
      [ ]   IPX: Full internal IPX network (NEW)
      &lt;<span class="term_write">M</span>&gt; Appletalk protocol support
      &lt; &gt;   Appletalk interfaces support
      &lt;<span class="term_write">M</span>&gt; Phonet protocols family
      [<span class="term_write">*</span>] QoS and/or fair queueing  ---&gt; <span class="term_note">&lt;==内容同样全为模块！</span>
      [ ] Data Center Bridging support
          Network testing  ---&gt; <span class="term_note">&lt;==保留成模块默认值</span>
<span class="term_say">================================================================================</span>
<span class="term_say"># 底下的则是一些特殊的网络设备，例如红外线啊、蓝芽啊！
# 如果不清楚的话，就使用模块吧！除非你真的知道不要该项目！</span>
[ ]   Amateur Radio support  ---&gt;
&lt; &gt;   CAN bus subsystem support  ---&gt;
&lt; &gt;   IrDA (infrared) subsystem support  ---&gt;
&lt;<span class="term_write">M</span>&gt;   Bluetooth subsystem support  ---&gt;
      <span class="term_say"># 这个是蓝芽支持，同样的，里面除了必选之外，其他通通挑选成为模块！</span>
[<span class="term_write">*</span>]   Wireless  ---&gt;
      <span class="term_say"># 这个则是无线网络设备，里面保留默认值，但可编成模块的就选模块</span>
&lt;<span class="term_write">M</span>&gt;   WiMAX Wireless Broadband support  ---&gt;
      <span class="term_say"># 新一代的无线网络，也请勾选成为模块！</span>
{M}   RF switch subsystem support  ---&gt;
</pre></td></tr></tbody></table><br>

		<a name="device"></a>
		<hr><ul class="list1"><li class="text_import1">各项装置的驱动程序</li></ul>

		<p>进入『Device Drivers』这个是所有硬件装置的驱动程序库！哇！光是看到里面这么多内容，鸟哥头都昏了～
		不过，为了你自己的主机好，建议你还是得要一个项目一个项目的去挑选挑选才行～
		这里面的数据就与你主机的硬件有绝对的关系了！</p>

		<p>在这里面真的很重要，因为很多数据都与你的硬件有关。核心推出时的默认值是比较符合一般状态的，
		所以很多数据其实保留默认值就可以编的很不错了！不过，也因为较符合一般状态，
		所以核心额外的编译进来很多跟你的主机系统不符合的数据，例如网络卡装置～
		你可以针对你的主板与相关硬件来进行编译。不过，还是要记得有『未来扩充性』的考量！
		之前鸟哥不是谈过吗，我的网络卡由螃蟹卡换成 3Com 时，核心捉不到～
		因为...鸟哥并没有将 3Com 的网络卡编译成为模块啊！ @_@</p>

<table class="term"><tbody><tr><td class="term"><pre>    Generic Driver Options  ---&gt;    <span class="term_note">&lt;==与韧体有关，保留默认值即可</span>
&lt;<span class="term_write">*</span>&gt; Connector - unified userspace &lt;-&gt; kernelspace linker  ---&gt;
    <span class="term_say"># 与使用者/核心层级的资讯沟通有关，务必要选择啊！</span>
&lt;<span class="term_write">M</span>&gt; Memory Technology Device (MTD) support  ---&gt;
    <span class="term_say"># 例如闪存(拇指碟之类)之支持，通常与嵌入式系统有关！
    # 但由於我们也会用到闪盘，所以里面的数据全编为模块！</span>
&lt;<span class="term_write">M</span>&gt; Parallel port support  ---&gt;
    <span class="term_say"># 平行序列埠的支持，例如早期的 25 针打印机与 9 针鼠标等，细项全编为模块！</span>
-*- Plug and Play support  ---&gt;     <span class="term_note">&lt;==不罗唆！当然要选择这个项目！</span>
[<span class="term_write">*</span>] Block devices  ---&gt;   <span class="term_note">&lt;==区块装置，就是一些储存媒体！细项内容请全编为模块</span>
[<span class="term_write">*</span>] Misc devices  ---&gt;    <span class="term_note">&lt;==一些较冷门的设备，建议还是全部编为模块！</span>
&lt;<span class="term_write">*</span>&gt; ATA/ATAPI/MFM/RLL support  ---&gt; <span class="term_note">&lt;==IDE 介面相关的芯片组！</span>
    <span class="term_say"># 这个其实与主板的南桥芯片有关！由於鸟哥的主机为 ALi 的板子，所以：</span>
    &lt;<span class="term_write">*</span>&gt;   ALI M15x3 chipset support
    <span class="term_say"># 除了可以保留默认值之外，你也可以将没用到的驱动程序取消选择。较重要的还有：</span>
    [ ]   Support for SATA (deprecated; conflicts with libata SATA driver)
    <span class="term_say"># 这个一定不能选！因为 SATA 的模块是在 SCSI 中！</span>
    &lt;<span class="term_write">*</span>&gt;   Include IDE/ATAPI CDROM support
    <span class="term_say"># IDE 的 CDROM 最好直接编译进核心！
    # 其余的驱动程序鸟哥几乎都选择成为模块了！没用到的芯片也将 * 也改成 M 哩！</span>
<span class="term_say">================================================================================</span>
    SCSI device support  ---&gt; 
    <span class="term_say"># 这部份是 SCSI 储存媒体的驱动程序！请一定要选择！因为：
    # 1. 因为 U盘 装置用的就是模拟 SCSI 啊！
    # 2. 因为 SATA 的配置项目就在这里面！</span>
    &lt;<span class="term_write">M</span>&gt; RAID Transport Class
    {M} SCSI device support
    [<span class="term_write">*</span>] legacy /proc/scsi/ support
        *** SCSI support type (disk, tape, CD-ROM) ***
    &lt;<span class="term_write">M</span>&gt; SCSI disk support   <span class="term_note">&lt;==几乎全编为模块即可！</span>
    &lt;<span class="term_write">M</span>&gt; SCSI tape support
    &lt;<span class="term_write">M</span>&gt; SCSI OnStream SC-x0 tape support
    &lt;<span class="term_write">M</span>&gt; SCSI CDROM support
    [<span class="term_write">*</span>]   Enable vendor-specific extensions (for SCSI CDROM)
    &lt;<span class="term_write">M</span>&gt; SCSI generic support
    &lt;<span class="term_write">M</span>&gt; SCSI media changer support
    &lt;<span class="term_write">M</span>&gt; SCSI Enclosure Support
        *** Some SCSI devices (e.g. CD jukebox) support multiple LUNs ***
    [<span class="term_write">*</span>] Probe all LUNs on each SCSI device
    [<span class="term_write">*</span>] Verbose SCSI error reporting (kernel size +=12K)
    [<span class="term_write">*</span>] SCSI logging facility
    [<span class="term_write">*</span>] Asynchronous SCSI scanning
        SCSI Transports  ---&gt;         <span class="term_note">&lt;==细项保留默认值</span>
    [<span class="term_write">*</span>] SCSI low-level drivers  ---&gt;  <span class="term_note">&lt;==主要是磁盘阵列卡，细项可全选为模块</span>
    &lt;<span class="term_write">M</span>&gt; SCSI Device Handlers  ---&gt;    <span class="term_note">&lt;==细项全选为模块</span>
    &lt; &gt; OSD-Initiator library
<span class="term_say">================================================================================</span>
&lt;<span class="term_write">M</span>&gt; Serial ATA (prod) and Parallel ATA (experimental) drivers  ---&gt;
    <span class="term_say"># SATA 之类的磁碟驱动程序！这里的模块与 SCSI 模块是有相依属性的关系！
    # 底下的细项全部选择模块，尤其是 ALi 的这个项目，对鸟哥来说，是一定要勾选的</span>
    &lt;<span class="term_write">M</span>&gt;     ALi PATA support
[<span class="term_write">*</span>] Multiple devices driver support (RAID and LVM)  ---&gt;
    <span class="term_say"># RAID 与 LVM 怎可不选！我们<a href="http://cn.linux.vbird.org/linux_basic/0420quota.php">第十五章</a>才讲过这东西！细项均保留默认值即可</span>
[ ] Fusion MPT device support  ---&gt;
    <span class="term_say"># 一种高阶的 SCSI 控制器，可选可不选！因为鸟哥这里不会用到，所以不选！</span>
    IEEE 1394 (FireWire) support  ---&gt;
    <span class="term_say"># 这个就是俗称的『火线』，许多外接式设备可能会用这个介面，因此，
    # 在此部分内的细项部分，请务必配置为模块喔！不要忘了！</span>
&lt;<span class="term_write">M</span>&gt; I2O device support  ---&gt;       <span class="term_note">&lt;==细项亦全选为模块！</span>
[ ] Macintosh device drivers  ---&gt; <span class="term_note">&lt;==我们是 PC ，所以不需支持麦金塔周边</span>
[<span class="term_write">*</span>] Network device support  ---&gt;   <span class="term_note">&lt;==网络设备的支持是必选！</span>
    --- Network device support
    [<span class="term_write">*</span>]   Enable older network device API compatibility
    &lt;<span class="term_write">M</span>&gt;   Intermediate Functional Block support
    &lt;<span class="term_write">M</span>&gt;   Dummy net driver support
    &lt;<span class="term_write">M</span>&gt;   Bonding driver support
    &lt;<span class="term_write">M</span>&gt;   EQL (serial line load balancing) support
    &lt;<span class="term_write">M</span>&gt;   Universal TUN/TAP device driver support
    &lt;<span class="term_write">M</span>&gt;   Virtual ethernet pair device
    &lt;<span class="term_write">M</span>&gt;   General Instruments Surfboard 1000
    &lt; &gt;   ARCnet support  ---&gt; <span class="term_note">&lt;==较早期的网卡规格，可不选择！</span>
    {M}   PHY Device support and infrastructure  ---&gt; <span class="term_note">&lt;==细项全为模块</span>
    <u>[<span class="term_write">*</span>]   Ethernet (10 or 100Mbit)  ---&gt;</u>
    <u>[<span class="term_write">*</span>]   Ethernet (1000 Mbit)  ---&gt;</u>
    <u>[<span class="term_write">*</span>]   Ethernet (10000 Mbit)  ---&gt;</u>
    <span class="term_say"># 上面三个以太网络网卡支持，不论是否用的到，细项请全编为模块来待命吧！</span>
    &lt; &gt;   Token Ring driver support  ---&gt; <span class="term_note">&lt;==IBM 的 LAN ，可不选！</span>
          Wireless LAN  ---&gt;
          WiMAX Wireless Broadband devices  ---&gt;
          U盘 Network Adapters  ---&gt;
          <span class="term_say"># 上面三个为现阶段很热门的无线网络设备，所以全部内容的细项全选择
          # 为模块！免得未来你的主机加上新的无线设备时会找不到驱动程序！</span>
    [ ]   Wan interfaces support  ---&gt; <span class="term_note">&lt;==WAN 的广域网络设备应该就不用选择了！</span>
    [ ]   ATM drivers  ---&gt; <span class="term_note">&lt;==高阶的 ATM 设备也不用选吧！</span>
    &lt;<span class="term_write">*</span>&gt;   Xen network device frontend driver
    &lt;<span class="term_write">*</span>&gt;   FDDI driver support
    &lt;<span class="term_write">M</span>&gt;     Digital DEFTA/DEFEA/DEFPA adapter support
    [ ]       Use MMIO instead of PIO (NEW)
    &lt;<span class="term_write">M</span>&gt;     SysKonnect FDDI PCI support
    &lt;<span class="term_write">M</span>&gt;   PLIP (parallel port) support
    &lt;<span class="term_write">M</span>&gt;   PPP (point-to-point protocol) support
    [<span class="term_write">*</span>]     PPP filtering
    &lt;<span class="term_write">M</span>&gt;     PPP support for async serial ports
    &lt;<span class="term_write">M</span>&gt;     PPP support for sync tty ports
    &lt;<span class="term_write">M</span>&gt;     PPP Deflate compression
    &lt;<span class="term_write">M</span>&gt;     PPP BSD-Compress compression
    &lt;<span class="term_write">M</span>&gt;     PPP over ATM
    <span class="term_say"># 如果你有 ADSL 拨接的话，呵呵！PPP 的装置也要选择上喔！</span>
    &lt;<span class="term_write">M</span>&gt;   SLIP (serial line) support
    [<span class="term_write">*</span>]     CSLIP compressed headers
    [<span class="term_write">*</span>]   Keepalive and linefill
    [ ]   Six bit SLIP encapsulation
    [<span class="term_write">*</span>]   Fibre Channel driver support
<span class="term_say">================================================================================</span>
[ ] ISDN support  ---&gt;
&lt; &gt; Telephony support  ---&gt;
    <span class="term_say"># 这两个设备没用到，所以也可以不要选择！</span>
    Input device support  ---&gt;
    <span class="term_say"># 这里面含有鼠标、键盘、摇杆、触控版等输入装置，尽量全选为模块吧！</span>
    Character devices  ---&gt;
    <span class="term_say"># 周边组件设备部分，也全选为模块吧！</span>
{M} I2C support  ---&gt;
    <span class="term_say"># 还记得我们去侦测主板的温度与压力吧？呵呵！那就是透过核心的这个 I2C 
    # 的模块功能！ALi 默认没有被编入核心，所以请进入选择成模块！</span>
[ ] SPI support  ---&gt;
[ ] GPIO Support  ---&gt;
&lt; &gt; Dallas's 1-wire support  ---&gt;
-*- Power supply class support  ---&gt;
    <span class="term_say"># 绝大部分都没有用到的咚咚，所以保留默认值，不选择！</span>
&lt;<span class="term_write">M</span>&gt; Hardware Monitoring support  ---&gt;
    <span class="term_say"># 硬件侦测器的支持，记得也要挑选，然后内容全为模块！</span>
-*- Generic Thermal sysfs driver  ---&gt;
[<span class="term_write">*</span>] Watchdog Timer Support  ---&gt; <span class="term_note">&lt;==需搭配 watchdog 服务</span>
    <span class="term_say"># 若搭配 watchdog 服务，可以配置在某些特定状况下重新启动主机！</span>
    Sonics Silicon Backplane  ---&gt;
    Multifunction device drivers  ---&gt;
    <span class="term_say"># 鸟哥没有这样的设备，所以也没有选择！</span>
[ ] Voltage and Current Regulator Support  ---&gt;
    Multimedia devices  ---&gt;
    <span class="term_say"># 一堆多媒体装置如影像撷取卡、FM 广播声卡。但如果你的 Linux 是桌上型计算机，
    # 里面需要挑选成模块较佳！因为一大堆多媒体介面卡！</span>
    Graphics support  ---&gt;  <span class="term_note">&lt;==这就重要了！显卡选择！</span>
    <span class="term_say"># 嘿嘿！重点之一，显卡的芯片组～刚刚前面提到的都是主板的对显卡的
    # 汇流排支持 (PCI-E 与 AGP) ，这里则是针对显卡芯片！鸟哥的显卡是 NVidia 
    # 的，所以将他选择即可！其他的可以编成模块！</span>
&lt;<span class="term_write">M</span>&gt; Sound card support  ---&gt;
    <span class="term_say"># 声卡部分，也全部选择成为模块啦！反正编成模块又不用钱～</span>
[<span class="term_write">*</span>] HID Devices  ---&gt; <span class="term_note">&lt;==人机介面装置，保留默认值即可(也可不选)</span>
[<span class="term_write">*</span>] U盘 support  ---&gt;
    <span class="term_say"># 不能不选的 U盘 ，内容也全部是模块即可！尤其底下这三个：</span>
    &lt;<span class="term_write">M</span>&gt;     EHCI HCD (U盘 2.0) support
    &lt;<span class="term_write">M</span>&gt;     OHCI HCD support
    &lt;<span class="term_write">M</span>&gt;     UHCI HCD (most Intel and VIA) support
&lt;<span class="term_write">M</span>&gt; MMC/SD/SDIO card support  ---&gt;  <span class="term_note">&lt;==多媒体介面卡，保留默认值</span>
&lt; &gt; Sony MemoryStick card support (EXPERIMENTAL)  ---&gt;
-*- LED Support  ---&gt;
[ ] Accessibility support  ---&gt;
&lt;<span class="term_write">M</span>&gt; InfiniBand support  ---&gt; <span class="term_note">&lt;==高阶网络设备</span>
[<span class="term_write">*</span>] EDAC - error detection and reporting  ---&gt;
&lt;<span class="term_write">M</span>&gt; Real Time Clock  ---&gt; <span class="term_note">&lt;==内容选为模块吧！</span>
[ ] DMA Engine support  ---&gt;
[ ] Auxiliary Display support  ---&gt;
&lt; &gt; Userspace I/O drivers  ---&gt;
[<span class="term_write">*</span>] Xen memory balloon driver
[<span class="term_write">*</span>]   Scrub pages before returning them to system
&lt;<span class="term_write">*</span>&gt; Xen filesystem
[<span class="term_write">*</span>]   Create compatibility mount point /proc/xen
[ ] Staging drivers  ---&gt;
[ ] X86 Platform Specific Device Drivers  ---&gt;
    <span class="term_say"># 一堆笔记本计算机的驱动，可以不选啦！</span>
</pre></td></tr></tbody></table>

		<p>底下则与 Firmware Drivers 有关喔！基本上，都保留默认值就好了！</p>

<table class="term"><tbody><tr><td class="term"><pre>&lt;<span class="term_write">M</span>&gt; BIOS Enhanced Disk Drive calls determine boot disk
[ ]   Sets default behavior for EDD detection to off (NEW)
&lt;<span class="term_write">M</span>&gt; BIOS update support for DELL systems via sysfs
&lt;<span class="term_write">M</span>&gt; Dell Systems Management Base Driver
[<span class="term_write">*</span>] Export DMI identification via sysfs to userspace
[<span class="term_write">*</span>] iSCSI Boot Firmware Table Attributes
&lt;<span class="term_write">M</span>&gt;   iSCSI Boot Firmware Table Attributes module
</pre></td></tr></tbody></table><br>

		<a name="filesystem"></a>
		<hr><ul class="list1"><li class="text_import1">文件系统的支持</li></ul>

		<p>文件系统的支持也是很重要的一项核心功能！因为如果不支持某个文件系统，那么我们的 Linux kernel 
		就无法认识，当然也就无法使用啦！例如 Quota, NTFS 等等特殊的 filesystem 。
		这部份也是有够麻烦～因为涉及核心是否能够支持某些文件系统，以及某些操作系统支持的
		partition table 项目。在进行选择时，也务必要特别的小心在意喔！
		尤其是我们常常用到的网络操作系统 (NFS/Samba 等等)，以及基础篇谈到的 Quota 等，
		你都得要勾选啊！否则是无法被支持的。比较有趣的是 NTFS 在这一版的核心里面竟然有支持可写入的项目，
		著实让鸟哥吓了一跳了！^_^</p>

<table class="term"><tbody><tr><td class="term"><pre>&lt;<span class="term_write">*</span>&gt; Second extended fs support
[<span class="term_write">*</span>]   Ext2 extended attributes
[<span class="term_write">*</span>]     Ext2 POSIX Access Control Lists
[<span class="term_write">*</span>]     Ext2 Security Labels
[<span class="term_write">*</span>]   Ext2 execute in place support
&lt;<span class="term_write">*</span>&gt; Ext3 journalling file system support <span class="term_note">&lt;==建议这里直接编进核心</span>
[ ]   Default to 'data=ordered' in ext3 (legacy option)
[<span class="term_write">*</span>]   Ext3 extended attributes
[<span class="term_write">*</span>]     Ext3 POSIX Access Control Lists
[<span class="term_write">*</span>]     Ext3 Security Labels
&lt;<span class="term_write">M</span>&gt; The Extended 4 (ext4) filesystem
[<span class="term_write">*</span>]   Enable ext4dev compatibility
[<span class="term_write">*</span>]   Ext4 extended attributes (NEW)
[<span class="term_write">*</span>]     Ext4 POSIX Access Control Lists
[<span class="term_write">*</span>]     Ext4 Security Labels
<span class="term_say"># 上面是传统的 EXT2/EXT3 及进阶的 EXT4 支持！除了 EXT4 外，其他编入核心吧！</span>
<span class="term_say">================================================================================</span>
[ ] JBD (ext3) debugging support
[ ] JBD2 (ext4) debugging support (NEW)
&lt;<span class="term_write">M</span>&gt; Reiserfs support
[ ]   Enable reiserfs debug mode (NEW)
[ ]   Stats in /proc/fs/reiserfs (NEW)
[ ]   ReiserFS extended attributes (NEW)
&lt; &gt; JFS filesystem support
&lt;<span class="term_write">M</span>&gt; XFS filesystem support
[<span class="term_write">*</span>]   XFS Quota support
[<span class="term_write">*</span>]   XFS POSIX ACL support
[<span class="term_write">*</span>]   XFS Realtime subvolume support
&lt; &gt; OCFS2 file system support
[<span class="term_write">*</span>] Dnotify support
[<span class="term_write">*</span>] Inotify file change notification support
[<span class="term_write">*</span>]   Inotify support for userspace
[<span class="term_write">*</span>] Quota support
[ ]   Report quota messages through netlink interface
[<span class="term_write">*</span>]   Print quota warnings to console (OBSOLETE)
&lt; &gt; Old quota format support
&lt;<span class="term_write">*</span>&gt; Quota format v2 support
&lt;<span class="term_write">M</span>&gt; Kernel automounter support
&lt;<span class="term_write">M</span>&gt; Kernel automounter version 4 support (also supports v3)
&lt; &gt; FUSE (Filesystem in Userspace) support 
<span class="term_say"># XFS 以及 Reiserfs 与 Quota 建议也是选择起来放啦！</span>
<span class="term_say">================================================================================</span>
    Caches  ---&gt;
    CD-ROM/DVD Filesystems  ---&gt;  <span class="term_note">&lt;==CD内的文件格式，默认值即可</span>
    DOS/FAT/NT Filesystems  ---&gt;  <span class="term_note">&lt;==有支持 NTFS ，要进入挑挑！</span>
      &lt;<span class="term_write">M</span>&gt; MSDOS fs support
      &lt;<span class="term_write">M</span>&gt; VFAT (Windows-95) fs support
      (<span class="term_write">950</span>) Default codepage for FAT    <span class="term_note">&lt;==支持繁体中文</span>
      (<span class="term_write">utf8</span>) Default iocharset for FAT  <span class="term_note">&lt;==支持万国码</span>
      &lt;<span class="term_write">M</span>&gt; NTFS file system support
      [ ]   NTFS debugging support (NEW)
      [<span class="term_write">*</span>]   NTFS write support
<span class="term_say">================================================================================</span>
    Pseudo filesystems  ---&gt;        <span class="term_note">&lt;==类似 /proc ，保留默认值</span>
[*] Miscellaneous filesystems  ---&gt; <span class="term_note">&lt;==其他文件系统的支持，保留默认值</span>
[*] Network File Systems  ---&gt;      <span class="term_note">&lt;==网络文件系统！很重要！也要挑挑！</span>
    --- Network File Systems
    &lt;<span class="term_write">M</span>&gt;   NFS client support
    [<span class="term_write">*</span>]     NFS client support for NFS version 3
    [<span class="term_write">*</span>]       NFS client support for the NFSv3 ACL protocol extension
    &lt;<span class="term_write">M</span>&gt;   NFS server support
    [<span class="term_write">*</span>]     NFS server support for NFS version 3
    [<span class="term_write">*</span>]       NFS server support for the NFSv3 ACL protocol extension
    &lt; &gt;   SMB file system support (OBSOLETE, please use CIFS)
    &lt;<span class="term_write">M</span>&gt;   CIFS support (advanced network filesystem, SMBFS successor)
<span class="term_say"># 最重要就这几项，其他保留默认值即可！</span>
<span class="term_say">================================================================================</span>
    Partition Types  ---&gt;          <span class="term_note">&lt;==分割类型，也是保持默认值即可！</span>
-*- Native language support  ---&gt;  <span class="term_note">&lt;==选择默认的语系</span>
    --- Native language support
    (<span class="term_write">utf8</span>) Default NLS Option
    &lt;<span class="term_write">*</span>&gt;   Traditional Chinese charset (utf-8)
    <span class="term_say"># 除了上述这两个之外，其他的请选择成为模块即可！</span>
</pre></td></tr></tbody></table><br>

		<a name="security"></a>
		<hr><ul class="list1"><li class="text_import1">核心黑客、资讯安全、口令应用</li></ul>

		<p>再接下来有个『Kernel hacking』的项目，那是与核心开发者比较有关的部分，这部分建议保留默认值即可，
		应该不需要去修改他！除非你想要进行核心方面的研究喔。然后底下有个『 Security Options 』，那是属於资讯安全方面的配置，
		包括 SELinux 这个细部权限强化模块也在这里编入核心的！这部分可以作一些额外的配置。
		另外还有『 Cryptographic API 』这个口令应用程序介面工具选项，也是可以保留默认值啦！
		我们来看看有什么比较特殊的地方吧！</p>

<table class="term"><tbody><tr><td class="term"><pre>Security options  ---&gt;
[<span class="term_write">*</span>] Enable access key retention support
[<span class="term_write">*</span>]   Enable the /proc/keys file by which keys may be viewed
[<span class="term_write">*</span>] Enable different security models
[ ] Enable the securityfs filesystem
[<span class="term_write">*</span>] Socket and Networking Security Hooks
[<span class="term_write">*</span>]   XFRM (IPSec) Networking Security Hooks
[ ] Security hooks for pathname based access control
[ ] File POSIX Capabilities
[ ] Root Plug Support
[<span class="term_write">*</span>] NSA SELinux Support
[<span class="term_write">*</span>]   NSA SELinux boot parameter
(<span class="term_write">1</span>)     NSA SELinux boot parameter default value
[<span class="term_write">*</span>]   NSA SELinux runtime disable
[<span class="term_write">*</span>]   NSA SELinux Development Support
[<span class="term_write">*</span>]   NSA SELinux AVC Statistics
(<span class="term_write">1</span>)   NSA SELinux checkreqprot default value
[ ]   NSA SELinux maximum supported policy format version
[ ] Simplified Mandatory Access Control Kernel Support
[ ] TOMOYO Linux Support
[ ] Integrity Measurement Architecture(IMA)
<span class="term_say"># 基本上，这部分保留默认值就对了！你也会发现 NSA 的数据都是直接编进核心！</span>
<span class="term_say">================================================================================</span>
Cryptographic API  ---&gt;
<span class="term_say"># 基本上，除了底下这两个编译进核心之外，其他的通通选择成为模块吧！</span>
{<span class="term_write">*</span>}   MD5 digest algorithm
{<span class="term_write">*</span>}   SHA1 digest algorithm
</pre></td></tr></tbody></table>

		<p>在口令应用程序介面方面，一般我们使用的帐号口令登陆利用的就是 MD5 
		这个加密机制，要让核心有支持才行啊！几乎所有的项目都给他做成模块即可！
		不过 MD5 与 SHA1 必须要直接由核心支持比较好！<br><br></p>

		<a name="virt"></a>
		<hr><ul class="list1"><li class="text_import1">虚拟化与函式库</li></ul>

		<p>虚拟化是近年来非常热门的一个议题，因为计算机的能力太强，所以时常闲置在那边，
		此时，我们可以透过虚拟化技术在一部主机上面同时启动多个操作系统来运行，这就是所谓的虚拟化。
		Linux 核心已经主动的纳入虚拟化功能喔！而 Linux 认可的虚拟化使用的机制为 KVM (Kernel base Virtual Machine)。
		至於常用的核心函式库也可以全部编为模块罗！</p>

<table class="term"><tbody><tr><td class="term"><pre>[<span class="term_write">*</span>] Virtualization  ---&gt;
    --- Virtualization
    &lt;<span class="term_write">M</span>&gt;   Kernel-based Virtual Machine (KVM) support
    &lt;<span class="term_write">M</span>&gt;     KVM for Intel processors support
    &lt;<span class="term_write">M</span>&gt;     KVM for AMD processors support
    [ ]     KVM trace support (NEW)
    &lt;<span class="term_write">M</span>&gt;   Virtio balloon driver (EXPERIMENTAL)
<span class="term_say">================================================================================</span>
Library routines  ---&gt;
    {<span class="term_write">M</span>} CRC-CCITT functions
    {<span class="term_write">M</span>} CRC16 functions
    {<span class="term_write">M</span>} CRC calculation for the T10 Data Integrity Field
    {<span class="term_write">M</span>} CRC ITU-T V.41 functions
    -*- CRC32 functions
    &lt;<span class="term_write">M</span>&gt; CRC7 functions
    {<span class="term_write">*</span>} CRC32c (Castagnoli, et al) Cyclic Redundancy-Check
</pre></td></tr></tbody></table>

		<p>最后，还有底下这两个项目，这两个项目与核心功能无关，但是与挑选时的配置文件有关：</p>

<table class="term"><tbody><tr><td class="term"><pre>Load an Alternate Configuration File
Save an Alternate Configuration File
</pre></td></tr></tbody></table>

		<p>这两个项目分别是储存刚刚做好的所有项目的配置数据，另一个则是将来自其他人作的选择给他读入！
		事实上，刚刚我们所做的配置只要在离开时选择 SAVE ，那么这些项目
		<span class="text_import2">通通会记录到目前这个目录下的 .config 文件内</span>。
		而我们也可以使用上面提到的 Save Configuration 这个项目来将刚刚做完的配置储存成另外的文件，
		做成这个文件的好处是，你可以在下次在其他版本的核心作选择时，直接以 Load 
		来将这个文件的配置项目读入，这样可以减少你还要重新挑选一遍的困境啊！</p>

		<p>要请你注意的是，上面的数据主要是适用在鸟哥的个人机器上面的，
		目前鸟哥比较习惯使用原本 distributions 提供的默认核心，因为他们也会主动的进行升级，
		所以鸟哥就懒的自己重编核心了～ ^_^</p>

		<p>此外，因为鸟哥重视的地方在於『网络服务器』上面，所以里头的配置少掉了相当多的个人桌上型
		Linux 的硬件编译！所以，如果你想要编译出一个适合你的机器的核心，
		那么可能还有相当多的地方需要来修正的！不论如何，请随时以
		Help 那个选项来看一看内容吧！反正 Kernel 重编的机率不大！花多一点时间重新编译一次！
		然后将该编译完成的参数文件储存下来，未来就可以直接将该文件叫出来读入了！
		所以花多一点时间安装一次就好！那也是相当值得的！</p>
	</div>
</div>


<hr><a name="make"></a><img src="./鸟哥的 Linux 私房菜27 -- Linux 核心编译_files/logo.png" alt="大标题的图示" width="35" align="middle" height="34"><span class="text_h1">核心的编译与安装</span><br>
<div class="block1">
	<p>将最复杂的核心功能选择完毕后，接下来就是进行这些核心、核心模块的编译了！而编译完成后，当然就是需要使用噜～
	那如何使用新核心呢？就得要考虑 grub 这个玩意儿啦！底下我们就来处理处理：<br><br></p>

	<hr><a name="make_kernel"></a><img src="./鸟哥的 Linux 私房菜27 -- Linux 核心编译_files/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">编译核心与核心模块</span><br>
	<div class="block2">
		<p>核心与核心模块需要先编译起来，而编译的过程其实非常简单，你可以先使用『 make help 』去查阅一下所有可用编译参数，
		就会知道有底下这些基本功能：</p>

<table class="term"><tbody><tr><td class="term"><pre>[root@www linux-2.6.30.3]# <span class="term_command">make vmlinux</span>  <span class="term_note">&lt;==未经压缩的核心</span>
[root@www linux-2.6.30.3]# <span class="term_command">make modules</span>  <span class="term_note">&lt;==仅核心模块</span>
[root@www linux-2.6.30.3]# <span class="term_command">make bzImage</span>  <span class="term_note">&lt;==经压缩过的核心(默认)</span>
[root@www linux-2.6.30.3]# <span class="term_command">make all    </span>  <span class="term_note">&lt;==进行上述的三个动作</span>
</pre></td></tr></tbody></table>

		<p>我们常见的在 /boot/ 底下的核心文件，都是经过压缩过的核心文件，因此，上述的动作中比较常用的是 modules 与
		bzImage 这两个，其中 bzImage 第三个字母是英文大写的 I 喔！bzImage 可以制作出压缩过后的核心，
		也就是一般我们拿来进行系统启动的资讯罗！所以，基本上我们会进行的动作是：</p>

<table class="term"><tbody><tr><td class="term"><pre>[root@www linux-2.6.30.3]# <span class="term_command">make clean  </span>  <span class="term_note">&lt;==先清除缓存档</span>
[root@www linux-2.6.30.3]# <span class="term_command">make bzImage</span>  <span class="term_note">&lt;==先编译核心</span>
[root@www linux-2.6.30.3]# <span class="term_command">make modules</span>  <span class="term_note">&lt;==再编译模块</span>
</pre></td></tr></tbody></table>

		<p>上述的动作会花费非常长的时间，编译的动作依据你选择的项目以及你主机硬件的效能而不同。
		最后制作出来的数据是被放置在 /usr/src/kernels/linux-2.6.30.3/ 
		这个目录下，还没有被放到系统的相关路径中喔！在上面的编译过程当中，如果有发生任何错误的话，
		很可能是由於核心项目的挑选选择的不好，可能你需要重新以 make menuconfig 再次的检查一下你的相关配置喔！
		如果还是无法成功的话，那么或许将原本的核心数据内的 .config 文件，复制到你的核心原始档目录下，
		然后据以修改，应该就可以顺利的编译出你的核心了。最后注意到，下达了 make bzImage 后，最终的结果应该会像这样：</p>

<table class="term"><tbody><tr><td class="term"><pre>Root device is (8, 1)
Setup is 12696 bytes (padded to 12800 bytes).
System is 2207 kB
CRC 7701ab0e
Kernel: <span class="term_write">arch/x86/boot/bzImage</span> is ready  (#1)
[root@www linux-2.6.30.3]# <span class="term_command">ll arch/x86/boot/bzImage</span>
-rw-r--r-- 1 root root 2272432  7月 30 13:35 arch/x86/boot/bzImage
</pre></td></tr></tbody></table>

		<p>可以发现你的核心已经编译好而且放置在 /usr/src/kernels/linux-2.6.30.3/arch/x86/boot/bzImage
		里面罗～那个就是我们的核心文件！最重要就是他啦！我们等一下就会安装到这个文件哩！
		然后就是编译模块的部分罗～ make modules 进行完毕后，就等著安装啦！ ^_^</p>
	</div>

	<hr><a name="make_module"></a><img src="./鸟哥的 Linux 私房菜27 -- Linux 核心编译_files/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">实际安装模块</span><br>
	<div class="block2">
		<p>安装模块前有个地方得要特别强调喔！我们知道模块是放置到 /lib/modules/$(uname -r) 目录下的，那如果<span class="text_import2">同一个版本的模块被反覆编译后来安装时，会不会产生冲突</span>呢？举例来说，鸟哥这个 2.6.30.3
		的版本第一次编译完成且安装妥当后，发现有个小细节想要重新处理，因此又重新编译过一次，那两个版本一模一样时，
		模块放置的目录会一样，此时就会产生冲突了！如何是好？有两个解决方法啦：</p>
		<ul>
		<li>先将旧的模块目录更名，然后才安装核心模块到目标目录去；</li>
		<li>在 make menuconfig 时，那个 <a href="http://cn.linux.vbird.org/linux_basic/0540kernel.php#general">General setup</a> 内的 Local version 修改成新的名称。</li>
		</ul>
		<p>鸟哥建议使用第二个方式，因为如此一来，你的模块放置的目录名称就不会相同，这样也就能略过上述的目录同名问题罗！
		好，那么如何安装模块到正确的目标目录呢？很简单，同样使用 make 的功能即可：</p>

<table class="term"><tbody><tr><td class="term"><pre>[root@www linux-2.6.30.3]# <span class="term_command">make modules_install</span>
[root@www linux-2.6.30.3]# <span class="term_command">ll /lib/modules/</span>
drwxr-xr-x 3 root root 4096  7月 30 14:31 <span class="term_write">2.6.30.3vbird</span>
</pre></td></tr></tbody></table>

		<p>看到否，最终会在 /lib/modules 底下创建起你这个核心的相关模块喔！不错吧！模块这样就已经处理妥当罗～
		接下来，就是准备要进行核心的安装了！哈哈！又跟 grub 有关罗～</p>
	</div>

	<hr><a name="make_install"></a><img src="./鸟哥的 Linux 私房菜27 -- Linux 核心编译_files/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">开始安装新核心与多重核心菜单 (grub)</span><br>
	<div class="block2">
		<p>现在我们知道核心文件放置在 /usr/src/kernels/linux-2.6.30.3/arch/x86/boot/bzImage 
		，但是其实系统核心理论上都是摆在 /boot  底下，且为 vmlinuz 开头的档名。
		此外，我们也晓得一部主机是可以做成多重启动系统的！这样说，应该知道鸟哥想要干嘛了吧？
		对啦！我们将同时保留旧版的核心，并且新增新版的核心在我们的主机上面。<br><br></p>

		<hr><ul class="list1"><li class="text_import1">移动核心到 /boot 且保留旧核心文件</li></ul>

		<p>保留旧核心有什么好处呢？最大的好处是可以确保系统能够顺利启动啦！因为核心虽然被编译成功了，
		但是并不保证我们刚刚挑选的核心项目完全适合於目前这部主机系统，
		可能有某些地方我们忘记选择了，这将导致新核心无法顺利驱动整个主机系统，更差的情况是，
		你的主机无法成功启动成功！此时，如果我们保留旧的核心，呵呵！若新核心测试不通过，就用旧核心来启动啊！嘿嘿！
		保证比较不会有问题嘛！新核心通常可以这样作的：</p>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">cp /usr/src/kernels/linux-2.6.30.3/arch/x86/boot/bzImage \</span>
&gt; <span class="term_command">/boot/vmlinuz-2.6.30.3vbird</span>  <span class="term_note">&lt;==实际核心</span>
[root@www ~]# <span class="term_command">cp /usr/src/kernels/linux-2.6.30.3/.config \</span>
&gt; <span class="term_command">/boot/config-2.6.30.3vbird</span>   <span class="term_note">&lt;==建议配置档也复制备份</span>
</pre></td></tr></tbody></table><br>

		<hr><ul class="list1"><li class="text_import1">创建相对应的 Initial Ram Disk (initrd)</li></ul>

		<p>还记得<a href="http://cn.linux.vbird.org/linux_basic/0510osloader.php#grub_initrd">第二十章谈过的 initrd</a> 这个玩意儿吧！
		由於鸟哥的系统使用 SATA 磁碟，加上刚刚 SATA 磁碟支持的功能并没有直接编译到核心去，所以当然要使用 initrd 来加载才行！
		使用如下的方法来创建 initrd 吧！记得搭配正确的核心版本喔！</p>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">mkinitrd -v /boot/initrd-2.6.30.3vbird.img  2.6.30.3vbird</span>
<span class="term_say">....(前面省略)....</span>
Adding module ehci-hcd
Adding module ohci-hcd
Adding module uhci-hcd
<span class="term_say">....(后面省略)....</span>
</pre></td></tr></tbody></table><br>

		<hr><ul class="list1"><li class="text_import1">编辑启动菜单 (grub)</li></ul>

		<p>鸟哥这部测试机之前是使用 Xen 的核心来启动的，但因为 Xen 核心的制作比较复杂，本章并没有实作出 Xen 虚拟机器的核心。
		底下鸟哥使用的是刚刚编译成功的核心来进行启动菜单的配置，你会看到的配置档与你的环境可能会有不一样喔！
		那就来看看吧！</p>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">vim /boot/grub/menu.lst</span>
default=0
timeout=10
splashimage=(hd0,0)/boot/grub/splash.xpm.gz
#hiddenmenu
title CentOS (2.6.18-128.2.1.el5xen)
        root (hd0,0)
        kernel /boot/xen.gz-2.6.18-128.2.1.el5
        module /boot/vmlinuz-2.6.18-128.2.1.el5xen ro root=LABEL=/ rhgb quiet
        module /boot/initrd-2.6.18-128.2.1.el5xen.img
<span class="term_write">title CentOS testing kernel from vbird
        root (hd0,0)
        kernel /boot/vmlinuz-2.6.30.3vbird ro root=LABEL=/ rhgb
        initrd /boot/initrd-2.6.30.3vbird.img</span>
</pre></td></tr></tbody></table>

		<p>新增上述的特殊字体到你的配置档当中。另外，你会发现我上头的 default 并没有修改到最新的那个核心的菜单上，
		因为我必须要测试一下新核心能否顺利启动！如果顺利启动且运行没有问题后，那么才来修订这个 default 的值吧！<br><br></p>

		<hr><ul class="list1"><li class="text_import1">重新以新核心启动、测试、修改</li></ul>

		<p>如果上述的动作都成功后，接下来就是重新启动并选择新核心来启动系统啦！如果系统顺利启动之后，你使用 uname -a
		会出现类似底下的数据：</p>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">uname -a</span>
Linux www.vbird.tsai <span class="term_write">2.6.30.3vbird</span> #1 SMP Thu Jul 30 13:34:31 
CST 2009 <span class="term_write">x86_64 x86_64 x86_64</span> GNU/Linux
</pre></td></tr></tbody></table>

		<p>包括核心版本与支持的硬件平台都是 OK 的！嘿嘿！那你所编译的核心就是差不多成功的啦！
		如果运行一阵子后，你的系统还是稳定的情况下，那就能够将 default 值使用这个新的核心来作为默认启动罗！
		这就是核心编译！那你也可以自己处理嵌入式系统的核心编译罗！ ^_^</p>
	</div>
</div>


<hr><a name="module"></a><img src="./鸟哥的 Linux 私房菜27 -- Linux 核心编译_files/logo.png" alt="大标题的图示" width="35" align="middle" height="34"><span class="text_h1">额外(单一)核心模块编译</span><br>
<div class="block1">
	<p>我们现在知道核心所支持的功能当中，有直接编译到核心内部的，也有使用外挂模块的，外挂模块可以简单的想成<span class="text_import2">就是驱动程序</span> 啦！那么也知道这些核心模块依据不同的版本，被分别放置到 
	/lib/modules/$(uname -r)/kernel/ 目录中，各个硬件的驱动程序则是放置到 /lib/modules/$(uname -r)/kernel/drivers/ 
	当中！换个角度再来思考一下，如果刚刚我自己编译的数据中，有些驱动程序忘记编译成为模块了，那是否需要重新进行上述的所有动作？
	又如果我想要使用硬件厂商释出的新驱动程序，那该如何是好？<br><br></p>

	<hr><a name="module_before"></a><img src="./鸟哥的 Linux 私房菜27 -- Linux 核心编译_files/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">编译前注意事项</span><br>
	<div class="block2">
		<p>由於我们的核心原本就有提供很多的核心工具给硬件开发商来使用，
		而硬件开发商也需要针对核心所提供的功能来设计他们的驱动程序模块，因此，
		我们如果想要自行使用硬件开发商所提供的模块来进行编译时，就需要使用到核心所提供的原始档当中，
		所谓的标头文件 (header include file) 来取得驱动模块所需要的一些函式库或标头的定义啦！
		也因此我们常常会发现到，如果想要自行编译核心模块时，就得要拥有核心原始码嘛！</p>

		<p>那核心原始码我们知道他是可能放置在 /usr/src/ 底下，早期的核心原始码被要求一定要放置到 /usr/src/linux/
		目录下，不过，如果你有多个核心在一个 Linux 系统当中，而且使用的原始码并不相同时，
		呵呵～问题可就大了！所以，在 2.6 版以后，核心使用比较有趣的方法来设计他的原始码放置目录，
		那就是以 /lib/modules/$(uname -r)/build 及 /lib/modules/$(uname -r)/source
		这两个连结档来指向正确的核心原始码放置目录。如果以我们刚刚由 kernel 2.6.30.3 创建的核心模块来说，
		那么他的核心模块目录底下有什么咚咚？</p>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">ll -h /lib/modules/2.6.30.3vbird/</span>
<span style="font-size: 9pt;">lrwxrwxrwx  1 root root   31  7月 30 14:29 build -&gt; /usr/src/kernels/linux-2.6.30.3
drwxr-xr-x 10 root root 4.0K  7月 30 14:30 kernel
-rw-r--r--  1 root root 337K  7月 30 14:31 modules.alias
-rw-r--r--  1 root root   69  7月 30 14:31 modules.ccwmap
-rw-r--r--  1 root root 224K  7月 30 14:31 modules.dep
<span class="term_say">....(中间省略)....</span>
lrwxrwxrwx  1 root root   31  7月 30 14:29 source -&gt; /usr/src/kernels/linux-2.6.30.3</span>
</pre></td></tr></tbody></table>

		<p>比较有趣的除了那两个连结档之外，还有那个 modules.dep 文件也挺有趣的，
		那个文件是记录了核心模块的相依属性的地方，依据该文件，我们可以简单的使用
		modprobe 这个命令来加载模块呢！至於核心原始码提供的标头档，在上面的案例当中，
		则是放置到 /usr/src/kernels/linux-2.6.30.3/include/ 目录中，当然就是藉由 build/source
		这两个连结文件来取得目录所在的啦！^_^</p>

		<p>由於核心模块的编译其实与核心原本的原始码有点关系的，因此如果你需要重新编译模块时，
		那除了 make, gcc 等主要的编译软件工具外，<span class="text_import2">你还需要的就是 kernel-devel 
		这个软件</span>！记得一定要安装喔！而如果你想要在默认的核心底下新增模块的话，那么就得要找到 kernel 的 SRPM 文件了！
		将该文件给他安装，并且取得 source code 后，才能够顺利的编译喔！</p>
	</div>

	<hr><a name="module_compile"></a><img src="./鸟哥的 Linux 私房菜27 -- Linux 核心编译_files/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">单一模块编译</span><br>
	<div class="block2">
		<p>想像两个情况：</p>

		<ul>
		<li>如果我的默认核心忘记加入某个功能，而且该功能可以编译成为模块，不过，
		默认核心却也没有将该项功能编译成为模块，害我不能使用时，该如何是好？<br><br></li>
		<li>如果 Linux 核心原始码并没有某个硬件的驱动程序 (module) ，但是开发该硬件的厂商有提供给
		Linux 使用的驱动程序原始码，那么我又该如何将该项功能编进核心模块呢？</li>
		</ul>

		<p>很有趣对吧！不过，在这样的情况下其实没有什么好说的，反正就是
		『去取得原始码后，重新编译成为系统可以加载的模块』啊！很简单，对吧！^_^！
		但是，上面那两种情况的模块编译行为是不太一样的，不过，都是需要 make, 
		gcc 以及核心所提供的 include 标头档与函式库等等。<br><br></p>

		<hr><ul class="list1"><li class="text_import1">硬件开发商提供的额外模块</li></ul>

		<p>很多时候，可能由於核心默认的核心驱动模块所提供的功能你不满意，或者是硬件开发商所提供的核心模块具有更强大的功能，
		又或者该硬件是新的，所以默认的核心并没有该硬件的驱动模块时，那你只好自行由硬件开发商处取得驱动模块，
		然后自行编译罗！</p>

		<p>如果你的硬件开发商有提供驱动程序的话，那么真的很好解决，直接下载该原始码，重新编译，
		将他放置到核心模块该放置的地方后就能够使用了！举个例子来说，为了省电，鸟哥在 2009 
		年初买了整合型主板来架设家用的服务器，没想到 CentOS 5.1 以前的版本对鸟哥新买的主板内建网卡支持度不足，
		使用的网卡驱动程序 r8169 有问题！搜寻了 google 才发现大家都有这个问题。解决方法就是到 Realtek
		官网下载网卡驱动程序来编译即可。</p>

		<ul><li>Realtek 的 r8168 网卡驱动程序：<a href="http://www.realtek.com.tw/downloads/" target="_blank">http://www.realtek.com.tw/downloads/</a></li>
		<li>选择『Communications Network ICs』--&gt;『Network Interface Controlllers』--&gt;
		『10/100/1000M Gigabit Ethernet』--&gt; 『PCI Express』--&gt;
		『Software』就能够下载了！</li>
		</ul>

		<p>你可以利用各种方法将他下载后，假设这个文件放置到 /root ，那么直接将他解压缩吧！
		之后就可以读一读 INSTALL/README ，然后找一下 Makefile ，就能够编译了。整体流程有点像这样：</p>

<table class="term"><tbody><tr><td class="term"><pre><span class="term_hd"># 1. 将文件解压缩：</span>
[root@www ~]# <span class="term_command">cd /usr/local/src</span>
[root@www src]# <span class="term_command">tar -jxvf /root/r8168-8.013.00.tar.bz2</span>
[root@www src]# <span class="term_command">cd r8168-8.013.00/</span>

<span class="term_hd"># 2. 开始进行编译与安装：</span>
[root@www r8168-8.013.00]# <span class="term_command">vi readme</span>  <span class="term_note">&lt;==注意查一下该文件内容</span>
[root@www r8168-8.013.00]# <span class="term_command">make clean modules</span>
[root@www r8168-8.013.00]# <span class="term_command">ll src/*.ko</span>  <span class="term_note">&lt;==创建底下的模块档！</span>
-rw-r--r-- 1 root root 112216  7月 31 01:11 src/r8168.ko
[root@www r8168-8.013.00]# <span class="term_command">make install</span>
install -m 744 -c r8168.ko /lib/modules/2.6.30.3vbird/kernel/drivers/net/
<span class="term_say"># 重点在上面这行！会发现模块已经被移动到核心模块目录！</span>

<span class="term_hd">4. 升级模块相依属性！</span>
[root@www r8168-8.013.00]# <span class="term_command">depmod -a</span>
</pre></td></tr></tbody></table>

		<p>有趣吧！透过这样的动作，我们就可以轻易的将模块编译起来，并且还可以将他直接放置到核心模块目录中，
		同时以 depmod 将模块创建相关性，未来就能够利用 modprobe 来直接取用啦！
		但是需要提醒你的是，<span class="text_import2">当自行编译模块时，
		若你的核心有升级 (例如利用自动升级机制进行线上升级) 时，则你必须要重新编译该模块一次，
		重复上面的步骤</span>才行！因为这个模块仅针对目前的核心来编译的啊！对吧！<br><br></p>

		<hr><ul class="list1"><li class="text_import1">利用旧有的核心原始码进行编译</li></ul>

		<p>如果你后来发现忘记加入某个模块功能了，那该如何是好？其实如果仅是重新编译模块的话，
		那么整个过程就会变的非常简单！我们先到目前的核心原始码所在目录下达 make menuconfig ，
		然后将 NTFS 的选项配置成为模块，之后直接下达：</p>

		<blockquote class="text_import2">make fs/ntfs/</blockquote>

		<p>那么 ntfs 的模块 (ntfs.ko) 就会自动的被编译出来了！
		然后将该模块复制到 /lib/modules/2.6.30.3vbird/kernel/fs/ntsf/ 目录下，
		再运行 depmod -a ，呵呵～就可以在原来的核心底下新增某个想要加入的模块功能罗～ ^_^</p>
	</div>

	<hr><a name="module_mod"></a><img src="./鸟哥的 Linux 私房菜27 -- Linux 核心编译_files/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">核心模块管理</span><br>
	<div class="block2">
		<p>核心与核心模块是分不开的，至於驱动程序模块在编译的时候，更与核心的原始码功能分不开～
		因此，你必须要先了解到：核心、核心模块、驱动程序模块、核心原始码与标头文件的相关性，
		然后才有办法了解到为何编译驱动程序的时候老是需要找到核心的原始码才能够顺利编译！
		然后也才会知道，为何当核心升级之后，自己之前所编译的核心模块会失效～</p>

		<p>此外，与核心模块有相关的，还有那个很常被使用的 modprobe 命令，
		以及启动的时候会读取到的模块定义数据文件 /etc/modprobe.conf ，
		这些数据你也必须要了解才行～相关的命令说明我们已经在<a href="http://cn.linux.vbird.org/linux_basic/0510osloader.php">第二十章</a>内谈过了，
		你应该要自行前往了解喔！ ^_^</p>
	</div>
</div>


<hr><a name="hint"></a><img src="./鸟哥的 Linux 私房菜27 -- Linux 核心编译_files/logo.png" alt="大标题的图示" width="35" align="middle" height="34"><span class="text_h1">重点回顾</span><br>
<div class="block1">
<ul class="text_import2">
	<li>其实核心就是系统上面的一个文件而已，这个文件包含了驱动主机各项硬件的侦测程序与驱动模块；</li>
	<li>上述的核心模块放置於：/lib/modules/$(uname -r)/kernel/</li>
	<li>『驱动程序开发』的工作上面来说，应该是属於硬件发展厂商的问题</li>
	<li>一般的使用者，由於系统已经将核心编译的相当的适合一般使用者使用了，因此一般入门的使用者，基本上，不太需要编译核心</li>
	<li>编译核心的一般目的：新功能的需求、原本的核心太过臃肿、与硬件搭配的稳定性、其他需求(如嵌入式系统)</li>
	<li>编译核心前，最好先了解到您主机的硬件，以及主机的用途，才能选择好核心功能；</li>
	<li>编译前若想要保持核心原始码的干净，可使用 make mrproper 来清除缓存档与配置档；</li>
	<li>挑选核心功能与模块可用 make 配合：menuconfig, oldconfig, xconfig, gconfig 等等</li>
	<li>核心功能挑选完毕后，一般常见的编译过程为：make bzImage, make modules</li>
	<li>模块编译成功后的安装方式为： make modules_install</li>
	<li>核心的安装过程中，需要移动 bzImage 文件、创建 initrd 文件、编辑 /boot/grub/menu.lst 等动作；</li>
	<li>我们可以自行由硬件开发商之官网下载驱动程序来自行编译核心模块！</li>
</ul>
</div>


<hr><a name="ex"></a><img src="./鸟哥的 Linux 私房菜27 -- Linux 核心编译_files/logo.png" alt="大标题的图示" width="35" align="middle" height="34"><span class="text_h1">本章习题</span><br>
( 要看答案请将鼠标移动到『答：』底下的空白处，按下左键圈选空白处即可察看)
<div class="block1">
<ul>
	<li>简单说明核心编译的步骤为何？
	<div class="blockex">
	<ol>
		<li>先下载核心原始码，可以从 http://www.kernel.org 或者是 distributions 的 SRPM 来著手；</li>
		<li>以下以 Tarball 来处理，解开原始码到 /usr/src/kernels 目录下；</li>
		<li>先进行旧数据删除的动作：『make mrproper』；</li>
		<li>开始挑选核心功能，可以利用『make menuconfig』、『make oldconfig』、『make gconfig』等等；</li>
		<li>清除过去的中间缓存档数据：『make clean』</li>
		<li>开始核心文件与核心模块的编译：『make bzImage』、『make modules』</li>
		<li>开始核心模块的安装：『make modules_install』</li>
		<li>开始核心文件的安装，可以使用的方式有：『make install』或者是透过手动的方式复制核心文件到 /boot/grub 当中；</li>
		<li>创建 initrd 文件；</li>
		<li>修改 /boot/grub/menu.lst 文件；</li>
	</ol>
	</div></li>

	<li>如果你利用新编译的核心来操作系统，发现系统并不稳定，你想要移除这个自行编译的核心该如何处理？
	<div class="blockex">
		首先，可以将原始码删除：rm -rf /usr/src/kernels/linux-2.6.30<br>
		再者，删除掉核心模块的目录： rm -rf /lib/modules/2.6.30<br>
		最后删除掉 /boot/ 内的核心文件与 initrd 文件，以及 /boot/grub/menu.lst 内的 title 配置即可。
	</div></li>

</ul>
</div>


<hr><a name="reference"></a><img src="./鸟哥的 Linux 私房菜27 -- Linux 核心编译_files/logo.png" alt="大标题的图示" width="35" align="middle" height="34"><span class="text_h1">参考数据与延伸阅读</span><br>
<div class="block1">
<ul>
	<li><a name="ps1"></a>注1：透过在 /usr/src/kernels/linux-2.6.30.3 底下的 README 以及『 make 
		help 』可以得到相当多的解释</li>
	<li>核心编译的功能：可以用来测试 CPU 效能喔！因为 compile 非常耗系统资源！</li>
	<li><a href="http://lxr.xensource.com/lxr/source/README?a=x86_64" target="_blank">http://lxr.xensource.com/lxr/source/README?a=x86_64</a></li>
</ul>
</div>

<hr><span class="text_history">
2002/05/29：第一次完成<br>
2003/02/11：重新编排与加入 FAQ<br>
2004/06/11：原本的 2.4.xx 版本核心被移动到 <a href="http://linux.vbird.org/linux_basic/0540kernel/0540kernel-2.4.18.php">此处</a><br>
2005/11/15：原本的模块管理已经先移动到<a href="http://linux.vbird.org/linux_basic/0510osloader.php#kernel">启动流程管理</a>那一篇罗！<br>
2005/12/05：经过将近一个月，呵呵！终於给他整理出来这一篇了～真难得～<br>
2007/06/27：<a href="http://cn.linux.vbird.org/linux_basic/0540kernel.php#20070627">添加了 initrd 的简单说明</a>，详细还是得看 loader 那一章。<br>
2009/07/21：将基於 FC4 所撰写的文章移动到<a href="http://linux.vbird.org/linux_basic/0540kernel/0540kernel-fc4.php">此处</a><br>
2009/08/03：原本的 KDE/GNOME 使用的引擎写错了！ KDE 用 Qt ，而 GNOME 是用 Gtk ！非常感谢 Chua Tze An 兄提供的指正！<br>
2009/09/18：加入两个简单的题目，给大家思考一下而已。<hr>
</span>
    </td>
    <td style="width: 16px; font-size: 6px;">　</td></tr>
<tr><td style="width: 16px; height: 16px;">　</td>
    <td style="width: 866px; height: 16px;">　</td>
    <td style="width: 16px; height: 16px;">　</td></tr>
</tbody></table>

<div style="padding-top: 0px; text-align: center;">
<span style="font-size: 80%;">
	<a href="http://linux.vbird.org/" target="_top" title="前往鸟哥的首页">http://linux.vbird.org</a>
	is designed by <a href="mailto:vbird@mail.vbird.idv.tw" title="联络鸟哥(我不要广告信！)">VBird</a>
		during 2001-2011. <a href="http://www.ksu.edu.tw/" target="_blank">ksu.edu</a></span>
         ﻿<div id="apDiv4">
      <p>本网页主要以Firefox配合解析度 1024x768 作为设计依据&nbsp;&nbsp;&nbsp;&nbsp; 鸟哥自由软件整合应用研究室</p></div></div>
</div>
</center>

</body></html>