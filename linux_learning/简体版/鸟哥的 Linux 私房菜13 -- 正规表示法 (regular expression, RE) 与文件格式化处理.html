
<!-- saved from url=(0055)http://cn.linux.vbird.org/linux_basic/0330regularex.php -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
	
	<meta name="Author" content="2011/04/18,lee">
	<meta name="Description" content="介绍正规表示法的应用与相关技巧">
	<title>鸟哥的 Linux 私房菜 -- 正规表示法 (regular expression, RE) 与文件格式化处理</title>
    <script src="./鸟哥的 Linux 私房菜13 -- 正规表示法 (regular expression, RE) 与文件格式化处理_files/SpryMenuBar.js" type="text/javascript"></script>
	<script src="./鸟哥的 Linux 私房菜13 -- 正规表示法 (regular expression, RE) 与文件格式化处理_files/index.js" type="text/javascript"></script>
	<link href="./鸟哥的 Linux 私房菜13 -- 正规表示法 (regular expression, RE) 与文件格式化处理_files/SpryMenuBarHorizontal.css" rel="stylesheet" type="text/css">
    <link href="./鸟哥的 Linux 私房菜13 -- 正规表示法 (regular expression, RE) 与文件格式化处理_files/main.css" rel="stylesheet" type="text/css">
    </head><body style="margin: 0pt; padding: 0pt;" class="table" onload="MM_preloadImages(&#39;image/title_19.png&#39;,&#39;image/title_26.png&#39;,&#39;image/title_27.png&#39;,&#39;image/title_28.png&#39;,&#39;image/title_06.png&#39;,&#39;image/title_08.png&#39;,&#39;image/title_10.png&#39;,&#39;image/title_12.png&#39;)">

<center>
<div id="apDiv5">
<div> <link rel="SHORTCUT ICON" href="http://cn.linux.vbird.org/linux_basic/favicon.ico">
<!-- ImageReady Slices (title3.ai) -->
<table id="___01" width="898" height="81" border="0" align="center" cellpadding="0" cellspacing="0" ;="">
	<tbody><tr>
		<td colspan="15">
			<img src="./鸟哥的 Linux 私房菜13 -- 正规表示法 (regular expression, RE) 与文件格式化处理_files/title_01.png" width="900" height="1" alt=""></td>
	</tr>
	<tr>
		<td rowspan="4" bgcolor="#182448"><p><img src="./鸟哥的 Linux 私房菜13 -- 正规表示法 (regular expression, RE) 与文件格式化处理_files/Count.cgi" width="93" align="left" title="計數器"></p>
	    <p><font color="#FFFFFF" size="-1">since2012/04/23</font></p></td>
		<td rowspan="4" align="left" valign="top"><a href="http://cn.linux.vbird.org/"><img src="./鸟哥的 Linux 私房菜13 -- 正规表示法 (regular expression, RE) 与文件格式化处理_files/title_03.png" alt="" width="263" height="79" border="0"></a></td>
		<td colspan="13">
			<img src="./鸟哥的 Linux 私房菜13 -- 正规表示法 (regular expression, RE) 与文件格式化处理_files/title_04.png" alt="" width="535" height="9" border="0"></td>
	</tr>
	<tr>
		<td rowspan="3">
			<img src="./鸟哥的 Linux 私房菜13 -- 正规表示法 (regular expression, RE) 与文件格式化处理_files/title_05.png" alt="" width="53" height="70" border="0"></td>
		<td colspan="2" align="left" valign="top"><a href="http://cn.linux.vbird.org/linux_basic/0110whatislinux.php" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage(&#39;Image51&#39;,&#39;&#39;,&#39;image/title/title_06.png&#39;,1)"><img src="./鸟哥的 Linux 私房菜13 -- 正规表示法 (regular expression, RE) 与文件格式化处理_files/title3_06.png" name="Image51" width="106" height="25" border="0" id="Image51" alt=""></a></td>
		<td rowspan="2">
			<img src="./鸟哥的 Linux 私房菜13 -- 正规表示法 (regular expression, RE) 与文件格式化处理_files/title_07.png" alt="" width="27" height="37" border="0"></td>
		<td colspan="3" align="left" valign="top"><a href="http://cn.linux.vbird.org/linux_server/0110network_basic.php" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage(&#39;Image52&#39;,&#39;&#39;,&#39;image/title/title_08.png&#39;,1)"><img src="./鸟哥的 Linux 私房菜13 -- 正规表示法 (regular expression, RE) 与文件格式化处理_files/title3_08.png" name="Image52" width="107" height="25" border="0" id="Image52" alt=""></a></td>
		<td rowspan="2">
			<img src="./鸟哥的 Linux 私房菜13 -- 正规表示法 (regular expression, RE) 与文件格式化处理_files/title_09.png" alt="" width="37" height="37" border="0"></td>
		<td colspan="2" align="left" valign="top"><a href="http://cn.linux.vbird.org/about.php" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage(&#39;Image53&#39;,&#39;&#39;,&#39;image/title/title_10.png&#39;,1)"><img src="./鸟哥的 Linux 私房菜13 -- 正规表示法 (regular expression, RE) 与文件格式化处理_files/title3_10.png" name="Image53" width="75" height="25" border="0" id="Image53" alt=""></a></td>
		<td rowspan="3">
			<img src="./鸟哥的 Linux 私房菜13 -- 正规表示法 (regular expression, RE) 与文件格式化处理_files/title_11.png" alt="" width="35" height="70" border="0"></td>
		<td align="left" valign="top"><a href="mailto:vbird@mail.vbird.idv.tw" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage(&#39;Image54&#39;,&#39;&#39;,&#39;image/title/title_12.png&#39;,1)"><img src="./鸟哥的 Linux 私房菜13 -- 正规表示法 (regular expression, RE) 与文件格式化处理_files/title3_12.png" name="Image54" width="74" height="25" border="0" id="Image54" alt=""></a></td>
		<td rowspan="3">
			<img src="./鸟哥的 Linux 私房菜13 -- 正规表示法 (regular expression, RE) 与文件格式化处理_files/title_13.png" alt="" width="21" height="70" border="0"></td>
	</tr>
	<tr>
		<td colspan="2">
			<img src="./鸟哥的 Linux 私房菜13 -- 正规表示法 (regular expression, RE) 与文件格式化处理_files/title_14.png" alt="" width="106" height="12" border="0"></td>
		<td colspan="3">
			<img src="./鸟哥的 Linux 私房菜13 -- 正规表示法 (regular expression, RE) 与文件格式化处理_files/title_15.png" alt="" width="107" height="12" border="0"></td>
		<td colspan="2">
			<img src="./鸟哥的 Linux 私房菜13 -- 正规表示法 (regular expression, RE) 与文件格式化处理_files/title_16.png" width="75" height="12" alt=""></td>
		<td rowspan="2">
			<img src="./鸟哥的 Linux 私房菜13 -- 正规表示法 (regular expression, RE) 与文件格式化处理_files/title_17.png" alt="" width="74" height="45" border="0"></td>
	</tr>
	<tr>
		<td>
			<img src="./鸟哥的 Linux 私房菜13 -- 正规表示法 (regular expression, RE) 与文件格式化处理_files/title_18.png" alt="" width="15" height="33" border="0"></td>
		<td colspan="3" align="left" valign="top"><ul id="MenuBar1" class="MenuBarHorizontal">
	  <li><a href="http://cn.linux.vbird.org/linux_basic/linux_basic.php" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage(&#39;Image44&#39;,&#39;&#39;,&#39;image/title/title_19.png&#39;,1)" class="MenuBarItemSubmenu"><img src="./鸟哥的 Linux 私房菜13 -- 正规表示法 (regular expression, RE) 与文件格式化处理_files/title3_19.png" name="Image44" width="123" height="33" border="0" id="Image44"></a>
			    <ul>
			      <li><a href="http://cn.linux.vbird.org/linux_basic/Mandrake9.0/mandrake9.0.php" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage(&#39;Image46&#39;,&#39;&#39;,&#39;image/title/title_26.png&#39;,1)"><img src="./鸟哥的 Linux 私房菜13 -- 正规表示法 (regular expression, RE) 与文件格式化处理_files/title_23.png" name="Image46" width="120" height="26" border="0" id="Image46" alt=""></a></li>
                  <li><a href="http://cn.linux.vbird.org/linux_basic/fedora_4/fc4.php" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage(&#39;Image47&#39;,&#39;&#39;,&#39;image/title/title_27.png&#39;,1)"><img src="./鸟哥的 Linux 私房菜13 -- 正规表示法 (regular expression, RE) 与文件格式化处理_files/title_24.png" name="Image47" width="120" height="26" border="0" id="Image47" alt=""></a></li>
                  <li><a href="http://cn.linux.vbird.org/linux_basic/linux_basic.php" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage(&#39;Image48&#39;,&#39;&#39;,&#39;image/title/title_28.png&#39;,1)"><img src="./鸟哥的 Linux 私房菜13 -- 正规表示法 (regular expression, RE) 与文件格式化处理_files/title_25.png" name="Image48" width="120" height="26" border="0" id="Image48" alt=""></a></li>
                </ul>
		      </li>
		</ul></td>
		<td>
			<img src="./鸟哥的 Linux 私房菜13 -- 正规表示法 (regular expression, RE) 与文件格式化处理_files/title_20.png" alt="" width="42" height="33" border="0"></td>
		<td colspan="3" align="left" valign="top"><ul id="MenuBar2" class="MenuBarHorizontal">
	  <li><a href="http://cn.linux.vbird.org/linux_server/" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage(&#39;Image45&#39;,&#39;&#39;,&#39;image/title/title_21.png&#39;,1)" class="MenuBarItemSubmenu"><img src="./鸟哥的 Linux 私房菜13 -- 正规表示法 (regular expression, RE) 与文件格式化处理_files/title3_21.png" name="Image45" width="125" height="33" border="0" id="Image45"></a>
			    <ul>
			      <li><a href="http://cn.linux.vbird.org/linux_server/linux_redhat9/redhat9.php" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage(&#39;Image43&#39;,&#39;&#39;,&#39;image/title/title_26.png&#39;,1)"><img src="./鸟哥的 Linux 私房菜13 -- 正规表示法 (regular expression, RE) 与文件格式化处理_files/title_23.png" name="Image43" width="120" height="26" border="0" id="Image43" alt=""></a></li>
			      <li><a href="http://cn.linux.vbird.org/linux_server/centos4.php" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage(&#39;Image49&#39;,&#39;&#39;,&#39;image/title/title_27.png&#39;,1)"><img src="./鸟哥的 Linux 私房菜13 -- 正规表示法 (regular expression, RE) 与文件格式化处理_files/title_24.png" name="Image49" width="120" height="26" border="0" id="Image49" alt=""></a></li>
			      <li><a href="http://cn.linux.vbird.org/linux_server/" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage(&#39;Image50&#39;,&#39;&#39;,&#39;image/title/title_28.png&#39;,1)"><img src="./鸟哥的 Linux 私房菜13 -- 正规表示法 (regular expression, RE) 与文件格式化处理_files/title_25.png" name="Image50" width="120" height="26" border="0" id="Image50" alt=""></a></li>
		        </ul>
		      </li>
		</ul></td>
		<td>
			<img src="./鸟哥的 Linux 私房菜13 -- 正规表示法 (regular expression, RE) 与文件格式化处理_files/title_22.png" alt="" width="47" height="33" border="0"></td>
	</tr>
	<tr>
		<td>
			<img src="./鸟哥的 Linux 私房菜13 -- 正规表示法 (regular expression, RE) 与文件格式化处理_files/Spacer.gif" width="101" height="1" alt=""></td>
		<td>
			<img src="./鸟哥的 Linux 私房菜13 -- 正规表示法 (regular expression, RE) 与文件格式化处理_files/Spacer.gif" width="263" height="1" alt=""></td>
		<td>
			<img src="./鸟哥的 Linux 私房菜13 -- 正规表示法 (regular expression, RE) 与文件格式化处理_files/Spacer.gif" width="53" height="1" alt=""></td>
		<td>
			<img src="./鸟哥的 Linux 私房菜13 -- 正规表示法 (regular expression, RE) 与文件格式化处理_files/Spacer.gif" width="15" height="1" alt=""></td>
		<td>
			<img src="./鸟哥的 Linux 私房菜13 -- 正规表示法 (regular expression, RE) 与文件格式化处理_files/Spacer.gif" width="91" height="1" alt=""></td>
		<td>
			<img src="./鸟哥的 Linux 私房菜13 -- 正规表示法 (regular expression, RE) 与文件格式化处理_files/Spacer.gif" width="27" height="1" alt=""></td>
		<td>
			<img src="./鸟哥的 Linux 私房菜13 -- 正规表示法 (regular expression, RE) 与文件格式化处理_files/Spacer.gif" width="5" height="1" alt=""></td>
		<td>
			<img src="./鸟哥的 Linux 私房菜13 -- 正规表示法 (regular expression, RE) 与文件格式化处理_files/Spacer.gif" width="42" height="1" alt=""></td>
		<td>
			<img src="./鸟哥的 Linux 私房菜13 -- 正规表示法 (regular expression, RE) 与文件格式化处理_files/Spacer.gif" width="60" height="1" alt=""></td>
		<td>
			<img src="./鸟哥的 Linux 私房菜13 -- 正规表示法 (regular expression, RE) 与文件格式化处理_files/Spacer.gif" width="37" height="1" alt=""></td>
		<td>
			<img src="./鸟哥的 Linux 私房菜13 -- 正规表示法 (regular expression, RE) 与文件格式化处理_files/Spacer.gif" width="28" height="1" alt=""></td>
		<td>
			<img src="./鸟哥的 Linux 私房菜13 -- 正规表示法 (regular expression, RE) 与文件格式化处理_files/Spacer.gif" width="47" height="1" alt=""></td>
		<td>
			<img src="./鸟哥的 Linux 私房菜13 -- 正规表示法 (regular expression, RE) 与文件格式化处理_files/Spacer.gif" width="35" height="1" alt=""></td>
		<td>
			<img src="./鸟哥的 Linux 私房菜13 -- 正规表示法 (regular expression, RE) 与文件格式化处理_files/Spacer.gif" width="74" height="1" alt=""></td>
		<td>
			<img src="./鸟哥的 Linux 私房菜13 -- 正规表示法 (regular expression, RE) 与文件格式化处理_files/Spacer.gif" width="22" height="1" alt=""></td>
	</tr>
</tbody></table>
<!-- End ImageReady Slices -->
<script type="text/javascript">
<!--
var MenuBar1 = new Spry.Widget.MenuBar("MenuBar1", {imgDown:"SpryAssets/SpryMenuBarDownHover.gif", imgRight:"SpryAssets/SpryMenuBarRightHover.gif"});
var MenuBar2 = new Spry.Widget.MenuBar("MenuBar2", {imgDown:"SpryAssets/SpryMenuBarDownHover.gif", imgRight:"SpryAssets/SpryMenuBarRightHover.gif"});
//-->
</script>
</div>
<table summary="本文内容的排版" style="width: 898px;" border="0" cellpadding="0" cellspacing="0">
<tbody><tr><td style="width: 16px; height: 16px;">　</td>
    <td style="width: 866px; height: 16px;">　</td>
    <td style="width: 16px; height: 16px;">　</td></tr>
<tr><td style="width: 16px; font-size: 6px;">　</td>
    <td width="866">

<!-- 本文的档头部分 -->
<div style="text-align: center;">
    <a href="http://cn.linux.vbird.org/linux_basic/0330regularex.php">
    <span class="text_head0">第十二章、正规表示法与文件格式化处理</span></a><br>
</div>
    <div style="text-align: right;">
        <span class="text_history">最近升级日期：2009/08/26</span>
    </div>

<!-- 本文的档头部分 -->
<center><table class="head1" summary="排版：文章档头的说明"><tbody><tr><td class="head1">
	正规表示法 (Regular Expression, RE, 或称为常规表示法)是透过一些特殊字节的排列，用以『搜寻/取代/删除』一列或多列文字字串，
	简单的说，正规表示法就是用在字串的处理上面的一项『表示式』。正规表示法并不是一个工具程序，
	而是一个字串处理的标准依据，如果您想要以正规表示法的方式处理字串，就得要使用支持正规表示法的工具程序才行，
	这类的工具程序很多，例如 vi, sed, awk 等等。<br><br>

	正规表示法对於系统管理员来说实在是很重要！因为系统会产生很多的信息，这些信息有的重要有的仅是告知，
	此时，管理员可以透过正规表示法的功能来将重要信息撷取出来，并产生便於查阅的报表来简化管理流程。此外，
	很多的套装软件也都支持正规表示法的分析，例如邮件服务器的过滤机制(过滤垃圾信件)就是很重要的一个例子。
	所以，您最好要了解正规表示法的相关技能，在未来管理主机时，才能够更精简处理您的日常事务！<br><br>

	注：本章节使用者需要多加练习，因为目前很多的套件都是使用正规表示法来达成其『过滤、分析』的目的，
	为了未来主机管理的便利性，使用者至少要能看的懂正规表示法的意义！
</td></tr></tbody></table></center><br>

<!-- 本文的连结区部分 -->
<div class="block1">
<span class="text_h1">
1. <a href="http://cn.linux.vbird.org/linux_basic/0330regularex.php#before">前言： 什么是正规表示法</a><br>
	<span class="text_h2">
	　　1.1 <a href="http://cn.linux.vbird.org/linux_basic/0330regularex.php#before_1">什么是正规表示法</a><br>
	　　1.2 <a href="http://cn.linux.vbird.org/linux_basic/0330regularex.php#before_2">正规表示法对於系统管理员的用途</a><br>
	　　1.3 <a href="http://cn.linux.vbird.org/linux_basic/0330regularex.php#before_3">正规表示法的广泛用途</a><br>
	　　1.4 <a href="http://cn.linux.vbird.org/linux_basic/0330regularex.php#before_4">正规表示法与 Shell 在 Linux 当中的角色定位</a><br>
	　　1.5 <a href="http://cn.linux.vbird.org/linux_basic/0330regularex.php#before_5">延伸的正规表示法</a><br>
	</span>
2. <a href="http://cn.linux.vbird.org/linux_basic/0330regularex.php#basic_regexp">基础正规表示法</a><br>
	<span class="text_h2">
	　　2.1 <a href="http://cn.linux.vbird.org/linux_basic/0330regularex.php#lang">语系对正规表示法的影响</a><br>
	　　2.2 <a href="http://cn.linux.vbird.org/linux_basic/0330regularex.php#grep">grep 的一些进阶选项</a><br>
	　　2.3 <a href="http://cn.linux.vbird.org/linux_basic/0330regularex.php#basicre">基础正规表示法练习</a><br>
	　　2.4 <a href="http://cn.linux.vbird.org/linux_basic/0330regularex.php#basic_regexp_char">基础正规表示法字符汇整(characters)</a><br>
	　　2.5 <a href="http://cn.linux.vbird.org/linux_basic/0330regularex.php#sed">sed 工具</a>：
		<a href="http://cn.linux.vbird.org/linux_basic/0330regularex.php#sed_line_add">行的新增/删除</a>, <a href="http://cn.linux.vbird.org/linux_basic/0330regularex.php#sed_line_replace">行的取代/显示</a>,
		<a href="http://cn.linux.vbird.org/linux_basic/0330regularex.php#sed_replace">搜寻并取代</a>, <a href="http://cn.linux.vbird.org/linux_basic/0330regularex.php#sed_file">直接改档</a><br>
	</span>
3. <a href="http://cn.linux.vbird.org/linux_basic/0330regularex.php#extend">延伸正规表示法</a><br>
4. <a href="http://cn.linux.vbird.org/linux_basic/0330regularex.php#docs">文件的格式化与相关处理</a><br>
	<span class="text_h2">
	　　4.1 <a href="http://cn.linux.vbird.org/linux_basic/0330regularex.php#printf">printf： 格式化列印</a><br>
	　　4.2 <a href="http://cn.linux.vbird.org/linux_basic/0330regularex.php#awk">awk：好用的数据处理工具</a><br>
	　　4.3 <a href="http://cn.linux.vbird.org/linux_basic/0330regularex.php#doc_compare">文件比对工具：</a>, <a href="http://cn.linux.vbird.org/linux_basic/0330regularex.php#diff">diff</a>, <a href="http://cn.linux.vbird.org/linux_basic/0330regularex.php#cmp">cmp</a>, 
		<a href="http://cn.linux.vbird.org/linux_basic/0330regularex.php#patch">patch</a><br>
	　　4.4 <a href="http://cn.linux.vbird.org/linux_basic/0330regularex.php#pr">文件列印准备工具： pr</a><br>
	</span>

5. <a href="http://cn.linux.vbird.org/linux_basic/0330regularex.php#hint">重点回顾</a><br>
6. <a href="http://cn.linux.vbird.org/linux_basic/0330regularex.php#ex">本章习题</a><br>
7. <a href="http://cn.linux.vbird.org/linux_basic/0330regularex.php#reference">参考数据与延伸阅读</a><br>
<span class="text_h2">
8. <a href="http://phorum.vbird.org/viewtopic.php?t=23885" target="_blank">针对本文的建议：http://phorum.vbird.org/viewtopic.php?t=23885</a>
</span>
</span>
</div>

<!-- 本文的正式部分 -->
<hr>
<a name="before"></a><img src="./鸟哥的 Linux 私房菜13 -- 正规表示法 (regular expression, RE) 与文件格式化处理_files/logo.png" alt="大标题的图示" width="35" align="middle" height="34"><span class="text_h1">前言：什么是正规表示法</span><br>
<div class="block1">
	<p>约略了解了 Linux 的基本命令 (<a href="http://cn.linux.vbird.org/linux_basic/0320bash.php">BASH</a>) 并且熟悉了
	<a href="http://cn.linux.vbird.org/linux_basic/0310vi.php">vim</a> 之后，相信你对於敲击键盘的打字与命令下达比较不陌生了吧？
	接下来，底下要开始介绍一个很重要的观念，那就是所谓的『<span class="text_import2">正规表示法
	(Regular Expression)</span>』罗！<br><br></p>

	<a name="before_1"></a><hr><img src="./鸟哥的 Linux 私房菜13 -- 正规表示法 (regular expression, RE) 与文件格式化处理_files/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">什么是正规表示法</span><br>
	<div class="block2">
		<p>任何一个有经验的系统管理员，都会告诉你：『<span class="text_import2">正规表示法真是挺重要的</span>！』
		为什么很重要呢？因为日常生活就使用的到啊！举个例子来说，
		在你日常使用 <a href="http://cn.linux.vbird.org/linux_basic/0310vi.php">vim</a> 作文书处理或程序撰写时使用到的『搜寻/取代』等等的功能，
		这些举动要作的漂亮，就得要配合正规表示法来处理罗！</p>

		<p class="text_import2">简单的说，正规表示法就是处理字串的方法，他是以行为单位来进行字串的处理行为，
		正规表示法透过一些特殊符号的辅助，可以让使用者轻易的达到『搜寻/删除/取代』某特定字串的处理程序！</p>

		<p>举例来说，我只想找到 VBird(前面两个大写字节) 或 Vbird(仅有一个大写字节) 这个字样，但是不要其他的字串 (例如 VBIRD, vbird 
		等不需要)，该如何办理？如果在没有正规表示法的环境中(例如 MS word)，你或许就得要使用忽略大小写的办法，
		或者是分别以 VBird 及 Vbird 搜寻两遍。但是，忽略大小写可能会搜寻到 VBIRD/vbird/VbIrD 等等的不需要的字串而造成困扰。</p>

		<p>再举个系统常见的例子好了，假设你发现系统在启动的时候，老是会出现一个关於 mail 程序的错误，
		而启动过程的相关程序都是在 /etc/init.d/ 底下，也就是说，在该目录底下的某个文件内具有 mail 
		这个关键字，你想要将该文件捉出来进行查询修改的动作。此时你怎么找出来含有这个关键字的文件？
		你当然可以一个文件一个文件的开启，然后去搜寻 mail 这个关键字，只是.....该目录底下的文件可能不止 100 个说～
		如果了解正规表示法的相关技巧，那么只要一行命令就找出来啦：『grep 'mail' /etc/init.d/*』
		那个 grep 就是支持正规表示法的工具程序之一！如何～很简单吧！</p>

		<p>谈到这里就得要进一步说明了，<span class="text_import2">正规表示法基本上是一种『表示法』，
		只要工具程序支持这种表示法，那么该工具程序就可以用来作为正规表示法的字串处理之用。</span>
		例如 vi, grep, awk ,sed 等等工具，因为她们有支持正规表示法，
		所以，这些工具就可以使用正规表示法的特殊字节来进行字串的处理。但例如 cp, ls 等命令并未支持正规表示法，
		所以就只能使用 <a href="http://cn.linux.vbird.org/linux_basic/0320bash.php#settings_wildcard">bash 自己本身的万用字节</a>而已。</p>
	</div>

	<a name="before_2"></a><hr><img src="./鸟哥的 Linux 私房菜13 -- 正规表示法 (regular expression, RE) 与文件格式化处理_files/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">正规表示法对於系统管理员的用途</span><br>
	<div class="block2">
		<p>那么为何我需要学习正规表示法呢？对於一般使用者来说，由於使用到正规表示法的机会可能不怎么多，
		因此感受不到他的魅力，不过，对於身为系统管理员的你来说，<span class="text_import2">正规表示法则是一个『不可不学的好东西！</span>』
		怎么说呢？由於系统如果在繁忙的情况之下，每天产生的信息资讯会多到你无法想像的地步，
		而我们也都知道，系统的『<a href="http://cn.linux.vbird.org/linux_basic/0570syslog.php">错误信息登录文件 (第十九章)</a>』
		的内容记载了系统产生的所有信息，当然，这包含你的系统是否被『入侵』的记录数据。</p>

		<p>但是系统的数据量太大了，要身为系统管理员的你每天去看这么多的信息数据，
		从千百行的数据里面找出一行有问题的信息，呵呵～光是用肉眼去看，想不疯掉都很难！
		这个时候，我们就可以透过『正规表示法』的功能，将这些登录的资讯进行处理，
		仅取出『有问题』的资讯来进行分析，哈哈！如此一来，你的系统管理工作将会
		『快乐得不得了』啊！当然，正规表示法的优点还不止於此，等你有一定程度的了解之后，你会爱上他喔！</p>
	</div>

	<a name="before_3"></a><hr><img src="./鸟哥的 Linux 私房菜13 -- 正规表示法 (regular expression, RE) 与文件格式化处理_files/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">正规表示法的广泛用途</span><br>
	<div class="block2">
		<p>正规表示法除了可以让系统管理员管理主机更为便利之外，事实上，由於正规表示法强大的字串处理能力，
		目前一堆软件都支持正规表示法呢！最常见的就是『邮件服务器』啦！</p>

		<p>如果你留意网际网络上的消息，那么应该不能发现，目前造成网络大塞车的主因之一就是『垃圾/广告信件』了，
		而如果我们可以在服务器端，就将这些问题邮件剔除的话，用户端就会减少很多不必要的频宽耗损了。
		那么如何剔除广告信件呢？由於广告信件几乎都有一定的标题或者是内容，因此，
		只要每次有来信时，都先将来信的标题与内容进行特殊字串的比对，发现有不良信件就予以剔除！
		嘿！这个工作怎么达到啊？就使用正规表示法啊！目前两大邮件服务器软件 sendmail 与 postfix 
		以及支持邮件服务器的相关分析软件，都支持正规表示法的比对功能！</p>

		<p>当然还不止於此啦，很多的服务器软件都支持正规表示法呢！当然，
		虽然各家软件都支持他，不过，这些『字串』的比对还是需要系统管理员来加入比对守则的，
		所以啦！身为系统管理员的你，为了自身的工作以及用户端的需求，
		正规表示法实在是很需要也很值得学习的一项工具呢！</p>
	</div>

	<a name="before_4"></a><hr><img src="./鸟哥的 Linux 私房菜13 -- 正规表示法 (regular expression, RE) 与文件格式化处理_files/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">正规表示法与 Shell 在 Linux 当中的角色定位</span><br>
	<div class="block2">
		<p>说实在的，我们在学数学的时候，一个很重要、但是粉难的东西是一定要『背』的，
		那就是九九乘法表，背成功了之后，未来在数学应用的路途上，真是一帆风顺啊！
		这个九九乘法表我们在小学的时候几乎背了一整年才背下来，并不是这么好背的呢！
		但他却是基础当中的基础！你现在一定受惠相当的多呢 ^_^！</p>

		<p>而我们谈到的这个正规表示法，与前一章的 <a href="http://cn.linux.vbird.org/linux_basic/0320bash.php">BASH</a> 
		就有点像是数学的九九乘法表一样，是 Linux 基础当中的基础，虽然也是最难的部分，
		不过，如果学成了之后，一定是『大大的有帮助』的！这就好像是金庸小说里面的学武难关：任督二脉！
		打通任督二脉之后，武功立刻成倍成长！所以啦，
		不论是对於系统的认识与系统的管理部分，他都有很棒的辅助啊！请好好的学习这个基础吧！ ^_^</p>
	</div>

	<a name="before_5"></a><hr><img src="./鸟哥的 Linux 私房菜13 -- 正规表示法 (regular expression, RE) 与文件格式化处理_files/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">延伸的正规表示法</span><br>
	<div class="block2">
		<p>唔！正规表示法还有分喔？没错喔！<span class="text_import2">正规表示法的字串表示方式依照不同的严谨度而分为：
		基础正规表示法与延伸正规表示法</span>。延伸型正规表示法除了简单的一组字串处理之外，还可以作群组的字串处理，
		例如进行搜寻 VBird 或 netman 或 lman 的搜寻，注意，是『或(or)』而不是『和(and)』的处理，
		此时就需要延伸正规表示法的帮助啦！藉由特殊的『 ( 』与『 | 』等字节的协助，
		就能够达到这样的目的！不过，我们在这里主力仅是介绍最基础的基础正规表示法而已啦！好啦！清清脑门，咱们用功去罗！</p>
	</div>

	<div style="padding: 10pt 0pt;" align="right"><table width="90%"><tbody><tr><td><b>Tips:</b><br><span style="color: rgb(0, 144, 0);"><font size="-1">		有一点要向大家报告的，那就是：『<b>正规表示法与万用字节是完全不一样的东西！</b>』
		这很重要喔！因为『万用字节 (wildcard) 代表的是 bash 操作介面的一个功能』，但正规表示法则是一种字串处理的表示方式！
		这两者要分的很清楚才行喔！所以，学习本章，请将前一章 bash 的万用字节意义先忘掉吧！<br><br>
		老实说，鸟哥以前刚接触正规表示法时，老想著要将这两者归纳在一起，结果就是...错误认知一大堆～
		所以才会建议您学习本章先忘记万用字节再来学习吧！
	</font></span></td><td><img src="./鸟哥的 Linux 私房菜13 -- 正规表示法 (regular expression, RE) 与文件格式化处理_files/vbird_face.gif" alt="鸟哥的图示" title="鸟哥的图示"></td></tr></tbody></table></div></div>

<hr><a name="basic_regexp"></a><img src="./鸟哥的 Linux 私房菜13 -- 正规表示法 (regular expression, RE) 与文件格式化处理_files/logo.png" alt="大标题的图示" width="35" align="middle" height="34"><span class="text_h1">基础正规表示法</span><br>
<div class="block1">
	<p>既然正规表示法是处理字串的一种表示方式，那么对字节排序有影响的语系数据就会对正规表示法的结果有影响！
	此外，正规表示法也需要支持工具程序来辅助才行！所以，我们这里就先介绍一个最简单的字串撷取功能的工具程序，那就是 grep 罗！
	前一章已经介绍过 grep 的相关选项与参数，本章著重在较进阶的 grep 选项说明罗！
	介绍完 grep 的功能之后，就进入正规表示法的特殊字符的处理能力了。<br><br></p>

	<hr><a name="lang"></a><img src="./鸟哥的 Linux 私房菜13 -- 正规表示法 (regular expression, RE) 与文件格式化处理_files/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">语系对正规表示法的影响</span><br>
	<div class="block2">
		<p>为什么语系的数据会影响到正规表示法的输出结果呢？我们在<a href="http://cn.linux.vbird.org/linux_basic/0105computers.php#data_word">第零章计算机概论的文字编码系统</a>里面谈到，文件其实记录的仅有 0 与
		1，我们看到的字节文字与数字都是透过编码表转换来的。由於不同语系的编码数据并不相同，所以就会造成数据撷取结果的差异了。
		举例来说，在英文大小写的编码顺序中，zh_TW.big5 及 C 这两种语系的输出结果分别如下：</p>

		<ul class="text_import2" style="font-family: &#39;细明体&#39;;">
		<li>LANG=C &nbsp; &nbsp; 时：0 1 2 3 4 ... A B C D ... Z a b c d ...z</li>
		<li>LANG=zh_TW 时：0 1 2 3 4 ... a A b B c C d D ... z Z</li>
		</ul>
 
		<p>上面的顺序是编码的顺序，我们可以很清楚的发现这两种语系明显就是不一样！如果你想要撷取大写字节而使用 [A-Z] 时，
		会发现 LANG=C 确实可以仅捉到大写字节 (因为是连续的) ，但是如果 LANG=zh_TW.big5 时，就会发现到，
		连同小写的 b-z 也会被撷取出来！因为就编码的顺序来看， big5 语系可以撷取到『 A b B c C ... z Z 』这一堆字节哩！
		所以，<span class="text_import2">使用正规表示法时，需要特别留意当时环境的语系为何，
		否则可能会发现与别人不相同的撷取结果</span>喔！</p>

		<p>由於一般我们在练习正规表示法时，使用的是兼容於 POSIX 的标准，因此就使用『 C 』这个语系(<a href="http://cn.linux.vbird.org/linux_basic/0330regularex.php#ps1">注1</a>)！
		因此，<span class="text_import2">底下的很多练习都是使用『 LANG=C 』这个语系数据来进行</span>的喔！
		另外，为了要避免这样编码所造成的英文与数字的撷取问题，因此有些特殊的符号我们得要了解一下的！
		这些符号主要有底下这些意义：(<a href="http://cn.linux.vbird.org/linux_basic/0330regularex.php#ps1">注1</a>)</p>

<table class="fontwidth" bgcolor="lightyellow" border="1" cellpadding="3" cellspacing="0" width="95%">
<tbody><tr style="text-align: center;" bgcolor="#182448"><td><font color="#FFFFFF">特殊符号</font></td><td><font color="#FFFFFF">代表意义</font></td></tr>
<tr><td>[:alnum:]</td><td>代表英文大小写字节及数字，亦即 0-9, A-Z, a-z</td></tr>
<tr><td>[:alpha:]</td><td>代表任何英文大小写字节，亦即 A-Z, a-z</td></tr>
<tr><td>[:blank:]</td><td>代表空白键与 [Tab] 按键两者</td></tr>
<tr><td>[:cntrl:]</td><td>代表键盘上面的控制按键，亦即包括 CR, LF, Tab, Del.. 等等</td></tr>
<tr><td>[:digit:]</td><td>代表数字而已，亦即 0-9</td></tr>
<tr><td>[:graph:]</td><td>除了空白字节 (空白键与 [Tab] 按键) 外的其他所有按键</td></tr>
<tr><td>[:lower:]</td><td>代表小写字节，亦即 a-z</td></tr>
<tr><td>[:print:]</td><td>代表任何可以被列印出来的字节</td></tr>
<tr><td>[:punct:]</td><td>代表标点符号 (punctuation symbol)，亦即：" ' ? ! ; : # $...</td></tr>
<tr><td>[:upper:]</td><td>代表大写字节，亦即 A-Z</td></tr>
<tr><td>[:space:]</td><td>任何会产生空白的字节，包括空白键, [Tab], CR 等等</td></tr>
<tr><td>[:xdigit:]</td><td>代表 16 进位的数字类型，因此包括： 0-9, A-F, a-f 的数字与字节</td></tr>
</tbody></table>

		<p>尤其上表中的<span class="text_import2">[:alnum:], [:alpha:], [:upper:], [:lower:], [:digit:]</span>
		这几个一定要知道代表什么意思，因为他要比 a-z 或 A-Z 的用途要确定的很！好了，底下就让我们开始来玩玩进阶版的 grep 吧！</p>
	</div>

	<hr><a name="grep"></a><img src="./鸟哥的 Linux 私房菜13 -- 正规表示法 (regular expression, RE) 与文件格式化处理_files/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">grep 的一些进阶选项</span><br>
	<div class="block2">
		<p>我们在<a href="http://cn.linux.vbird.org/linux_basic/0320bash.php#grep">第十一章 BASH 里面的 grep </a>谈论过一些基础用法，
		但其实 grep 还有不少的进阶用法喔！底下我们仅列出较进阶的 grep 选项与参数给大家参考，
		<a href="http://cn.linux.vbird.org/linux_basic/0320bash.php#grep">基础的 grep 用法</a>请参考前一章的说明罗！</p>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">grep [-A] [-B] [--color=auto] '搜寻字串' filename</span>
<span class="term_say">选项与参数：
-A ：后面可加数字，为 after 的意思，除了列出该行外，后续的 n 行也列出来；
-B ：后面可加数字，为 befer 的意思，除了列出该行外，前面的 n 行也列出来；
--color=auto 可将正确的那个撷取数据列出颜色</span>

<span class="term_hd">范例一：用 dmesg 列出核心信息，再以 grep 找出内含 eth 那行</span>
[root@www ~]# <span class="term_command">dmesg | grep 'eth'</span>
eth0: RealTek RTL8139 at 0xee846000, 00:90:cc:a6:34:84, IRQ 10
eth0:  Identified 8139 chip type 'RTL-8139C'
eth0: link up, 100Mbps, full-duplex, lpa 0xC5E1
eth0: no IPv6 routers present
<span class="term_say"># dmesg 可列出核心产生的信息！透过 grep 来撷取网络卡相关资讯 (eth) ，
# 就可发现如上资讯。不过没有行号与特殊颜色显示！看看下个范例吧！</span>

<span class="term_hd">范例二：承上题，要将捉到的关键字显色，且加上行号来表示：</span>
[root@www ~]# <span class="term_command">dmesg | grep -n --color=auto 'eth'</span>
247:<span class="term_write">eth</span>0: RealTek RTL8139 at 0xee846000, 00:90:cc:a6:34:84, IRQ 10
248:<span class="term_write">eth</span>0:  Identified 8139 chip type 'RTL-8139C'
294:<span class="term_write">eth</span>0: link up, 100Mbps, full-duplex, lpa 0xC5E1
305:<span class="term_write">eth</span>0: no IPv6 routers present
<span class="term_say"># 你会发现除了 eth 会有特殊颜色来表示之外，最前面还有行号喔！</span>

<span class="term_hd">范例三：承上题，在关键字所在行的前两行与后三行也一起捉出来显示</span>
[root@www ~]# <span class="term_command">dmesg | grep -n -A3 -B2 --color=auto 'eth'</span>
245-PCI: setting IRQ 10 as level-triggered
246-ACPI: PCI Interrupt 0000:00:0e.0[A] -&gt; Link [LNKB] ...
247:<span class="term_write">eth</span>0: RealTek RTL8139 at 0xee846000, 00:90:cc:a6:34:84, IRQ 10
248:<span class="term_write">eth</span>0:  Identified 8139 chip type 'RTL-8139C'
249-input: PC Speaker as /class/input/input2
250-ACPI: PCI Interrupt 0000:00:01.4[B] -&gt; Link [LNKB] ...
251-hdb: ATAPI 48X DVD-ROM DVD-R-RAM CD-R/RW drive, 2048kB Cache, UDMA(66)
<span class="term_say"># 如上所示，你会发现关键字 247 所在的前两行及 248 后三行也都被显示出来！
# 这样可以让你将关键字前后数据捉出来进行分析啦！</span>
</pre></td></tr></tbody></table>

		<p>grep 是一个很常见也很常用的命令，他最重要的功能就是进行字串数据的比对，然后将符合使用者需求的字串列印出来。
		需要说明的是『<span class="text_import2">grep 在数据中查寻一个字串时，是以 "整行" 
		为单位来进行数据的撷取的！</span>』也就是说，假如一个文件内有 10 
		行，其中有两行具有你所搜寻的字串，则将那两行显示在萤幕上，其他的就丢弃了！</p>

		<p>在关键字的显示方面，grep 可以使用 --color=auto 来将关键字部分使用颜色显示。
		这可是个很不错的功能啊！但是如果每次使用 grep 都得要自行加上 --color=auto 又显的很麻烦～
		此时那个好用的 alias 就得来处理一下啦！你可以在 ~/.bashrc 内加上这行：『<span class="text_import2">alias
		grep='grep --color=auto'</span>』再以『 source ~/.bashrc 』来立即生效即可喔！
		这样每次运行 grep 他都会自动帮你加上颜色显示啦！</p>
	</div>

	<hr><a name="basicre"></a><img src="./鸟哥的 Linux 私房菜13 -- 正规表示法 (regular expression, RE) 与文件格式化处理_files/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">基础正规表示法练习</span><br>
	<div class="block2">
		<p>要了解正规表示法最简单的方法就是由实际练习去感受啦！所以在汇整正规表示法特殊符号前，
		我们先以底下这个文件的内容来进行正规表示法的理解吧！先说明一下，底下的练习大前提是：</p>
		<ul class="text_import2">
		<li>语系已经使用『 export LANG=C 』的配置值；</li>
		<li>grep 已经使用 alias 配置成为『 grep --color=auto 』</li>
		</ul>

		<p>至於本章的练习用文件请由底下的连结来下载。需要特别注意的是，底下这个文件是鸟哥在 MS Windows 系统下编辑的，
		并且已经特殊处理过，因此，他虽然是纯文字档，但是内含一些 Windows 
		系统下的软件常常自行加入的一些特殊字节，例如断行字节 (^M) 就是一例！
		所以，你可以直接将底下的文字以 vi 储存成 regular_express.txt 这个文件，
		不过，还是比较建议直接点底下的连结：</p>
		<blockquote style="font-family: &#39;细明体&#39;;">
		<a href="http://cn.linux.vbird.org/linux_basic/0330regularex/regular_express.txt">http://cn.linux.vbird.org/linux_basic/0330regularex/regular_express.txt</a></blockquote>

		<p>如果你的 Linux 可以直接连上 Internet 的话，那么使用如下的命令来捉取即可：</p>

		<blockquote>
		wget http://cn.linux.vbird.org/linux_basic/0330regularex/regular_express.txt
		</blockquote>

		<p>至於这个文件的内容如下：</p>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">vi regular_express.txt</span>
"Open Source" is a good mechanism to develop programs.
apple is my favorite food.
Football game is not use feet only.
this dress doesn't fit me.
However, this dress is about $ 3183 dollars.^M
GNU is free air not free beer.^M
Her hair is very beauty.^M
I can't finish the test.^M
Oh! The soup taste good.^M
motorcycle is cheap than car.
This window is clear.
the symbol '*' is represented as start.
Oh!     My god!
The gd software is a library for drafting programs.^M
You are the best is mean you are the no. 1.
The world &lt;Happy&gt; is the same with "glad".
I like dog.
google is the best tools for search keyword.
goooooogle yes!
go! go! Let's go.
# I am VBird

</pre></td></tr></tbody></table>

		<p>这文件共有 22  行，最底下一行为空白行！现在开始我们一个案例一个案例的来介绍吧！<br><br></p>

		<hr><ul class="list1"><li class="text_import1">例题一、搜寻特定字串</li></ul>

		<p>搜寻特定字串很简单吧？假设我们要从刚刚的文件当中取得 the 这个特定字串，最简单的方式就是这样：</p>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">grep -n 'the' regular_express.txt</span>
8:I can't finish <span class="term_write">the</span> test.
12:<span class="term_write">the</span> symbol '*' is represented as start.
15:You are <span class="term_write">the</span> best is mean you are <span class="term_write">the</span> no. 1.
16:The world &lt;Happy&gt; is <span class="term_write">the</span> same with "glad".
18:google is <span class="term_write">the</span> best tools for search keyword.
</pre></td></tr></tbody></table>

		<p>那如果想要『<span class="text_import2">反向选择</span>』呢？也就是说，当该行没有 
		'the' 这个字串时才显示在萤幕上，那就直接使用：</p>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">grep -vn 'the' regular_express.txt</span>
</pre></td></tr></tbody></table>

		<p>你会发现，萤幕上出现的行列为除了 8,12,15,16,18 五行之外的其他行列！
		接下来，如果你想要取得不论大小写的 the 这个字串，则：</p>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">grep -in 'the' regular_express.txt</span>
8:I can't finish <span class="term_write">the</span> test.
9:Oh! <span class="term_write">The</span> soup taste good.
12:<span class="term_write">the</span> symbol '*' is represented as start.
14:<span class="term_write">The</span> gd software is a library for drafting programs.
15:You are <span class="term_write">the</span> best is mean you are <span class="term_write">the</span> no. 1.
16:<span class="term_write">The</span> world &lt;Happy&gt; is <span class="term_write">the</span> same with "glad".
18:google is <span class="term_write">the</span> best tools for search keyword.
</pre></td></tr></tbody></table>

		<p>除了多两行 (9, 14行) 之外，第 16 行也多了一个 The 的关键字被撷取到喔！<br><br></p>

		<hr><ul class="list1"><li class="text_import1">例题二、利用中括号 [] 来搜寻集合字节</li></ul>

		<p>如果我想要搜寻 test 或 taste 这两个单字时，可以发现到，其实她们有共通的 't?st'
		存在～这个时候，我可以这样来搜寻：</p>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">grep -n 't[ae]st' regular_express.txt</span>
8:I can't finish the <span class="term_write">test</span>.
9:Oh! The soup <span class="term_write">tast</span>e good.
</pre></td></tr></tbody></table>

		<p>了解了吧？<span class="text_import2">其实 [] 里面不论有几个字节，他都谨代表某『一个』字节</span>，
		所以，上面的例子说明了，我需要的字串是『tast』或『test』两个字串而已！
		而如果想要搜寻到有 oo 的字节时，则使用：</p>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">grep -n 'oo' regular_express.txt</span>
1:"Open Source" is a g<span class="term_write">oo</span>d mechanism to develop programs.
2:apple is my favorite f<span class="term_write">oo</span>d.
3:F<span class="term_write">oo</span>tball game is not use feet only.
9:Oh! The soup taste g<span class="term_write">oo</span>d.
18:g<span class="term_write">oo</span>gle is the best t<span class="term_write">oo</span>ls for search keyword.
19:g<span class="term_write">oooooo</span>gle yes!
</pre></td></tr></tbody></table>

		<p>但是，如果我不想要 oo 前面有 g 的话呢？此时，可以利用在集合字节的反向选择 [^] 来达成：</p>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">grep -n '[^g]oo' regular_express.txt</span>
2:apple is my favorite <span class="term_write">foo</span>d.
3:<span class="term_write">Foo</span>tball game is not use feet only.
18:google is the best <span class="term_write">too</span>ls for search keyword.
19:g<span class="term_write">oooooo</span>gle yes!
</pre></td></tr></tbody></table>

		<p>意思就是说，我需要的是 oo ，但是 oo 前面不能是 g 就是了！仔细比较上面两个表格，你会发现，第 
		1,9 行不见了，因为 oo 前面出现了 g 所致！第 2,3 行没有疑问，因为 foo 与 Foo 均可被接受！但是第 18 
		行明明有 google 的 goo 啊～别忘记了，因为该行后面出现了 tool 的 too 啊！所以该行也被列出来～
		也就是说， 18 行里面虽然出现了我们所不要的项目 (goo) 但是由於有需要的项目 (too) ，
		因此，是符合字串搜寻的喔！</p>

		<p>至於第 19 行，同样的，因为 goooooogle 里面的 oo 前面可能是 o ，例如：
		go(ooo)oogle ，所以，这一行也是符合需求的！</p>

		<p>再来，假设我 oo 前面不想要有小写字节，所以，我可以这样写 [^abcd....z]oo ，
		但是这样似乎不怎么方便，由於小写字节的 ASCII 上编码的顺序是连续的，
		因此，我们可以将之简化为底下这样：</p>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">grep -n '[^a-z]oo' regular_express.txt</span>
3:<span class="term_write">Foo</span>tball game is not use feet only.
</pre></td></tr></tbody></table>

		<p>也就是说，当我们在一组集合字节中，如果该字节组是连续的，例如大写英文/小写英文/数字等等，
		就可以使用[a-z],[A-Z],[0-9]等方式来书写，那么如果我们的要求字串是数字与英文呢？
		呵呵！就将他全部写在一起，变成：[a-zA-Z0-9]。例如，我们要取得有数字的那一行，就这样：</p>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">grep -n '[0-9]' regular_express.txt</span>
5:However, this dress is about $ <span class="term_write">3183</span> dollars.
15:You are the best is mean you are the no. <span class="term_write">1</span>.
</pre></td></tr></tbody></table>

		<p>但由於考虑到语系对於编码顺序的影响，因此除了连续编码使用减号『 - 』之外，
		你也可以使用如下的方法来取得前面两个测试的结果：</p>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">grep -n '[^[:lower:]]oo' regular_express.txt</span>
<span class="term_say"># 那个 [:lower:] 代表的就是 a-z 的意思！请参考前两小节的说明表格</span>

[root@www ~]# <span class="term_command">grep -n '[[:digit:]]' regular_express.txt</span>
</pre></td></tr></tbody></table>

		<p>这样对於 [] 以及 [^] 以及 [] 当中的 - ，还有关於前面表格提到的特殊关键字有了解了吗？^_^！<br><br></p>

		<hr><ul class="list1"><li class="text_import1">例题三、行首与行尾字节 ^ $</li></ul>

		<p>我们在例题一当中，可以查询到一行字串里面有 the 的，那如果我想要让 the 只在行首列出呢？
		这个时候就得要使用定位字节了！我们可以这样做：</p>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">grep -n '^the' regular_express.txt</span>
12:<span class="term_write">the</span> symbol '*' is represented as start.
</pre></td></tr></tbody></table>

		<p>此时，就只剩下第 12 行，因为只有第 12 行的行首是 the 开头啊～此外，
		如果我想要开头是小写字节的那一行就列出呢？可以这样：</p>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">grep -n '^[a-z]' regular_express.txt</span>
2:<span class="term_write">apple</span> is my favorite food.
4:<span class="term_write">this</span> dress doesn't fit me.
10:<span class="term_write">motorcycle</span> is cheap than car.
12:<span class="term_write">the</span> symbol '*' is represented as start.
18:<span class="term_write">google</span> is the best tools for search keyword.
19:<span class="term_write">goooooogle</span> yes!
20:<span class="term_write">go</span>! go! Let's go.
</pre></td></tr></tbody></table>

		<p>你可以发现我们可以捉到第一个字节都不是大写的！只不过 grep 列出的关键字部分不只有第一个字节，
		grep 是列出一整个字 (word) 说！同样的，上面的命令也可以用如下的方式来取代的：</p>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">grep -n '^[[:lower:]]' regular_express.txt</span>
</pre></td></tr></tbody></table>

		<p>好！那如果我不想要开头是英文字母，则可以是这样：</p>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">grep -n '^[^a-zA-Z]' regular_express.txt</span>
1:<span class="term_write">"</span>Open Source" is a good mechanism to develop programs.
21:<span class="term_write">#</span> I am VBird
<span class="term_say"># 命令也可以是： grep -n '^[^[:alpha:]]' regular_express.txt</span>
</pre></td></tr></tbody></table>

		<p>注意到了吧？<span class="text_import2">那个 ^ 符号，在字节集合符号(括号[])之内与之外是不同的！
		在 [] 内代表『反向选择』，在 [] 之外则代表定位在行首的意义</span>！要分清楚喔！
		反过来思考，那如果我想要找出来，行尾结束为小数点 (.) 的那一行，该如何处理：</p>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">grep -n '\.$' regular_express.txt</span>
1:"Open Source" is a good mechanism to develop programs<span class="term_write">.</span>
2:apple is my favorite food<span class="term_write">.</span>
3:Football game is not use feet only<span class="term_write">.</span>
4:this dress doesn't fit me<span class="term_write">.</span>
10:motorcycle is cheap than car<span class="term_write">.</span>
11:This window is clear<span class="term_write">.</span>
12:the symbol '*' is represented as start<span class="term_write">.</span>
15:You are the best is mean you are the no. 1<span class="term_write">.</span>
16:The world &lt;Happy&gt; is the same with "glad"<span class="term_write">.</span>
17:I like dog<span class="term_write">.</span>
18:google is the best tools for search keyword<span class="term_write">.</span>
20:go! go! Let's go<span class="term_write">.</span>
</pre></td></tr></tbody></table>

		<p>特别注意到，因为小数点具有其他意义(底下会介绍)，所以必须要使用跳脱字节(\)来加以解除其特殊意义！
		不过，你或许会觉得奇怪，但是第 5~9 行最后面也是 . 啊～怎么无法列印出来？
		这里就牵涉到 Windows 平台的软件对於断行字节的判断问题了！我们使用 cat -A 将第五行拿出来看，
		你会发现：</p>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">cat -An regular_express.txt | head -n 10 | tail -n 6</span>
     5  However, this dress is about $ 3183 dollars.<span class="term_write">^M</span>$
     6  GNU is free air not free beer.<span class="term_write">^M</span>$
     7  Her hair is very beauty.<span class="term_write">^M</span>$
     8  I can't finish the test.<span class="term_write">^M</span>$
     9  Oh! The soup taste good.<span class="term_write">^M</span>$
    10  motorcycle is cheap than car.$
</pre></td></tr></tbody></table>

		<p>我们在<a href="http://cn.linux.vbird.org/linux_basic/0310vi.php#tips_dos">第十章内谈到过断行字节</a>在 Linux 与 Windows 上的差异，
		在上面的表格中我们可以发现 5~9 行为 Windows 的断行字节 (^M$) ，而正常的 Linux 应该仅有第 10 行显示的那样 ($)
		。所以罗，那个 . 自然就不是紧接在 $ 之前喔！也就捉不到 5~9 行了！这样可以了解 ^ 与 $ 的意义吗？
		好了，先不要看底下的解答，自己想一想，那么如果我想要找出来，哪一行是『空白行』，
		也就是说，该行并没有输入任何数据，该如何搜寻？</p>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">grep -n '^$' regular_express.txt</span>
22:
</pre></td></tr></tbody></table>

		<p>因为只有行首跟行尾 (^$)，所以，这样就可以找出空白行啦！再来，假设你已经知道在一个程序脚本
		(shell script) 或者是配置档当中，空白行与开头为 # 的那一行是注解，因此如果你要将数据列出给别人参考时，
		可以将这些数据省略掉以节省保贵的纸张，那么你可以怎么作呢？
		我们以 /etc/syslog.conf 这个文件来作范例，你可以自行参考一下输出的结果：</p>

<a name="blank_line"></a>
<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">cat -n /etc/syslog.conf</span>
<span class="term_say"># 在 CentOS 中，结果可以发现有 33 行的输出，很多空白行与 # 开头</span>

[root@www ~]# <span class="term_command">grep -v '^$' /etc/syslog.conf | grep -v '^#'</span>
<span class="term_say"># 结果仅有 10 行，其中第一个『 -v '^$' 』代表『不要空白行』，
# 第二个『 -v '^#' 』代表『不要开头是 # 的那行』喔！</span>
</pre></td></tr></tbody></table>

		<p>是否节省很多版面啊？<br><br></p>

		<hr><ul class="list1"><li class="text_import1">例题四、任意一个字节 . 与重复字节 *</li></ul>

		<p>在<a href="http://cn.linux.vbird.org/linux_basic/0320bash.php">第十一章 bash</a> 当中，我们知道<a href="http://cn.linux.vbird.org/linux_basic/0320bash.php#settings_wildcard">万用字节 *</a> 可以用来代表任意(0或多个)字节，
		但是<span class="text_import2">正规表示法并不是万用字节</span>，两者之间是不相同的！
		至於正规表示法当中的『 . 』则代表『绝对有一个任意字节』的意思！这两个符号在正规表示法的意义如下：</p>

		<ul class="text_import2" style="font-family: &#39;细明体&#39;;">
		<li>. (小数点)：代表『一定有一个任意字节』的意思；</li>
		<li><a name="20100416"></a>* (星星号)：代表『重复前一个字节， 0 到无穷多次』的意思，为组合形态</li>
		</ul>

		<p>这样讲不好懂，我们直接做个练习吧！假设我需要找出 g??d 的字串，亦即共有四个字节，
		起头是 g 而结束是 d ，我可以这样做：</p>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">grep -n 'g..d' regular_express.txt</span>
1:"Open Source" is a <span class="term_write">good</span> mechanism to develop programs.
9:Oh! The soup taste <span class="term_write">good</span>.
16:The world &lt;Happy&gt; is the same with "<span class="term_write">glad</span>".
</pre></td></tr></tbody></table>

		<p>因为强调 g 与 d 之间一定要存在两个字节，因此，第 13 行的 god 与第 14 行的 gd 
		就不会被列出来啦！再来，如果我想要列出有 oo, ooo, oooo 等等的数据，
		也就是说，至少要有两个(含) o 以上，该如何是好？是 o* 还是 oo* 还是 ooo* 呢？
		虽然你可以试看看结果， 不过结果太占版面了 @_@ ，所以，我这里就直接说明。</p>

		<p>因为 * 代表的是『<span class="text_import2">重复 0 个或多个前面的 RE 字符</span>』的意义，
		因此，<span class="text_import2">『o*』代表的是：『拥有空字节或一个 o 以上的字节』</span>，
		特别注意，因为允许空字节(就是有没有字节都可以的意思)，因此，『 <span class="text_import2">
		grep -n 'o*' regular_express.txt</span> 』将会把所有的数据都列印出来萤幕上！</p>

		<p>那如果是『oo*』呢？则第一个 o 肯定必须要存在，第二个 o 则是可有可无的多个 o ，
		所以，凡是含有 o, oo, ooo, oooo 等等，都可以被列出来～</p>

		<p>同理，当我们需要『至少两个 o 以上的字串』时，就需要 ooo* ，亦即是：</p>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">grep -n 'ooo*' regular_express.txt</span>
1:"Open Source" is a g<span class="term_write">oo</span>d mechanism to develop programs.
2:apple is my favorite f<span class="term_write">oo</span>d.
3:F<span class="term_write">oo</span>tball game is not use feet only.
9:Oh! The soup taste g<span class="term_write">oo</span>d.
18:g<span class="term_write">oo</span>gle is the best t<span class="term_write">oo</span>ls for search keyword.
19:g<span class="term_write">oooooo</span>gle yes!
</pre></td></tr></tbody></table>

		<p>这样理解 * 的意义了吗？好了，现在出个练习，如果我想要字串开头与结尾都是 g，但是两个 g 
		之间仅能存在至少一个 o ，亦即是 gog, goog, gooog.... 等等，那该如何？</p>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">grep -n 'goo*g' regular_express.txt</span>
18:<span class="term_write">goog</span>le is the best tools for search keyword.
19:<span class="term_write">goooooog</span>le yes!
</pre></td></tr></tbody></table>

		<p>如此了解了吗？再来一题，如果我想要找出 g 开头与 g 结尾的字串，当中的字节可有可无，那该如何是好？是『g*g』吗？</p>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">grep -n 'g*g' regular_express.txt</span>
1:"Open Source" is a <span class="term_write">g</span>ood mechanism to develop pro<span class="term_write">g</span>rams.
3:Football <span class="term_write">g</span>ame is not use feet only.
9:Oh! The soup taste <span class="term_write">g</span>ood.
13:Oh!  My <span class="term_write">g</span>od!
14:The <span class="term_write">g</span>d software is a library for draftin<span class="term_write">g</span> pro<span class="term_write">g</span>rams.
16:The world &lt;Happy&gt; is the same with "<span class="term_write">g</span>lad".
17:I like do<span class="term_write">g</span>.
18:<span class="term_write">g</span>oo<span class="term_write">g</span>le is the best tools for search keyword.
19:<span class="term_write">g</span>oooooo<span class="term_write">g</span>le yes!
20:<span class="term_write">g</span>o! <span class="term_write">g</span>o! Let's <span class="term_write">g</span>o.
</pre></td></tr></tbody></table>

		<p>但测试的结果竟然出现这么多行？太诡异了吧？其实一点也不诡异，因为 g*g 里面的 g* 代表『空字节或一个以上的 g』
		在加上后面的 g ，因此，整个 RE 的内容就是 g, gg, ggg, gggg ，
		因此，只要该行当中拥有一个以上的 g 就符合所需了！</p>

		<p>那该如何得到我们的 g....g 的需求呢？呵呵！就利用任意一个字节『.』啊！
		亦即是：『g.*g』的作法，因为 * 可以是 0 或多个重复前面的字符，而 . 是任意字节，所以：
		『<span class="text_import2">.* 就代表零个或多个任意字节</span>』的意思啦！</p>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">grep -n 'g.*g' regular_express.txt</span>
1:"Open Source" is a <span class="term_write">good mechanism to develop prog</span>rams.
14:The <span class="term_write">gd software is a library for drafting prog</span>rams.
18:<span class="term_write">goog</span>le is the best tools for search keyword.
19:<span class="term_write">goooooog</span>le yes!
20:<span class="term_write">go! go! Let's g</span>o.
</pre></td></tr></tbody></table>

		<p>因为是代表 g 开头与 g 结尾，中间任意字节均可接受，所以，第 1, 14, 20 行是可接受的喔！
		这个 .* 的 RE 表示任意字节是很常见的，希望大家能够理解并且熟悉！
		再出一题，如果我想要找出『任意数字』的行列呢？因为仅有数字，所以就成为：</p>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">grep -n '[0-9][0-9]*' regular_express.txt</span>
5:However, this dress is about $ <span class="term_write">3183</span> dollars.
15:You are the best is mean you are the no. <span class="term_write">1</span>.
</pre></td></tr></tbody></table>

		<p>虽然使用 grep -n '[0-9]' regular_express.txt 也可以得到相同的结果，
		但鸟哥希望大家能够理解上面命令当中 RE 表示法的意义才好！<br><br></p>

		<hr><ul class="list1"><li class="text_import1">例题五、限定连续 RE 字符范围 {}</li></ul>

		<p>在上个例题当中，我们可以利用 . 与 RE 字符及 * 来配置 0 个到无限多个重复字节，
		那如果我想要限制一个范围区间内的重复字节数呢？举例来说，我想要找出两个到五个 o 
		的连续字串，该如何作？这时候就得要使用到限定范围的字符 {} 了。
		但<span class="text_import2">因为 { 与 } 的符号在 shell 是有特殊意义的，因此，
		我们必须要使用跳脱字符 \ 来让他失去特殊意义才行。</span>
		至於 {} 的语法是这样的，假设我要找到两个 o 的字串，可以是：</p>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">grep -n 'o\{2\}' regular_express.txt</span>
1:"Open Source" is a g<span class="term_write">oo</span>d mechanism to develop programs.
2:apple is my favorite f<span class="term_write">oo</span>d.
3:F<span class="term_write">oo</span>tball game is not use feet only.
9:Oh! The soup taste g<span class="term_write">oo</span>d.
18:g<span class="term_write">oo</span>gle is the best t<span class="term_write">oo</span>ls for search keyword.
19:g<span class="term_write">oooooo</span>gle yes!
</pre></td></tr></tbody></table>

		<p>这样看似乎与 ooo* 的字符没有什么差异啊？因为第 19 行有多个 o 依旧也出现了！
		好，那么换个搜寻的字串，假设我们要找出 g 后面接 2 到 5 个 o ，然后再接一个 g 的字串，他会是这样：</p>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">grep -n 'go\{2,5\}g' regular_express.txt</span>
18:<span class="term_write">goog</span>le is the best tools for search keyword.
</pre></td></tr></tbody></table>

		<p>嗯！很好！第 19 行终於没有被取用了(因为 19 行有 6 个 o 啊！)。
		那么，如果我想要的是 2 个 o 以上的 goooo....g 呢？除了可以是 gooo*g ，也可以是：</p>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">grep -n 'go\{2,\}g' regular_express.txt</span>
18:<span class="term_write">goog</span>le is the best tools for search keyword.
19:<span class="term_write">goooooog</span>le yes!
</pre></td></tr></tbody></table>

		<p>呵呵！就可以找出来啦～</p>
	</div>

	<hr><a name="basic_regexp_char"></a><img src="./鸟哥的 Linux 私房菜13 -- 正规表示法 (regular expression, RE) 与文件格式化处理_files/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">基础正规表示法字符汇整
	(characters)</span><br>
	<div class="block2">
		<p>经过了上面的几个简单的范例，我们可以将基础的正规表示法特殊字符汇整如下：</p>

<table bgcolor="lightyellow" border="1" cellpadding="3" cellspacing="0" width="95%">
<tbody><tr style="text-align: center;" bgcolor="#182448"><td width="15%"><font color="#FFFFFF">RE 字符</font></td><td><font color="#FFFFFF">意义与范例</font></td></tr>
<tr class="fontwidth"><td align="center">^word</td><td><u>意义：待搜寻的字串(word)在行首！</u><br>
	范例：搜寻行首为 # 开始的那一行，并列出行号
	<blockquote style="padding: 0pt 0pt 0pt 25px; margin: 0pt; color: rgb(0, 0, 136); font-weight: bolder;">
	grep -n '^#' regular_express.txt</blockquote></td></tr>
<tr class="fontwidth"><td align="center">word$</td><td><u>意义：待搜寻的字串(word)在行尾！</u><br>
	范例：将行尾为 ! 的那一行列印出来，并列出行号
	<blockquote style="padding: 0pt 0pt 0pt 25px; margin: 0pt; color: rgb(0, 0, 136); font-weight: bolder;">
	grep -n '!$' regular_express.txt</blockquote></td></tr>
<tr class="fontwidth"><td align="center">.</td><td><u>意义：代表『一定有一个任意字节』的字符！</u><br>
	范例：搜寻的字串可以是 (eve) (eae) (eee) (e e)， 但不能仅有 (ee) ！亦即 e 与 e 中间『一定』仅有一个字节，而空白字节也是字节！
	<blockquote style="padding: 0pt 0pt 0pt 25px; margin: 0pt; color: rgb(0, 0, 136); font-weight: bolder;">
	grep -n 'e.e' regular_express.txt</blockquote></td></tr>
<tr class="fontwidth"><td align="center">\</td><td><u>意义：跳脱字符，将特殊符号的特殊意义去除！</u><br>
	范例：搜寻含有单引号 ' 的那一行！
	<blockquote style="padding: 0pt 0pt 0pt 25px; margin: 0pt; color: rgb(0, 0, 136); font-weight: bolder;">
	grep -n \' regular_express.txt</blockquote></td></tr>
<tr class="fontwidth"><td align="center">*</td><td><u>意义：重复零个到无穷多个的前一个 RE 字符</u><br>
	范例：找出含有 (es) (ess) (esss) 等等的字串，注意，因为 * 可以是 0 个，所以 es 也是符合带搜寻字串。另外，因为 * 
	为重复『前一个 RE 字符』的符号， 因此，在 * 之前必须要紧接著一个 RE 字符喔！例如任意字节则为 『.*』 ！
	<blockquote style="padding: 0pt 0pt 0pt 25px; margin: 0pt; color: rgb(0, 0, 136); font-weight: bolder;">
	grep -n 'ess*' regular_express.txt</blockquote></td></tr>
<tr class="fontwidth"><td align="center">[list]</td><td><u>意义：字节集合的 RE 字符，里面列出想要撷取的字节！</u><br>
	范例：搜寻含有 (gl) 或 (gd) 的那一行，需要特别留意的是，在 [] 当中『谨代表一个待搜寻的字节』，
	例如『 a[afl]y 』代表搜寻的字串可以是 aay, afy, aly 即 [afl] 代表 a 或 f 或 l 的意思！
	<blockquote style="padding: 0pt 0pt 0pt 25px; margin: 0pt; color: rgb(0, 0, 136); font-weight: bolder;">
	grep -n 'g[ld]' regular_express.txt</blockquote></td></tr>
<tr class="fontwidth"><td align="center">[n1-n2]</td><td><u>意义：字节集合的 RE 字符，里面列出想要撷取的字节范围！</u><br>
	范例：搜寻含有任意数字的那一行！需特别留意，在字节集合 [] 中的减号 - 
	是有特殊意义的，他代表两个字节之间的所有连续字节！但这个连续与否与 ASCII 编码有关，因此，你的编码需要配置正确(在 
	bash 当中，需要确定 LANG 与 LANGUAGE 的变量是否正确！) 例如所有大写字节则为 [A-Z]
	<blockquote style="padding: 0pt 0pt 0pt 25px; margin: 0pt; color: rgb(0, 0, 136); font-weight: bolder;">
	grep -n '[A-Z]' regular_express.txt</blockquote></td></tr>
<tr class="fontwidth"><td align="center">[^list]</td><td><u>意义：字节集合的 RE 字符，里面列出不要的字串或范围！</u><br>
	范例：搜寻的字串可以是 (oog) (ood) 但不能是 (oot) ，那个 ^ 在 [] 内时，代表的意义是『反向选择』的意思。
	例如，我不要大写字节，则为 [^A-Z]。但是，需要特别注意的是，如果以 grep -n [^A-Z] regular_express.txt 
	来搜寻，却发现该文件内的所有行都被列出，为什么？因为这个 [^A-Z] 是『非大写字节』的意思，
	因为每一行均有非大写字节，例如第一行的 "Open Source" 就有 p,e,n,o.... 等等的小写字
	<blockquote style="padding: 0pt 0pt 0pt 25px; margin: 0pt; color: rgb(0, 0, 136); font-weight: bolder;">
	grep -n 'oo[^t]' regular_express.txt</blockquote></td></tr>
<tr class="fontwidth"><td align="center">\{n,m\}</td><td><u>意义：连续 n 到 m 个的『前一个 RE 字符』<br>
意义：若为 \{n\} 则是连续 n 个的前一个 RE 字符，<br>
意义：若是 \{n,\} 则是连续 n 个以上的前一个 RE 字符！</u>
	范例：在 g 与 g 之间有 2 个到 3 个的 o 存在的字串，亦即 (goog)(gooog)
	<blockquote style="padding: 0pt 0pt 0pt 25px; margin: 0pt; color: rgb(0, 0, 136); font-weight: bolder;">
	grep -n 'go\{2,3\}g' regular_express.txt</blockquote></td></tr>
</tbody></table>

		<p>再次强调：『<span class="text_import2">正规表示法的特殊字节』与一般在命令列输入命令的『万用字节』并不相同</span>，
		例如，在万用字节当中的 * 代表的是『 0 ~ 无限多个字节』的意思，但是在正规表示法当中，
		* 则是『重复 0 到无穷多个的前一个 RE 字符』的意思～使用的意义并不相同，不要搞混了！</p>

		<p>举例来说，不支持正规表示法的 ls 这个工具中，若我们使用 『ls -l * 』
		代表的是任意档名的文件，而 『ls -l a* 』代表的是以 a 为开头的任何档名的文件，
		但在正规表示法中，我们要找到含有以 a 为开头的文件，则必须要这样：(需搭配支持正规表示法的工具)</p>

		<blockquote style="font-family: &#39;细明体&#39;;">ls | grep -n '^a.*' </blockquote>

<table border="1" cellpadding="5" cellspacing="0" width="90%"><tbody><tr><td>
例题：<div class="block2">
以 ls -l 配合 grep 找出 /etc/ 底下文件类型为连结档属性的档名
</div>
答：<div class="block2">
由於 ls -l 列出连结档时标头会是『 lrwxrwxrwx 』，因此使用如下的命令即可找出结果：
<blockquote style="font-family: &#39;细明体&#39;;">ls -l /etc | grep '^l'</blockquote>
若仅想要列出几个文件，再以『 |wc -l 』 来累加处理即可。
</div>
</td></tr></tbody></table><br>

	</div>

	<hr><a name="sed"></a><img src="./鸟哥的 Linux 私房菜13 -- 正规表示法 (regular expression, RE) 与文件格式化处理_files/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">sed 工具</span><br>
	<div class="block2">
		<p>在了解了一些正规表示法的基础应用之后，再来呢？呵呵～两个东西可以玩一玩的，那就是 sed 跟底下会介绍的 awk 了！
		这两个家伙可是相当的有用的啊！举例来说，鸟哥写的 <a href="http://cn.linux.vbird.org/linux_basic/0570syslog.php">logfile.sh 分析登录档的小程序</a>
		(第十九章会谈到)，绝大部分分析关键字的取用、统计等等，就是用这两个宝贝蛋来帮我完成的！那么你说，要不要玩一玩啊？^_^</p>

		<p>我们先来谈一谈 sed 好了， sed 本身也是一个管线命令，可以分析 standard input 的啦！
		而且 sed 还可以将数据进行取代、删除、新增、撷取特定行等等的功能呢！很不错吧～
		我们先来了解一下 sed 的用法，再来聊他的用途好了！</p>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">sed [-nefr] [动作]</span>
<span class="term_say">选项与参数：
-n  ：使用安静(silent)模式。在一般 sed 的用法中，所有来自 STDIN 
      的数据一般都会被列出到萤幕上。但如果加上 -n 参数后，则只有经过
      sed 特殊处理的那一行(或者动作)才会被列出来。
-e  ：直接在命令列模式上进行 sed 的动作编辑；
-f  ：直接将 sed 的动作写在一个文件内， -f filename 则可以运行 filename 内的 
      sed 动作；
-r  ：sed 的动作支持的是延伸型正规表示法的语法。(默认是基础正规表示法语法)
-i  ：直接修改读取的文件内容，而不是由萤幕输出。

动作说明：  [n1[,n2]]function
n1, n2 ：不见得会存在，一般代表『选择进行动作的行数』，举例来说，如果我的动作
         是需要在 10 到 20 行之间进行的，则『 10,20[动作行为] 』

function 有底下这些咚咚：
a   ：新增， a 的后面可以接字串，而这些字串会在新的一行出现(目前的下一行)～
c   ：取代， c 的后面可以接字串，这些字串可以取代 n1,n2 之间的行！
d   ：删除，因为是删除啊，所以 d 后面通常不接任何咚咚；
i   ：插入， i 的后面可以接字串，而这些字串会在新的一行出现(目前的上一行)；
p   ：列印，亦即将某个选择的数据印出。通常 p 会与参数 sed -n 一起运行～
s   ：取代，可以直接进行取代的工作哩！通常这个 s 的动作可以搭配
      正规表示法！例如 1,20s/old/new/g 就是啦！</span>
</pre></td></tr></tbody></table>

		<a name="sed_line_add"></a>
		<hr><ul class="list1"><li class="text_import1">以行为单位的新增/删除功能</li></ul>

		<p>sed 光是用看的是看不懂的啦！所以又要来练习了！先来玩玩删除与新增的功能吧！</p>

<table class="term"><tbody><tr><td class="term"><pre><span class="term_hd">范例一：将 /etc/passwd 的内容列出并且列印行号，同时，请将第 2~5 行删除！</span>
[root@www ~]# <span class="term_command">nl /etc/passwd | sed '2,5d'</span>
     1  root:x:0:0:root:/root:/bin/bash
     6  sync:x:5:0:sync:/sbin:/bin/sync
     7  shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown
<span class="term_say">.....(后面省略).....</span>
</pre></td></tr></tbody></table>

		<p>看到了吧？sed 的动作为 '2,5d' ，那个 d 就是删除！因为 2-5 行给他删除了，所以显示的数据就没有 2-5 行罗～
		另外，注意一下，原本应该是要下达 sed -e 才对，没有 -e 也行啦！同时也要注意的是， sed 
		后面接的动作，请务必以 '' 两个单引号括住喔！</p>

		<p>如果题型变化一下，举例来说，如果只要删除第 2 行，可以使用『 nl /etc/passwd | sed '2d' 』来达成，
		至於若是要删除第 3 到最后一行，则是『 nl /etc/passwd | sed '3,$d' 』的啦，那个<span class="text_import2">钱字号『 $ 』代表最后一行！</span></p>

<table class="term"><tbody><tr><td class="term"><pre><span class="term_hd">范例二：承上题，在第二行后(亦即是加在第三行)加上『drink tea?』字样！</span>
[root@www ~]# <span class="term_command">nl /etc/passwd | sed '2a drink tea'</span>
     1  root:x:0:0:root:/root:/bin/bash
     2  bin:x:1:1:bin:/bin:/sbin/nologin
drink tea
     3  daemon:x:2:2:daemon:/sbin:/sbin/nologin
<span class="term_say">.....(后面省略).....</span>
</pre></td></tr></tbody></table>

		<p>嘿嘿！在 a 后面加上的字串就已将出现在第二行后面罗！那如果是要在第二行前呢？『
		nl /etc/passwd | sed '2i drink tea' 』就对啦！就是将『 a 』变成『 i 』即可。
		添加一行很简单，那如果是要增将两行以上呢？</p>

<table class="term"><tbody><tr><td class="term"><pre><span class="term_hd">范例三：在第二行后面加入两行字，例如『Drink tea or .....』与『drink beer?』</span>
[root@www ~]# <span class="term_command">nl /etc/passwd | sed '2a Drink tea or ......\</span>
&gt; <span class="term_command">drink beer ?'</span>
     1  root:x:0:0:root:/root:/bin/bash
     2  bin:x:1:1:bin:/bin:/sbin/nologin
Drink tea or ......
drink beer ?
     3  daemon:x:2:2:daemon:/sbin:/sbin/nologin
<span class="term_say">.....(后面省略).....</span>
</pre></td></tr></tbody></table>

		<p>这个范例的重点是『我们可以新增不只一行喔！可以新增好几行』但是每一行之间都必须要以反斜线『 \ 
		』来进行新行的添加喔！所以，上面的例子中，我们可以发现在第一行的最后面就有 \ 存在啦！那是一定要的喔！<br><br></p>

		<a name="sed_line_replace"></a>
		<hr><ul class="list1"><li class="text_import1">以行为单位的取代与显示功能</li></ul>

		<p>刚刚是介绍如何新增与删除，那么如果要整行取代呢？看看底下的范例吧：</p>

<table class="term"><tbody><tr><td class="term"><pre><span class="term_hd">范例四：我想将第2-5行的内容取代成为『No 2-5 number』呢？</span>
[root@www ~]# <span class="term_command">nl /etc/passwd | sed '2,5c No 2-5 number'</span>
     1  root:x:0:0:root:/root:/bin/bash
No 2-5 number
     6  sync:x:5:0:sync:/sbin:/bin/sync
<span class="term_say">.....(后面省略).....</span>
</pre></td></tr></tbody></table>

		<p>透过这个方法我们就能够将数据整行取代了！非常容易吧！sed 还有更好用的东东！我们以前想要列出第 11~20 行，
		得要透过『head -n 20 | tail -n 10』之类的方法来处理，很麻烦啦～
		sed 则可以简单的直接取出你想要的那几行！是透过行号来捉的喔！看看底下的范例先：</p>

<table class="term"><tbody><tr><td class="term"><pre><span class="term_hd">范例五：仅列出 /etc/passwd 文件内的第 5-7 行</span>
[root@www ~]# <span class="term_command">nl /etc/passwd | sed -n '5,7p'</span>
     5  lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin
     6  sync:x:5:0:sync:/sbin:/bin/sync
     7  shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown
</pre></td></tr></tbody></table>

		<p>上述的命令中有个重要的选项『 -n 』，按照说明文件，这个 -n 代表的是『安静模式』！
		那么为什么要使用安静模式呢？你可以自行下达 sed '5,7p' 就知道了 (5-7 行会重复输出)！
		有没有加上 -n 的参数时，输出的数据可是差很多的喔！你可以透过这个 sed 的以行为单位的显示功能，
		就能够将某一个文件内的某些行号捉出来查阅！很棒的功能！不是吗？<br><br></p>

		<a name="sed_replace"></a>
		<hr><ul class="list1"><li class="text_import1">部分数据的搜寻并取代的功能</li></ul>

		<p>除了整行的处理模式之外， sed 还可以用行为单位进行部分数据的搜寻并取代的功能喔！
		基本上 sed 的搜寻与取代的与 vi 相当的类似！他有点像这样：</p>

<table class="term"><tbody><tr><td class="term"><pre><span class="term_command">sed 's/</span>要被取代的字串<span class="term_command">/</span>新的字串<span class="term_command">/g'</span>
</pre></td></tr></tbody></table>

		<p>上表中特殊字体的部分为关键字，请记下来！至於三个斜线分成两栏就是新旧字串的替换啦！
		我们使用底下这个取得 IP 数据的范例，一段一段的来处理给您瞧瞧，让你了解一下什么是咱们所谓的搜寻并取代吧！</p>

<table class="term"><tbody><tr><td class="term"><pre><span class="term_hd">步骤一：先观察原始信息，利用 /sbin/ifconfig  查询 IP 为何？</span>
[root@www ~]# <span class="term_command">/sbin/ifconfig eth0</span>
eth0      Link encap:Ethernet  HWaddr 00:90:CC:A6:34:84
          <span class="term_write">inet addr:192.168.1.100  Bcast:192.168.1.255  Mask:255.255.255.0</span>
          inet6 addr: fe80::290:ccff:fea6:3484/64 Scope:Link
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
<span class="term_say">.....(以下省略).....
# 因为我们还没有讲到 IP ，这里你先有个概念即可啊！我们的重点在第二行，
# 也就是 192.168.1.100 那一行而已！先利用关键字捉出那一行！</span>

<span class="term_hd">步骤二：利用关键字配合 grep 撷取出关键的一行数据</span>
[root@www ~]# <span class="term_command">/sbin/ifconfig eth0 | grep 'inet addr'</span>
          <span class="term_write">inet addr</span>:192.168.1.100  Bcast:192.168.1.255  Mask:255.255.255.0
<span class="term_say"># 当场仅剩下一行！接下来，我们要将开始到 addr: 通通删除，就是像底下这样：
# <span style="text-decoration: line-through;">inet addr:</span>192.168.1.100  Bcast:192.168.1.255  Mask:255.255.255.0
# 上面的删除关键在於『 ^.*inet addr: 』啦！正规表示法出现！ ^_^</span>

<span class="term_hd">步骤三：将 IP 前面的部分予以删除</span>
[root@www ~]# <span class="term_command">/sbin/ifconfig eth0 | grep 'inet addr' | \</span>
&gt; <span class="term_command"> sed 's/^.*addr://g'</span>
192.168.1.100  Bcast:192.168.1.255  Mask:255.255.255.0
<span class="term_say"># 仔细与上个步骤比较一下，前面的部分不见了！接下来则是删除后续的部分，亦即：
# 192.168.1.100  <span style="text-decoration: line-through;">Bcast:192.168.1.255  Mask:255.255.255.0</span>
# 此时所需的正规表示法为：『 Bcast.*$ 』就是啦！</span>

<span class="term_hd">步骤四：将 IP 后面的部分予以删除</span>
[root@www ~]# <span class="term_command">/sbin/ifconfig eth0 | grep 'inet addr' | \</span>
&gt; <span class="term_command"> sed 's/^.*addr://g' | sed 's/Bcast.*$//g'</span>
192.168.1.100
</pre></td></tr></tbody></table>

		<p>透过这个范例的练习也建议您依据此一步骤来研究你的命令！就是先观察，然后再一层一层的试做，
		如果有做不对的地方，就先予以修改，改完之后测试，成功后再往下继续测试。以鸟哥上面的介绍中，
		那一大串命令就做了四个步骤！对吧！ ^_^</p>

		<p>让我们再来继续研究 sed 与正规表示法的配合练习！假设我只要 MAN 存在的那几行数据，
		但是含有 # 在内的注解我不想要，而且空白行我也不要！此时该如何处理呢？可以透过这几个步骤来实作看看：</p>

<table class="term"><tbody><tr><td class="term"><pre><span class="term_hd">步骤一：先使用 grep 将关键字 MAN 所在行取出来</span>
[root@www ~]# <span class="term_command">cat /etc/man.config | grep 'MAN'</span>
# when MANPATH contains an empty substring), to find out where the cat
# MANBIN                pathname
# MANPATH               manpath_element [corresponding_catdir]
# MANPATH_MAP           path_element    manpath_element
# MANBIN                /usr/local/bin/man
# Every automatically generated MANPATH includes these fields
MANPATH /usr/man
<span class="term_say">....(后面省略)....</span>

<span class="term_hd">步骤二：删除掉注解之后的数据！</span>
[root@www ~]# <span class="term_command">cat /etc/man.config | grep 'MAN'| sed 's/#.*$//g'</span>






MANPATH /usr/man
<span class="term_say">....(后面省略)....
# 从上面可以看出来，原本注解的数据都变成空白行啦！所以，接下来要删除掉空白行</span>

[root@www ~]# <span class="term_command">cat /etc/man.config | grep 'MAN'| sed 's/#.*$//g' | \</span>
&gt; <span class="term_command">sed '/^$/d'</span>
MANPATH /usr/man
MANPATH /usr/share/man
MANPATH /usr/local/man
<span class="term_say">....(后面省略)....</span>
</pre></td></tr></tbody></table>

		<a name="sed_file"></a>
		<hr><ul class="list1"><li class="text_import1">直接修改文件内容(危险动作)</li></ul>

		<p>你以为 sed 只有这样的能耐吗？那可不！ sed 甚至可以直接修改文件的内容呢！而不必使用管线命令或数据流重导向！
		不过，由於这个动作会直接修改到原始的文件，所以请你千万不要随便拿系统配置档来测试喔！
		我们还是使用你下载的 regular_express.txt 文件来测试看看吧！</p>

<table class="term"><tbody><tr><td class="term"><pre><span class="term_hd">范例六：利用 sed 将 regular_express.txt 内每一行结尾若为 . 则换成 !</span>
[root@www ~]# <span class="term_command">sed -i 's/\.$/\!/g' regular_express.txt</span>
<span class="term_say"># 上头的 -i 选项可以让你的 sed 直接去修改后面接的文件内容而不是由萤幕输出喔！
# 这个范例是用在取代！请您自行 cat 该文件去查阅结果罗！</span>

<span class="term_hd">范例七：利用 sed 直接在 regular_express.txt 最后一行加入『# This is a test』</span>
[root@www ~]# <span class="term_command">sed -i '$a # This is a test' regular_express.txt</span>
<span class="term_say"># 由於 $ 代表的是最后一行，而 a 的动作是新增，因此该文件最后新增罗！</span>
</pre></td></tr></tbody></table>

		<p>sed 的『 -i 』选项可以直接修改文件内容，这功能非常有帮助！举例来说，如果你有一个 100 万行的文件，你要在第 
		100 行加某些文字，此时使用 vim 可能会疯掉！因为文件太大了！那怎办？就利用 sed 啊！透过 sed 
		直接修改/取代的功能，你甚至不需要使用 vim 去修订！很棒吧！</p>

		<p>总之，这个 sed 不错用啦！而且很多的 shell script 都会使用到这个命令的功能～
		sed 可以帮助系统管理员管理好日常的工作喔！要仔细的学习呢！</p>
	</div>
</div>


<hr><a name="extend"></a><img src="./鸟哥的 Linux 私房菜13 -- 正规表示法 (regular expression, RE) 与文件格式化处理_files/logo.png" alt="大标题的图示" width="35" align="middle" height="34"><span class="text_h1">延伸正规表示法</span><br>
<div class="block1">
	<p>事实上，一般读者只要了解基础型的正规表示法大概就已经相当足够了，不过，某些时刻为了要简化整个命令操作，
	了解一下使用范围更广的延伸型正规表示法的表示式会更方便呢！举个简单的例子好了，在上节的<a href="http://cn.linux.vbird.org/linux_basic/0330regularex.php#blank_line">例题三的最后一个例子</a>中，我们要去除空白行与行首为 # 的行列，使用的是</p>

	<blockquote class="fontwidth">grep -v '^$' regular_express.txt | grep -v '^#'</blockquote>

	<p>需要使用到管线命令来搜寻两次！那么如果使用延伸型的正规表示法，我们可以简化为：</p>

	<blockquote class="fontwidth">egrep -v '^$|^#' regular_express.txt</blockquote>

	<p>延伸型正规表示法可以透过群组功能『 | 』来进行一次搜寻！那个在单引号内的管线意义为『或 or』啦！
	是否变的更简单呢？此外，grep 默认仅支持基础正规表示法，如果要使用延伸型正规表示法，你可以使用 grep -E ，
	不过更建议直接使用 egrep ！直接区分命令比较好记忆！其实 egrep 与 grep -E 是类似命令别名的关系啦！</p>

	<p>熟悉了正规表示法之后，到这个延伸型的正规表示法，你应该也会想到，不就是多几个重要的特殊符号吗？ ^_^y 
	是的～所以，我们就直接来说明一下，延伸型正规表示法有哪几个特殊符号？由於底下的范例还是有使用到 regular_express.txt
	，不巧的是刚刚我们可能将该文件修改过了 @_@，所以，请重新下载该文件来练习喔！</p>

<table bgcolor="lightyellow" border="1" cellpadding="3" cellspacing="0" width="95%">
<tbody><tr style="text-align: center;" bgcolor="#182448"><td width="10%"><font color="#FFFFFF">RE 字符</font></td><td><font color="#FFFFFF">意义与范例</font></td></tr>
<tr class="fontwidth"><td align="center">+</td><td><u>意义：重复『一个或一个以上』的前一个 RE 字符</u><br>
	范例：搜寻 (god) (good) (goood)... 等等的字串。 那个 o+ 代表『一个以上的 o 』所以，底下的运行成果会将第 1, 9, 13 行列出来。
	<blockquote style="padding: 0pt 0pt 0pt 25px; margin: 0pt; color: rgb(0, 0, 136); font-weight: bolder;">
	egrep -n 'go+d' regular_express.txt</blockquote></td></tr>
<tr class="fontwidth"><td align="center">?</td><td><u>意义：『零个或一个』的前一个 RE 字符</u><br>
	范例：搜寻 (gd) (god) 这两个字串。 那个 o? 代表『空的或 1 个 o 』所以，上面的运行成果会将第 13, 14 行列出来。
	有没有发现到，这两个案例( 'go+d' 与 'go?d' )的结果集合与 'go*d' 相同？ 想想看，这是为什么喔！ ^_^
	<blockquote style="padding: 0pt 0pt 0pt 25px; margin: 0pt; color: rgb(0, 0, 136); font-weight: bolder;">
	egrep -n 'go?d' regular_express.txt</blockquote></td></tr>
<tr class="fontwidth"><td align="center">|</td><td><u>意义：用或( or )的方式找出数个字串</u><br>
	范例：搜寻 gd 或 good 这两个字串，注意，是『或』！ 所以，第 1,9,14 这三行都可以被列印出来喔！那如果还想要找出 dog 呢？
	<blockquote style="padding: 0pt 0pt 0pt 25px; margin: 0pt; color: rgb(0, 0, 136); font-weight: bolder;">
	egrep -n 'gd|good' regular_express.txt<br>
	egrep -n 'gd|good|dog' regular_express.txt</blockquote></td></tr>
<tr class="fontwidth"><td align="center">()</td><td><u>意义：找出『群组』字串</u><br>
	范例：搜寻 (glad) 或 (good) 这两个字串，因为 g 与 d 是重复的，所以， 我就可以将 la 与 oo 列於 ( ) 当中，并以 | 来分隔开来，就可以啦！
	<blockquote style="padding: 0pt 0pt 0pt 25px; margin: 0pt; color: rgb(0, 0, 136); font-weight: bolder;">
	egrep -n 'g(la|oo)d' regular_express.txt</blockquote></td></tr>
<tr class="fontwidth"><td align="center">()+</td><td><u>意义：多个重复群组的判别</u><br>
	范例：将『AxyzxyzxyzxyzC』用 echo 叫出，然后再使用如下的方法搜寻一下！
	<blockquote style="padding: 0pt 0pt 0pt 25px; margin: 0pt; color: rgb(0, 0, 136); font-weight: bolder;">
	echo 'AxyzxyzxyzxyzC' | egrep 'A(xyz)+C'</blockquote>
	上面的例子意思是说，我要找开头是 A 结尾是 C ，中间有一个以上的 "xyz" 字串的意思～</td></tr>
</tbody></table><br>

	<p>以上这些就是延伸型的正规表示法的特殊字节。另外，要特别强调的是，那个 ! 在正规表示法当中并不是特殊字节，
	所以，如果你想要查出来文件中含有 ! 与 &gt; 的字行时，可以这样：</p>

	<blockquote class="fontwidth">grep -n '[!&gt;]' regular_express.txt</blockquote>

	<p>这样可以了解了吗？常常看到有陷阱的题目写：『反向选择这样对否？ '[!a-z]'？』，
	呵呵！是错的呦～要 '[^a-z] 才是对的！至於更多关於正规表示法的进阶文章，请参考文末的参考数据(<a href="http://cn.linux.vbird.org/linux_basic/0330regularex.php#ps2">注2</a>)</p>
</div>
　

<hr><a name="docs"></a><img src="./鸟哥的 Linux 私房菜13 -- 正规表示法 (regular expression, RE) 与文件格式化处理_files/logo.png" alt="大标题的图示" width="35" align="middle" height="34"><span class="text_h1">文件的格式化与相关处理</span><br>
<div class="block1">
	<p>接下来让我们来将文件进行一些简单的编排吧！底下这些动作可以将你的信息进行排版的动作，
	不需要重新以 vim 去编辑，透过数据流重导向配合底下介绍的 printf 功能，以及 awk 命令，
	就可以让你的信息以你想要的模样来输出了！试看看吧！<br><br></p>

	<hr><a name="printf"></a><img src="./鸟哥的 Linux 私房菜13 -- 正规表示法 (regular expression, RE) 与文件格式化处理_files/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">格式化列印： printf</span><br>
	<div class="block1">
		<p>在很多时候，我们可能需要将自己的数据给他格式化输出的！
		举例来说，考试卷分数的输出，姓名与科目及分数之间，总是可以稍微作个比较漂亮的版面配置吧？
		例如我想要输出底下的样式：</p>

<table class="term"><tbody><tr><td class="term"><pre>Name     Chinese   English   Math    Average
DmTsai        80        60     92      77.33
VBird         75        55     80      70.00
Ken           60        90     70      73.33
</pre></td></tr></tbody></table>

		<p>上表的数据主要分成五个栏位，各个栏位之间可使用 tab 或空白键进行分隔。
		请将上表的数据转存成为 printf.txt 档名，等一下我们会利用这个文件来进行几个小练习的。
		因为每个栏位的原始数据长度其实并非是如此固定的 (Chinese 长度就是比 Name 要多)，
		而我就是想要如此表示出这些数据，此时，就得需要列印格式管理员 printf 的帮忙了！
		printf 可以帮我们将数据输出的结果格式化，而且而支持一些特殊的字符～底下我们就来看看！</p>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">printf '列印格式' 实际内容</span>
<span class="term_say">选项与参数：
关於格式方面的几个特殊样式：
       \a    警告声音输出
       \b    倒退键(backspace)
       \f    清除萤幕 (form feed)
       \n    输出新的一行
       \r    亦即 Enter 按键
       \t    水平的 [tab] 按键
       \v    垂直的 [tab] 按键
       \xNN  NN 为两位数的数字，可以转换数字成为字节。
关於 C 程序语言内，常见的变量格式
       %ns   那个 n 是数字， s 代表 string ，亦即多少个字节；
       %ni   那个 n 是数字， i 代表 integer ，亦即多少整数码数；
       %N.nf 那个 n 与 N 都是数字， f 代表 floating (浮点)，如果有小数码数，
             假设我共要十个位数，但小数点有两位，即为 %10.2f 罗！</span>
</pre></td></tr></tbody></table>

		<p>接下来我们来进行几个常见的练习。假设所有的数据都是一般文字 (这也是最常见的状态)，因此最常用来分隔数据的符号就是 
		[Tab] 啦！因为 [Tab] 按键可以将数据作个整齐的排列！那么如何利用 printf 呢？参考底下这个范例：</p>

<table class="term"><tbody><tr><td class="term"><pre><span class="term_hd">范例一：将刚刚上头数据的文件 (printf.txt) 内容仅列出姓名与成绩：(用 [tab] 分隔)</span>
[root@www ~]# <span class="term_command">printf '%s\t %s\t %s\t %s\t %s\t \n' $(cat printf.txt)</span>
Name     Chinese         English         Math    Average
DmTsai   80      60      92      77.33
VBird    75      55      80      70.00
Ken      60      90      70      73.33
</pre></td></tr></tbody></table>

		<p>由於 printf 并不是管线命令，因此我们得要透过类似上面的功能，将文件内容先提出来给 printf 作为后续的数据才行。
		如上所示，我们将每个数据都以 [tab] 作为分隔，但是由於 Chinese 长度太长，导致 English 中间多了一个 [tab] 
		来将数据排列整齐！啊～结果就看到数据对齐结果的差异了！</p>

		<p>另外，在 printf 后续的那一段格式中，%s 代表一个不固定长度的字串，而字串与字串中间就以 \t 这个 [tab]
		分隔符号来处理！你要记得的是，由於 \t 与 %s 中间还有空格，因此每个字串间会有一个 [tab] 与一个空白键的分隔喔！</p>

		<p>既然每个栏位的长度不固定会造成上述的困扰，那我将每个栏位固定就好啦！没错没错！这样想非常好！
		所以我们就将数据给他进行固定栏位长度的设计吧！</p>

<table class="term"><tbody><tr><td class="term"><pre><span class="term_hd">范例二：将上述数据关於第二行以后，分别以字串、整数、小数点来显示：</span>
[root@www ~]# <span class="term_command">printf '%10s %5i %5i %5i %8.2f \n' $(cat printf.txt |\</span>
&gt; <span class="term_command">grep -v Name)</span>
    DmTsai    80    60    92    77.33
     VBird    75    55    80    70.00
       Ken    60    90    70    73.33
</pre></td></tr></tbody></table>

		<p>上面这一串格式想必您看得很辛苦！没关系！一个一个来解释！上面的格式共分为五个栏位， %10s 
		代表的是一个长度为 10 个字节的字串栏位，%5i 代表的是长度为 5 个字节的数字栏位，至於那个 %8.2f 
		则代表长度为 8 个字节的具有小数点的栏位，其中小数点有两个字节宽度。我们可以使用底下的说明来介绍 %8.2f 的意义：</p>

		<blockquote class="fontwidth">字节宽度： 12345678<br>%8.2f意义：00000.00</blockquote>

		<p>如上所述，全部的宽度仅有 8 个字节，整数部分占有 5 个字节，小数点本身 (.) 占一位，小数点下的位数则有两位。
		这种格式经常使用於数值程序的设计中！这样了解乎？自己试看看如果要将小数点位数变成 1 位又该如何处理？</p>

		<p>printf 除了可以格式化处理之外，他还可以依据 ASCII 的数字与图形对应来显示数据喔(<a href="http://cn.linux.vbird.org/linux_basic/0330regularex.php#ps3">注3</a>)！
		举例来说 16 进位的 45 可以得到什么 ASCII 的显示图 (其实是字节啦)？</p>

<table class="term"><tbody><tr><td class="term"><pre><span class="term_hd">范例三：列出 16 进位数值 45 代表的字节为何？</span>
[root@www ~]# <span class="term_command">printf '\x45\n'</span>
E
<span class="term_say"># 这东西也很好玩～他可以将数值转换成为字节，如果你会写 script 的话，
# 可以自行测试一下，由 20~80 之间的数值代表的字节是啥喔！ ^_^</span>
</pre></td></tr></tbody></table>

		<p>printf 的使用相当的广泛喔！包括等一下后面会提到的 awk 以及在 C 程序语言当中使用的萤幕输出，
		都是利用 printf 呢！鸟哥这里也只是列出一些可能会用到的格式而已，有兴趣的话，可以自行多作一些测试与练习喔！ ^_^</p>

		<div style="padding: 10pt 0pt;" align="right"><table width="90%"><tbody><tr><td><b>Tips:</b><br><span style="color: rgb(0, 144, 0);"><font size="-1">		列印格式化这个 printf 命令，乍看之下好像也没有什么很重要的～
		不过，如果你需要自行撰写一些软件，需要将一些数据在萤幕上头漂漂亮亮的输出的话，
		那么 printf 可也是一个很棒的工具喔！
		</font></span></td><td><img src="./鸟哥的 Linux 私房菜13 -- 正规表示法 (regular expression, RE) 与文件格式化处理_files/vbird_face.gif" alt="鸟哥的图示" title="鸟哥的图示"></td></tr></tbody></table></div>	</div>

	<hr><a name="awk"></a><img src="./鸟哥的 Linux 私房菜13 -- 正规表示法 (regular expression, RE) 与文件格式化处理_files/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">awk：好用的数据处理工具</span><br>
	<div class="block1">
		<p>awk 也是一个非常棒的数据处理工具！相较於 sed 常常作用於一整个行的处理， awk 
		则比较倾向於一行当中分成数个『栏位』来处理。因此，awk 相当的适合处理小型的数据数据处理呢！awk
		通常运行的模式是这样的：</p>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">awk '条件类型1{动作1} 条件类型2{动作2} ...' filename</span>
</pre></td></tr></tbody></table>

		<p>awk 后面接两个单引号并加上大括号 {} 来配置想要对数据进行的处理动作。
		awk 可以处理后续接的文件，也可以读取来自前个命令的 standard output 。
		但如前面说的， <span class="text_import2">awk 主要是处理『每一行的栏位内的数据』，而默认的『栏位的分隔符号为
		"空白键" 或 "[tab]键" 』</span>！举例来说，我们用 last 可以将登陆者的数据取出来，结果如下所示：</p>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">last -n 5</span> <span class="term_note">&lt;==仅取出前五行</span>
root     pts/1   192.168.1.100  Tue Feb 10 11:21   still logged in
root     pts/1   192.168.1.100  Tue Feb 10 00:46 - 02:28  (01:41)
root     pts/1   192.168.1.100  Mon Feb  9 11:41 - 18:30  (06:48)
dmtsai   pts/1   192.168.1.100  Mon Feb  9 11:41 - 11:41  (00:00)
root     tty1                   Fri Sep  5 14:09 - 14:10  (00:01)
</pre></td></tr></tbody></table>

		<p>若我想要取出帐号与登陆者的 IP ，且帐号与 IP 之间以 [tab] 隔开，则会变成这样：</p>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">last -n 5 | awk '{print $1 "\t" $3}'</span>
root    192.168.1.100
root    192.168.1.100
root    192.168.1.100
dmtsai  192.168.1.100
root    Fri
</pre></td></tr></tbody></table>

		<p>上表是 awk 最常使用的动作！透过 print 的功能将栏位数据列出来！栏位的分隔则以空白键或 [tab] 按键来隔开。
		因为不论哪一行我都要处理，因此，就不需要有 "条件类型" 的限制！我所想要的是第一栏以及第三栏，
		但是，第五行的内容怪怪的～这是因为数据格式的问题啊！所以罗～使用 awk
		的时候，请先确认一下你的数据当中，如果是连续性的数据，请不要有空格或 [tab] 
		在内，否则，就会像这个例子这样，会发生误判喔！</p>

		<p>另外，由上面这个例子你也会知道，在<span class="text_import2">每一行的每个栏位都是有变量名称的，那就是 $1, $2... 
		等变量名称</span>。以上面的例子来说， root 是 $1 ，因为他是第一栏嘛！至於 192.168.1.100 是第三栏，
		所以他就是 $3 啦！后面以此类推～呵呵！还有个变量喔！那就是 $0 ，<span class="text_import2">$0 
		代表『一整列数据』的意思～</span>以上面的例子来说，第一行的 $0 代表的就是『root .... 』那一行啊！
		由此可知，刚刚上面五行当中，整个 awk 的处理流程是：</p>

		<ol class="text_import2">
		<li>读入第一行，并将第一行的数据填入 $0, $1, $2.... 等变量当中；</li>
		<li>依据 "条件类型" 的限制，判断是否需要进行后面的 "动作"；</li>
		<li>做完所有的动作与条件类型；</li>
		<li>若还有后续的『行』的数据，则重复上面 1~3 的步骤，直到所有的数据都读完为止。</li>
		</ol>

		<p>经过这样的步骤，你会晓得， awk 是『<span class="text_import2">以行为一次处理的单位</span>』，
		而『<span class="text_import2">以栏位为最小的处理单位</span>』。好了，那么 awk 
		怎么知道我到底这个数据有几行？有几栏呢？这就需要 awk 的内建变量的帮忙啦～</p>

<table bgcolor="lightyellow" border="1" cellpadding="3" cellspacing="0" width="75%">
<tbody><tr align="center" bgcolor="#182448"><td><font color="#FFFFFF">变量名称</font></td><td><font color="#FFFFFF">代表意义</font></td></tr>
<tr><td align="center">NF</td><td>每一行 ($0) 拥有的栏位总数</td></tr>
<tr><td align="center">NR</td><td>目前 awk 所处理的是『第几行』数据</td></tr>
<tr><td align="center">FS</td><td>目前的分隔字节，默认是空白键</td></tr>
</tbody></table><br>

		<p>我们继续以上面 last -n 5 的例子来做说明，如果我想要：</p>

		<ul>
		<li>列出每一行的帐号(就是 $1)；</li>
		<li>列出目前处理的行数(就是 awk 内的 NR 变量)</li>
		<li>并且说明，该行有多少栏位(就是 awk 内的 NF 变量)</li></ul>

		<p>则可以这样：</p>

		<div style="padding: 10pt 0pt;" align="right"><table width="90%"><tbody><tr><td><b>Tips:</b><br><span style="color: rgb(0, 144, 0);"><font size="-1">		要注意喔，awk 后续的所有动作是以单引号『 ' 』括住的，由於单引号与双引号都必须是成对的，
		所以， awk 的格式内容如果想要以 print 列印时，记得非变量的文字部分，包含上一小节 
		<a href="http://cn.linux.vbird.org/linux_basic/0330regularex.php#printf">printf</a> 提到的格式中，都需要使用双引号来定义出来喔！因为单引号已经是 awk 的命令固定用法了！
		</font></span></td><td><img src="./鸟哥的 Linux 私房菜13 -- 正规表示法 (regular expression, RE) 与文件格式化处理_files/vbird_face.gif" alt="鸟哥的图示" title="鸟哥的图示"></td></tr></tbody></table></div>
<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">last -n 5| awk '{print $1 "\t lines: " NR "\t columns: " NF}'</span>
root     lines: 1        columns: 10
root     lines: 2        columns: 10
root     lines: 3        columns: 10
dmtsai   lines: 4        columns: 10
root     lines: 5        columns: 9
<span class="term_say"># 注意喔，在 awk 内的 NR, NF 等变量要用大写，且不需要有钱字号 $ 啦！</span>
</pre></td></tr></tbody></table>

		<p>这样可以了解 NR 与 NF 的差别了吧？好了，底下来谈一谈所谓的 "条件类型" 了吧！<br><br></p>

		<hr><ul class="list1"><li class="text_import1">awk 的逻辑运算字节</li></ul>

		<p>既然有需要用到 "条件" 的类别，自然就需要一些逻辑运算罗～例如底下这些：</p>

<table bgcolor="lightyellow" border="1" cellpadding="3" cellspacing="0" width="75%">
<tbody><tr align="center" bgcolor="#182448"><td><font color="#FFFFFF">运算单元</font></td><td><font color="#FFFFFF">代表意义</font></td></tr>
<tr align="center"><td><font face="&#39;细明体&#39;">&gt;</font></td><td>大於</td></tr>
<tr align="center"><td><font face="&#39;细明体&#39;">&lt;</font></td><td>小於</td></tr>
<tr align="center"><td><font face="&#39;细明体&#39;">&gt;=</font></td><td>大於或等於</td></tr>
<tr align="center"><td><font face="&#39;细明体&#39;">&lt;=</font></td><td>小於或等於</td></tr>
<tr align="center"><td><font face="&#39;细明体&#39;">==</font></td><td>等於</td></tr>
<tr align="center"><td><font face="&#39;细明体&#39;">!=</font></td><td>不等於</td></tr>
</tbody></table>

		<p>值得注意的是那个『 <font face="&#39;细明体&#39;">==</font> 』的符号，因为：</p>

		<ul>
		<li>逻辑运算上面亦即所谓的大於、小於、等於等判断式上面，习惯上是以『 <font face="&#39;细明体&#39;">==</font> 』来表示；</li>
		<li>如果是直接给予一个值，例如变量配置时，就直接使用 = 而已。</li>
		</ul>

		<p>好了，我们实际来运用一下逻辑判断吧！举例来说，在 /etc/passwd 当中是以冒号 ":" 来作为栏位的分隔，
		该文件中第一栏位为帐号，第三栏位则是 UID。那假设我要查阅，第三栏小於 10 以下的数据，并且仅列出帐号与第三栏，
		那么可以这样做：</p>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">cat /etc/passwd | \</span>
&gt; <span class="term_command">awk '{FS=":"} $3 &lt; 10 {print $1 "\t " $3}'</span>
root:x:0:0:root:/root:/bin/bash
bin      1
daemon   2
<span class="term_say">....(以下省略)....</span>
</pre></td></tr></tbody></table>

		<p>有趣吧！不过，怎么第一行没有正确的显示出来呢？这是因为我们读入第一行的时候，那些变量 $1, 
		$2... 默认还是以空白键为分隔的，所以虽然我们定义了 FS=":" 了，
		但是却仅能在第二行后才开始生效。那么怎么办呢？我们可以预先配置 awk 的变量啊！
		利用 BEGIN 这个关键字喔！这样做：</p>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">cat /etc/passwd | \</span>
&gt; <span class="term_command">awk 'BEGIN {FS=":"} $3 &lt; 10 {print $1 "\t " $3}'</span>
root     0
bin      1
daemon   2
<span class="term_say">......(以下省略)......</span>
</pre></td></tr></tbody></table>

		<p>很有趣吧！而除了 BEGIN 之外，我们还有 END 呢！另外，如果要用 awk 来进行『计算功能』呢？以底下的例子来看，
		假设我有一个薪资数据表档名为 pay.txt ，内容是这样的：</p>

<table class="term"><tbody><tr><td class="term"><pre>Name    1st     2nd     3th
VBird   23000   24000   25000
DMTsai  21000   20000   23000
Bird2   43000   42000   41000
</pre></td></tr></tbody></table>

		<p>如何帮我计算每个人的总额呢？而且我还想要格式化输出喔！我们可以这样考虑：</p>

		<ul>
		<li>第一行只是说明，所以第一行不要进行加总 (NR==1 时处理)；</li>
		<li>第二行以后就会有加总的情况出现 (NR&gt;=2 以后处理)</li>
		</ul>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">cat pay.txt | \</span>
&gt; <span class="term_command">awk 'NR==1{printf "%10s %10s %10s %10s %10s\n",$1,$2,$3,$4,"Total" }
NR&gt;=2{total = $2 + $3 + $4
printf "%10s %10d %10d %10d %10.2f\n", $1, $2, $3, $4, total}'</span>
      Name        1st        2nd        3th      Total
     VBird      23000      24000      25000   72000.00
    DMTsai      21000      20000      23000   64000.00
     Bird2      43000      42000      41000  126000.00
</pre></td></tr></tbody></table>

		<p>上面的例子有几个重要事项应该要先说明的：</p>

		<ul class="text_import2">
		<li>awk 的命令间隔：所有 awk 的动作，亦即在 {} 内的动作，如果有需要多个命令辅助时，可利用分号『;』间隔，
			或者直接以 [Enter] 按键来隔开每个命令，例如上面的范例中，鸟哥共按了三次 [enter] 喔！</li>
		<li>逻辑运算当中，如果是『等於』的情况，则务必使用两个等号『==』！</li>
		<li>格式化输出时，在 printf 的格式配置当中，务必加上 \n ，才能进行分行！</li>
		<li>与 bash shell 的变量不同，在 awk 当中，变量可以直接使用，不需加上 $ 符号。</li>
		</ul>

		<p>利用 awk 这个玩意儿，就可以帮我们处理很多日常工作了呢！真是好用的很～
		此外， awk 的输出格式当中，常常会以 <a href="http://cn.linux.vbird.org/linux_basic/0330regularex.php#printf">printf</a> 来辅助，所以，
		最好你对 printf 也稍微熟悉一下比较好啦！另外， awk 的动作内 {} 也是支持 if (条件) 的喔！
		举例来说，上面的命令可以修订成为这样：</p>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">cat pay.txt | \</span>
&gt; <span class="term_command">awk '{if(NR==1) printf "%10s %10s %10s %10s %10s\n",$1,$2,$3,$4,"Total"}
NR&gt;=2{total = $2 + $3 + $4
printf "%10s %10d %10d %10d %10.2f\n", $1, $2, $3, $4, total}'</span>
</pre></td></tr></tbody></table>

		<p>你可以仔细的比对一下上面两个输入有啥不同～从中去了解两种语法吧！我个人是比较倾向於使用第一种语法，
		因为会比较有统一性啊！ ^_^</p>

		<p>除此之外， awk 还可以帮我们进行回圈计算喔！真是相当的好用！不过，那属於比较进阶的单独课程了，
		我们这里就不再多加介绍。如果你有兴趣的话，请务必参考延伸阅读中的相关连结喔 (<a href="http://cn.linux.vbird.org/linux_basic/0330regularex.php#ps4">注4</a>)。</p>
	</div>

	<hr><a name="doc_compare"></a><img src="./鸟哥的 Linux 私房菜13 -- 正规表示法 (regular expression, RE) 与文件格式化处理_files/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">文件比对工具</span><br>
	<div class="block2">
		<p>什么时候会用到文件的比对啊？通常是『<span class="text_import2">同一个套装软件的不同版本之间，比较配置档与原始档的差异</span>』。
		很多时候所谓的文件比对，通常是用在 ASCII 纯文字档的比对上的！那么比对文件的命令有哪些？最常见的就是 diff 罗！
		另外，除了 diff 比对之外，我们还可以藉由 cmp 来比对非纯文字档！同时，也能够藉由 diff 创建的分析档，
		以处理补丁 (patch) 功能的文件呢！就来玩玩先！<br><br></p>

		<a name="diff"></a>
		<hr><ul class="list1"><li class="text_import1">diff</li></ul>

		<p>diff 就是用在比对两个文件之间的差异的，并且是以行为单位来比对的！一般是用在 ASCII 纯文字档的比对上。
		由於是以行为比对的单位，因此<span class="text_import2"> diff 通常是用在同一的文件(或软件)的新旧版本差异上！</span>
		举例来说，假如我们要将 /etc/passwd 处理成为一个新的版本，处理方式为：
		将第四行删除，第六行则取代成为『no six line』，新的文件放置到 /tmp/test 里面，那么应该怎么做？</p>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">mkdir -p /tmp/test</span> <span class="term_note">&lt;==先创建测试用的目录</span>
[root@www ~]# <span class="term_command">cd /tmp/test</span>
[root@www test]# <span class="term_command">cp /etc/passwd passwd.old</span>
[root@www test]# <span class="term_command">cat /etc/passwd | \</span>
&gt; <span class="term_command">sed -e '4d' -e '6c no six line' &gt; passwd.new</span>
<span class="term_say"># 注意一下， sed 后面如果要接超过两个以上的动作时，每个动作前面得加 -e 才行！
# 透过这个动作，在 /tmp/test  里面便有新旧的 passwd 文件存在了！</span>
</pre></td></tr></tbody></table>

		<p>接下来讨论一下关於 diff 的用法吧！</p>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">diff [-bBi] from-file to-file</span>
<span class="term_say">选项与参数：
from-file ：一个档名，作为原始比对文件的档名；
to-file   ：一个档名，作为目的比对文件的档名；
注意，from-file 或 to-file 可以 - 取代，那个 - 代表『Standard input』之意。

-b  ：忽略一行当中，仅有多个空白的差异(例如 "about me" 与 "about     me" 视为相同
-B  ：忽略空白行的差异。
-i  ：忽略大小写的不同。</span>

<span class="term_hd">范例一：比对 passwd.old 与 passwd.new 的差异：</span>
[root@www test]# <span class="term_command">diff passwd.old passwd.new</span>
4d3    <span class="term_note">&lt;==左边第四行被删除 (d) 掉了，基准是右边的第三行</span>
&lt; adm:x:3:4:adm:/var/adm:/sbin/nologin  <span class="term_note">&lt;==这边列出左边(&lt;)文件被删除的那一行内容</span>
6c5    <span class="term_note">&lt;==左边文件的第六行被取代 (c) 成右边文件的第五行</span>
&lt; sync:x:5:0:sync:/sbin:/bin/sync  <span class="term_note">&lt;==左边(&lt;)文件第六行内容</span>
---
&gt; no six line                      <span class="term_note">&lt;==右边(&gt;)文件第五行内容</span>
<span class="term_say"># 很聪明吧！用 diff 就把我们刚刚的处理给比对完毕了！</span>
</pre></td></tr></tbody></table>

		<p>用 diff 比对文件真的是很简单喔！不过，你不要用 diff 去比对两个完全不相干的文件，因为比不出个啥咚咚！
		另外， diff 也可以比对整个目录下的差异喔！举例来说，我们想要了解一下不同的启动运行等级 (runlevel) 
		内容有啥不同？假设你已经知道运行等级 3 与 5 的启动脚本分别放置到 /etc/rc3.d 及 /etc/rc5.d ，
		则我们可以将两个目录比对一下：</p>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">diff /etc/rc3.d/ /etc/rc5.d/</span>
Only in /etc/rc3.d/: K99readahead_later
Only in /etc/rc5.d/: S96readahead_later
</pre></td></tr></tbody></table>

		<p>我们的 diff 很聪明吧！还可以比对不同目录下的相同档名的内容，这样真的很方便喔～<br><br></p>

		<a name="cmp"></a>
		<hr><ul class="list1"><li class="text_import1">cmp</li></ul>

		<p>相对於 diff 的广泛用途， cmp 似乎就用的没有这么多了～ cmp 主要也是在比对两个文件，他主要利用『位组』单位去比对，
		因此，当然也可以比对 binary file 罗～(还是要再提醒喔， diff 主要是以『行』为单位比对，
		cmp 则是以『位组』为单位去比对，这并不相同！)</p>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">cmp [-s] file1 file2</span>
<span class="term_say">选项与参数：
-s  ：将所有的不同点的位组处都列出来。因为 cmp 默认仅会输出第一个发现的不同点。</span>

<span class="term_hd">范例一：用 cmp 比较一下 passwd.old 及 passwd.new</span>
[root@www test]# <span class="term_command">cmp passwd.old passwd.new</span>
passwd.old passwd.new differ: byte 106, line 4
</pre></td></tr></tbody></table>

		<p>看到了吗？第一个发现的不同点在第四行，而且位组数是在第 106 个位组处！这个 cmp 也可以用来比对 binary 
		啦！ ^_^<br><br></p>

		<a name="patch"></a>
		<hr><ul class="list1"><li class="text_import1">patch</li></ul>

		<p>patch 这个命令与 diff 可是有密不可分的关系啊！我们前面提到，diff 可以用来分辨两个版本之间的差异，
		举例来说，刚刚我们所创建的 passwd.old 及 passwd.new 之间就是两个不同版本的文件。
		那么，如果要『升级』呢？就是『<span class="text_import2">将旧的文件升级成为新的文件</span>』时，应该要怎么做呢？
		其实也不难啦！就是『先比较先旧版本的差异，并将差异档制作成为补丁档，再由补丁档升级旧文件』即可。
		举例来说，我们可以这样做测试：</p>

<table class="term"><tbody><tr><td class="term"><pre><span class="term_hd">范例一：以 /tmp/test 内的 passwd.old 与 passwd.new  制作补丁文件</span>
[root@www test]# <span class="term_command">diff -Naur passwd.old passwd.new &gt; passwd.patch</span>
[root@www test]# <span class="term_command">cat passwd.patch</span>
--- passwd.old  2009-02-10 14:29:09.000000000 +0800 <span class="term_note">&lt;==新旧文件的资讯</span>
+++ passwd.new  2009-02-10 14:29:18.000000000 +0800
@@ -1,9 +1,8 @@   <span class="term_note">&lt;==新旧文件要修改数据的界定范围，旧档在 1-9 行，新档在 1-8 行</span>
 root:x:0:0:root:/root:/bin/bash
 bin:x:1:1:bin:/bin:/sbin/nologin
 daemon:x:2:2:daemon:/sbin:/sbin/nologin
-adm:x:3:4:adm:/var/adm:/sbin/nologin      <span class="term_note">&lt;==左侧文件删除</span>
 lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin
-sync:x:5:0:sync:/sbin:/bin/sync           <span class="term_note">&lt;==左侧文件删除</span>
+no six line                               <span class="term_note">&lt;==右侧新档加入</span>
 shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown
 halt:x:7:0:halt:/sbin:/sbin/halt
 mail:x:8:12:mail:/var/spool/mail:/sbin/nologin
</pre></td></tr></tbody></table>

		<p>一般来说，使用 diff 制作出来的比较文件通常使用扩展名为 .patch 罗。至於内容就如同上面介绍的样子。
		基本上就是以行为单位，看看哪边有一样与不一样的，找到一样的地方，然后将不一样的地方取代掉！
		以上面表格为例，新文件看到 - 会删除，看到 + 会加入！好了，那么如何将旧的文件升级成为新的内容呢？
		就是将 passwd.old 改成与 passwd.new 相同！可以这样做：</p>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">patch -pN &lt; patch_file   </span> <span class="term_note">&lt;==升级</span>
[root@www ~]# <span class="term_command">patch -R -pN &lt; patch_file</span> <span class="term_note">&lt;==还原</span>
<span class="term_say">选项与参数：
-p  ：后面可以接『取消几层目录』的意思。
-R  ：代表还原，将新的文件还原成原来旧的版本。</span>

<span class="term_hd">范例二：将刚刚制作出来的 patch file 用来升级旧版数据</span>
[root@www test]# <span class="term_command">patch -p0 &lt; passwd.patch</span>
patching file passwd.old
[root@www test]# <span class="term_command">ll passwd*</span>
-rw-r--r-- 1 root root <span class="term_write">1929</span> Feb 10 14:29 passwd.new
-rw-r--r-- 1 root root <span class="term_write">1929</span> Feb 10 15:12 passwd.old <span class="term_note">&lt;==文件一模一样！</span>

<span class="term_hd">范例三：恢复旧文件的内容</span>
[root@www test]# <span class="term_command">patch -R -p0 &lt; passwd.patch</span>
[root@www test]# <span class="term_command">ll passwd*</span>
-rw-r--r-- 1 root root 1929 Feb 10 14:29 passwd.new
-rw-r--r-- 1 root root <span class="term_write">1986</span> Feb 10 15:18 passwd.old
<span class="term_say"># 文件就这样恢复成为旧版本罗</span>
</pre></td></tr></tbody></table>

		<p>为什么这里会使用 -p0 呢？因为我们在比对新旧版的数据时是在同一个目录下，
		因此不需要减去目录啦！如果是使用整体目录比对 (diff 旧目录 新目录) 时，
		就得要依据创建 patch 文件所在目录来进行目录的删减罗！</p>

		<p>更详细的 patch 用法我们会在后续的第五篇的<a href="http://cn.linux.vbird.org/linux_basic/0520source_code_and_tarball.php#tarball_patch">原始码编译 (第二十二章)</a>再跟大家介绍，
		这里仅是介绍给你，我们可以利用 diff 来比对两个文件之间的差异，
		更可进一步利用这个功能来制作修补文件 (patch file) ，让大家更容易进行比对与升级呢！很不赖吧！ ^_^</p>
	</div>

	<hr><a name="pr"></a><img src="./鸟哥的 Linux 私房菜13 -- 正规表示法 (regular expression, RE) 与文件格式化处理_files/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">文件列印准备： pr</span><br>
	<div class="block2">
		<p>如果你曾经使用过一些图形介面的文书处理软件的话，那么很容易发现，当我们在列印的时候，
		可以同时选择与配置每一页列印时的标头吧！也可以配置页码呢！那么，如果我是在 Linux 底下列印纯文字档呢
		可不可以具有标题啊？可不可以加入页码啊？呵呵！当然可以啊！使用 pr 就能够达到这个功能了。不过， 
		pr 的参数实在太多了，鸟哥也说不完，一般来说，鸟哥都仅使用最简单的方式来处理而已。举例来说，如果想要列印 
		/etc/man.config 呢？</p>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">pr /etc/man.config</span>


<span class="term_write">2007-01-06 18:24                 /etc/man.config                  Page 1</span>


#
# Generated automatically from man.conf.in by the
# configure script.
<span class="term_say">.....以下省略......</span>
</pre></td></tr></tbody></table>

		<p>上面特殊字体那一行呢，其实就是使用 pr 处理后所造成的标题啦！标题中会有『文件时间』、『文件档名』及『页码』三大项目。
		更多的 pr 使用，请参考 pr 的说明啊！ ^_^</p>
	</div>
</div>


<hr><a name="hint"></a><img src="./鸟哥的 Linux 私房菜13 -- 正规表示法 (regular expression, RE) 与文件格式化处理_files/logo.png" alt="大标题的图示" width="35" align="middle" height="34"><span class="text_h1">重点回顾</span><br>
<div class="block1">
<ul class="text_import2">
	<li>正规表示法就是处理字串的方法，他是以行为单位来进行字串的处理行为；</li>
	<li>正规表示法透过一些特殊符号的辅助，可以让使用者轻易的达到『搜寻/删除/取代』某特定字串的处理程序；</li>
	<li>只要工具程序支持正规表示法，那么该工具程序就可以用来作为正规表示法的字串处理之用；</li>
	<li>正规表示法与万用字节是完全不一样的东西！万用字节 (wildcard) 代表的是 bash 操作介面的一个功能，
		但正规表示法则是一种字串处理的表示方式！</li>
	<li>使用 grep 或其他工具进行正规表示法的字串比对时，因为编码的问题会有不同的状态，因此，
 		你最好将 LANG 等变量配置为 C 或者是 en 等英文语系！</li>
	<li>grep 与 egrep 在正规表示法里面是很常见的两支程序，其中， egrep 支持更严谨的正规表示法的语法；</li>
	<li>由於编码系统的不同，不同的语系 (LANG) 会造成正规表示法撷取数据的差异。因此可利用特殊符号如 [:upper:] 
		来替代编码范围较佳；</li>
	<li>由於严谨度的不同，正规表示法之上还有更严谨的延伸正规表示法；</li>
	<li>基础正规表示法的特殊字符有： *, ?, [], [-], [^], ^, $ 等！</li>
	<li>常见的正规表示法工具有： grep , sed, vim 等等</li>
	<li>printf 可以透过一些特殊符号来将数据进行格式化输出；</li>
	<li>awk 可以使用『栏位』为依据，进行数据的重新整理与输出；</li>
	<li>文件的比对中，可利用 diff 及 cmp 进行比对，其中 diff 主要用在纯文字文件方面的新旧版本比对</li>
	<li>patch 命令可以将旧版数据升级到新版 (主要亦由 diff 创建 patch 的补丁来源文件)</li>
</ul>
</div>


<hr><a name="ex"></a><img src="./鸟哥的 Linux 私房菜13 -- 正规表示法 (regular expression, RE) 与文件格式化处理_files/logo.png" alt="大标题的图示" width="35" align="middle" height="34"><span class="text_h1">本章习题</span><br>
( 要看答案请将鼠标移动到『答：』底下的空白处，按下左键圈选空白处即可察看 )
<div class="block1">
<ul>
	<li>情境模拟题一：透过 grep 搜寻特殊字串，并配合数据流重导向来处理大量的文件搜寻问题。<br><br>
	<ul>
		<li>目标：正确的使用正规表示法；</li>
		<li>前提：需要了解数据流重导向，以及透过子命令 $(command) 来处理档名的搜寻；</li>
	</ul><br>

	我们简单的以搜寻星号 (*) 来处理底下的任务：<br><br>

	<ol style="padding-left: 0px;">
	<li>利用正规表示法找出系统中含有某些特殊关键字的文件，举例来说，找出在 /etc 底下含有星号 (*) 的文件与内容：<br><br>
	解决的方法必须要搭配万用字节，但是星号本身就是正规表示法的字符，因此需要如此进行：

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">grep '\*' /etc/*</span>
</pre></td></tr></tbody></table>

	你必须要注意的是，在单引号内的星号是正规表示法的字符，但我们要找的是星号，因此需要加上跳脱字符 (\)。但是在 
	/etc/* 的那个 * 则是 bash  的万用字节！
	代表的是文件的档名喔！不过由上述的这个结果中，我们仅能找到 /etc 底下第一层子目录的数据，无法找到次目录的数据，
	如果想要连同完整的 /etc 次目录数据，就得要这样做：

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">grep '\*' $(find /etc -type f)</span>
</pre></td></tr></tbody></table><br></li>

	<li>但如果文件数量太多呢？如同上述的案例，如果要找的是全系统 (/) 呢？你可以这样做：

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">grep '\*' $(find / -type f)</span>
-bash: /bin/grep: Argument list too long
</pre></td></tr></tbody></table>

	真要命！由於命令列的内容长度是有限制的，因此当搜寻的对象是整个系统时，上述的命令会发生错误。那该如何是好？
	此时我们可以透过管线命令以及 xargs 来处理。举例来说，让 grep 每次仅能处理 10 个档名，此时你可以这样想：<br><br>
	<ol type="a">
		<li>先用 find 去找出文件；</li>
		<li>用 xargs 将这些文件每次丢 10 个给 grep 来作为参数处理；</li>
		<li>grep 实际开始搜寻文件内容。</li>
	</ol><br>
	所以整个作法就会变成这样：

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">find / -type f | xargs -n 10 grep '\*'</span>
</pre></td></tr></tbody></table><br></li>

	<li>从输出的结果来看，数据量实在非常庞大！那如果我只是想要知道档名而已呢？你可以透过 grep 的功能来找到如下的参数！

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">find / -type f | xargs -n 10 grep -l '\*'</span>
</pre></td></tr></tbody></table><br></li>
	</ol></li>

	<li>情境模拟题二：使用管线命令配合正规表示法创建新命令与新变量。我想要创建一个新的命令名为 myip ，
	这个命令能够将我系统的 IP 捉出来显示。而我想要有个新变量，变量名为 MYIP ，这个变量可以记录我的 IP 。<br><br>

	处理的方式很简单，我们可以这样试看看：<br><br>

	<ol style="padding-left: 0px;">
		<li>首先，我们依据本章内的 ifconfig, sed 与 awk 来取得我们的 IP ，命令为：<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">ifconfig eth0 | grep 'inet addr' | \</span>
&gt;  <span class="term_command">sed 's/^.*inet addr://g'| cut -d ' ' -f1</span>
</pre></td></tr></tbody></table></li>

		<li>再来，我们可以将此命令利用 alias 指定为 myip 喔！如下所示：

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">alias myip="ifconfig eth0 | grep 'inet addr' | \</span>
&gt;  <span class="term_command">sed 's/^.*inet addr://g'| cut -d ' ' -f1 "</span>
</pre></td></tr></tbody></table></li>

		<li>最终，我们可以透过变量配置来处理 MYIP 喔！

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">MYIP=$( myip )</span>
</pre></td></tr></tbody></table></li>

		<li>如果每次登陆都要生效，可以将 alias 与 MYIP 的配置那两行，写入你的 ~/.bashrc 即可！</li>
	</ol></li>
</ul><br>

<hr>简答题部分：
<ul>
	<li>我想要知道，在 /etc 底下，只要含有 XYZ 三个字节的任何一个字节的那一行就列出来，要怎样进行？
	<div class="blockex">
		grep [XYZ] /etc/*
	</div></li>

	<li>将 /etc/termcap 内容取出后，(1)去除开头为 # 的行 (2)去除空白行 (3)取出开头为英文字母的那几行 (4)最终统计总行数该如何进行？
	<div class="blockex">
		grep -v '^#' /etc/termcap | grep -v '^$' | grep '^[[:alpha:]]' | wc -l
	</div></li>
</ul>
</div>


<hr><a name="reference"></a><img src="./鸟哥的 Linux 私房菜13 -- 正规表示法 (regular expression, RE) 与文件格式化处理_files/logo.png" alt="大标题的图示" width="35" align="middle" height="34"><span class="text_h1">参考数据与延伸阅读</span><br>
<div class="block1">
<ul>
	<li><a name="ps1"></a>注1：关於正规表示法与 POSIX 及特殊语法的参考网址可以查询底下的来源：<br>
		维基百科的说明：<a href="http://en.wikipedia.org/wiki/Regular_expression" target="_blank">http://en.wikipedia.org/wiki/Regular_expression</a><br>
		ZYTRAX 网站介绍：<a href="http://zytrax.com/tech/web/regex.htm" target="_blank">http://zytrax.com/tech/web/regex.htm</a><br></li>
	<li><a name="ps2"></a>注2：其他关於正规表示法的网站介绍：<br>
		洪朝贵老师的网页：<a href="http://www.cyut.edu.tw/~ckhung/b/re/index.php" target="_blank">http://www.cyut.edu.tw/~ckhung/b/re/index.php</a><br>
		龙门少尉的窝：<a href="http://main.rtfiber.com.tw/~changyj/" target="_blank">http://main.rtfiber.com.tw/~changyj/</a><br>
		PCRE 官方网站：<a href="http://perldoc.perl.org/perlre.html" target="_blank">http://perldoc.perl.org/perlre.html</a><br></li>
	<li><a name="ps3"></a>注3：关於 ASCII 编码对照表可参考维基百科的介绍：<br>
		维基百科 (ASCII) 条目： <a href="http://zh.wikipedia.org/w/index.php?title=ASCII&amp;variant=zh-tw" target="_blank">http://zh.wikipedia.org/w/index.php?title=ASCII&amp;variant=zh-tw</a></li>
	<li><a name="ps4"></a>注4：关於 awk 的进阶文献，包括有底下几个连结：<br>
		中研院计算中心 ASPAC 计画之 awk 程序介绍：<a href="http://phi.sinica.edu.tw/aspac/reports/94/94011/" target="_blank">http://phi.sinica.edu.tw/aspac/reports/94/94011/</a><br>
		鸟哥备份：<a href="http://cn.linux.vbird.org/linux_basic/0330regularex/awk.pdf" target="_blank">http://cn.linux.vbird.org/linux_basic/0330regularex/awk.pdf</a><br>
		这份文件写的非常棒！欢迎大家多多参考！<br>
		Study Area：<a href="http://www.study-area.org/linux/system/linux_shell.htm" target="_blank">http://www.study-area.org/linux/system/linux_shell.htm</a></li>
</ul>
</div>


<hr><span class="text_history">
2002/07/29：第一次完成；<br>
2003/02/10：重新编排与加入 FAQ ；<br>
2005/01/28：重新汇整基础正规表示法的内容！重点在 regular_express.txt 的处理与练习上！<br>
2005/03/30：修订了 grep -n 'goo*g' regular_express.txt 这一段<br>
2005/05/23：修订了 grep -n '^[a-z]' regular_express.txt 所要撷取的是小写，之前写成大写，错了！<br>
2005/08/22：加入了 awk, sed 等工具的介绍，还有 diff 与 cmp 等命令的说明！<br>
2005/09/05：加入 printf 内，关於 \xNN 的说明！<br>
2006/03/10：将原本的 sed 内的动作(action)中， s 由『搜寻』改成『取代』了！<br>
2006/10/05：在 sed 当中多了一个 -i 的参数说明，也多了一个范例八可以参考。感谢讨论区的thyme兄！<br>
2008/10/08：加入 grep 内的 --color=auto 说明！<br>
2009/02/07：将旧的基於 FC4 版本的文章移动到<a href="http://cn.linux.vbird.org/linux_basic/0330regularex/0330regularex-fc4.php">此处</a><br>
2009/02/10：重新排版，并且加入<a href="http://cn.linux.vbird.org/linux_basic/0330regularex.php#lang">语系</a>的说明，以及特殊 [:数据:] 的说明！更改不少范例的说明。<br>
2009/05/14：感谢网友 Jack 的回报， cmp 应该是使用『位组 bytes』而非位 bits，感谢 Jack 兄。<br>
2009/08/26：加入情境模拟题目了！<br>
2010/04/16：由<a href="http://phorum.vbird.org/viewtopic.php?f=10&amp;t=33387&amp;p=144272#p144272">linux_task</a>兄提供的意见，
	将<a href="http://cn.linux.vbird.org/linux_basic/0330regularex.php#20100416">原本的 * 说明订正</a>一些部分，可读性较佳！感谢您！<hr>
</span>
    </td>
    <td style="width: 16px; font-size: 6px;">　</td></tr>
<tr><td style="width: 16px; height: 16px;">　</td>
    <td style="width: 866px; height: 16px;">　</td>
    <td style="width: 16px; height: 16px;">　</td></tr>
</tbody></table>

<div style="padding-top: 0px; text-align: center;">
<span style="font-size: 80%;">
	<a href="http://linux.vbird.org/" target="_top" title="前往鸟哥的首页">http://linux.vbird.org</a>
	is designed by <a href="mailto:vbird@mail.vbird.idv.tw" title="联络鸟哥(我不要广告信！)">VBird</a>
		during 2001-2011. <a href="http://www.ksu.edu.tw/" target="_blank">ksu.edu</a></span>
         ﻿<div id="apDiv4">
      <p>本网页主要以Firefox配合解析度 1024x768 作为设计依据&nbsp;&nbsp;&nbsp;&nbsp; 鸟哥自由软件整合应用研究室</p></div></div>
</div>
</center>

</body></html>