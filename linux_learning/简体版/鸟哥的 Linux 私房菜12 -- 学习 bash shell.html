
<!-- saved from url=(0050)http://cn.linux.vbird.org/linux_basic/0320bash.php -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
	
	<meta name="Author" content="2011/04/18,white">
	<meta name="Description" content="学习 bash shell">
	<title>鸟哥的 Linux 私房菜 -- 学习 bash shell</title>
    <script src="./鸟哥的 Linux 私房菜12 -- 学习 bash shell_files/SpryMenuBar.js" type="text/javascript"></script>
	<script src="./鸟哥的 Linux 私房菜12 -- 学习 bash shell_files/index.js" type="text/javascript"></script>
	<link href="./鸟哥的 Linux 私房菜12 -- 学习 bash shell_files/SpryMenuBarHorizontal.css" rel="stylesheet" type="text/css">
    <link href="./鸟哥的 Linux 私房菜12 -- 学习 bash shell_files/main.css" rel="stylesheet" type="text/css">
    </head><body style="margin: 0pt; padding: 0pt;" class="table" onload="MM_preloadImages(&#39;image/title_19.png&#39;,&#39;image/title_26.png&#39;,&#39;image/title_27.png&#39;,&#39;image/title_28.png&#39;,&#39;image/title_06.png&#39;,&#39;image/title_08.png&#39;,&#39;image/title_10.png&#39;,&#39;image/title_12.png&#39;)">

<center>
<div id="apDiv5">
<div> <link rel="SHORTCUT ICON" href="http://cn.linux.vbird.org/linux_basic/favicon.ico">
<!-- ImageReady Slices (title3.ai) -->
<table id="___01" width="898" height="81" border="0" align="center" cellpadding="0" cellspacing="0" ;="">
	<tbody><tr>
		<td colspan="15">
			<img src="./鸟哥的 Linux 私房菜12 -- 学习 bash shell_files/title_01.png" width="900" height="1" alt=""></td>
	</tr>
	<tr>
		<td rowspan="4" bgcolor="#182448"><p><img src="./鸟哥的 Linux 私房菜12 -- 学习 bash shell_files/Count.cgi" width="93" align="left" title="計數器"></p>
	    <p><font color="#FFFFFF" size="-1">since2012/04/23</font></p></td>
		<td rowspan="4" align="left" valign="top"><a href="http://cn.linux.vbird.org/"><img src="./鸟哥的 Linux 私房菜12 -- 学习 bash shell_files/title_03.png" alt="" width="263" height="79" border="0"></a></td>
		<td colspan="13">
			<img src="./鸟哥的 Linux 私房菜12 -- 学习 bash shell_files/title_04.png" alt="" width="535" height="9" border="0"></td>
	</tr>
	<tr>
		<td rowspan="3">
			<img src="./鸟哥的 Linux 私房菜12 -- 学习 bash shell_files/title_05.png" alt="" width="53" height="70" border="0"></td>
		<td colspan="2" align="left" valign="top"><a href="http://cn.linux.vbird.org/linux_basic/0110whatislinux.php" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage(&#39;Image51&#39;,&#39;&#39;,&#39;image/title/title_06.png&#39;,1)"><img src="./鸟哥的 Linux 私房菜12 -- 学习 bash shell_files/title3_06.png" name="Image51" width="106" height="25" border="0" id="Image51" alt=""></a></td>
		<td rowspan="2">
			<img src="./鸟哥的 Linux 私房菜12 -- 学习 bash shell_files/title_07.png" alt="" width="27" height="37" border="0"></td>
		<td colspan="3" align="left" valign="top"><a href="http://cn.linux.vbird.org/linux_server/0110network_basic.php" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage(&#39;Image52&#39;,&#39;&#39;,&#39;image/title/title_08.png&#39;,1)"><img src="./鸟哥的 Linux 私房菜12 -- 学习 bash shell_files/title3_08.png" name="Image52" width="107" height="25" border="0" id="Image52" alt=""></a></td>
		<td rowspan="2">
			<img src="./鸟哥的 Linux 私房菜12 -- 学习 bash shell_files/title_09.png" alt="" width="37" height="37" border="0"></td>
		<td colspan="2" align="left" valign="top"><a href="http://cn.linux.vbird.org/about.php" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage(&#39;Image53&#39;,&#39;&#39;,&#39;image/title/title_10.png&#39;,1)"><img src="./鸟哥的 Linux 私房菜12 -- 学习 bash shell_files/title3_10.png" name="Image53" width="75" height="25" border="0" id="Image53" alt=""></a></td>
		<td rowspan="3">
			<img src="./鸟哥的 Linux 私房菜12 -- 学习 bash shell_files/title_11.png" alt="" width="35" height="70" border="0"></td>
		<td align="left" valign="top"><a href="mailto:vbird@mail.vbird.idv.tw" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage(&#39;Image54&#39;,&#39;&#39;,&#39;image/title/title_12.png&#39;,1)"><img src="./鸟哥的 Linux 私房菜12 -- 学习 bash shell_files/title3_12.png" name="Image54" width="74" height="25" border="0" id="Image54" alt=""></a></td>
		<td rowspan="3">
			<img src="./鸟哥的 Linux 私房菜12 -- 学习 bash shell_files/title_13.png" alt="" width="21" height="70" border="0"></td>
	</tr>
	<tr>
		<td colspan="2">
			<img src="./鸟哥的 Linux 私房菜12 -- 学习 bash shell_files/title_14.png" alt="" width="106" height="12" border="0"></td>
		<td colspan="3">
			<img src="./鸟哥的 Linux 私房菜12 -- 学习 bash shell_files/title_15.png" alt="" width="107" height="12" border="0"></td>
		<td colspan="2">
			<img src="./鸟哥的 Linux 私房菜12 -- 学习 bash shell_files/title_16.png" width="75" height="12" alt=""></td>
		<td rowspan="2">
			<img src="./鸟哥的 Linux 私房菜12 -- 学习 bash shell_files/title_17.png" alt="" width="74" height="45" border="0"></td>
	</tr>
	<tr>
		<td>
			<img src="./鸟哥的 Linux 私房菜12 -- 学习 bash shell_files/title_18.png" alt="" width="15" height="33" border="0"></td>
		<td colspan="3" align="left" valign="top"><ul id="MenuBar1" class="MenuBarHorizontal">
	  <li><a href="http://cn.linux.vbird.org/linux_basic/linux_basic.php" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage(&#39;Image44&#39;,&#39;&#39;,&#39;image/title/title_19.png&#39;,1)" class="MenuBarItemSubmenu"><img src="./鸟哥的 Linux 私房菜12 -- 学习 bash shell_files/title3_19.png" name="Image44" width="123" height="33" border="0" id="Image44"></a>
			    <ul>
			      <li><a href="http://cn.linux.vbird.org/linux_basic/Mandrake9.0/mandrake9.0.php" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage(&#39;Image46&#39;,&#39;&#39;,&#39;image/title/title_26.png&#39;,1)"><img src="./鸟哥的 Linux 私房菜12 -- 学习 bash shell_files/title_23.png" name="Image46" width="120" height="26" border="0" id="Image46" alt=""></a></li>
                  <li><a href="http://cn.linux.vbird.org/linux_basic/fedora_4/fc4.php" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage(&#39;Image47&#39;,&#39;&#39;,&#39;image/title/title_27.png&#39;,1)"><img src="./鸟哥的 Linux 私房菜12 -- 学习 bash shell_files/title_24.png" name="Image47" width="120" height="26" border="0" id="Image47" alt=""></a></li>
                  <li><a href="http://cn.linux.vbird.org/linux_basic/linux_basic.php" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage(&#39;Image48&#39;,&#39;&#39;,&#39;image/title/title_28.png&#39;,1)"><img src="./鸟哥的 Linux 私房菜12 -- 学习 bash shell_files/title_25.png" name="Image48" width="120" height="26" border="0" id="Image48" alt=""></a></li>
                </ul>
		      </li>
		</ul></td>
		<td>
			<img src="./鸟哥的 Linux 私房菜12 -- 学习 bash shell_files/title_20.png" alt="" width="42" height="33" border="0"></td>
		<td colspan="3" align="left" valign="top"><ul id="MenuBar2" class="MenuBarHorizontal">
	  <li><a href="http://cn.linux.vbird.org/linux_server/" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage(&#39;Image45&#39;,&#39;&#39;,&#39;image/title/title_21.png&#39;,1)" class="MenuBarItemSubmenu"><img src="./鸟哥的 Linux 私房菜12 -- 学习 bash shell_files/title3_21.png" name="Image45" width="125" height="33" border="0" id="Image45"></a>
			    <ul>
			      <li><a href="http://cn.linux.vbird.org/linux_server/linux_redhat9/redhat9.php" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage(&#39;Image43&#39;,&#39;&#39;,&#39;image/title/title_26.png&#39;,1)"><img src="./鸟哥的 Linux 私房菜12 -- 学习 bash shell_files/title_23.png" name="Image43" width="120" height="26" border="0" id="Image43" alt=""></a></li>
			      <li><a href="http://cn.linux.vbird.org/linux_server/centos4.php" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage(&#39;Image49&#39;,&#39;&#39;,&#39;image/title/title_27.png&#39;,1)"><img src="./鸟哥的 Linux 私房菜12 -- 学习 bash shell_files/title_24.png" name="Image49" width="120" height="26" border="0" id="Image49" alt=""></a></li>
			      <li><a href="http://cn.linux.vbird.org/linux_server/" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage(&#39;Image50&#39;,&#39;&#39;,&#39;image/title/title_28.png&#39;,1)"><img src="./鸟哥的 Linux 私房菜12 -- 学习 bash shell_files/title_25.png" name="Image50" width="120" height="26" border="0" id="Image50" alt=""></a></li>
		        </ul>
		      </li>
		</ul></td>
		<td>
			<img src="./鸟哥的 Linux 私房菜12 -- 学习 bash shell_files/title_22.png" alt="" width="47" height="33" border="0"></td>
	</tr>
	<tr>
		<td>
			<img src="./鸟哥的 Linux 私房菜12 -- 学习 bash shell_files/Spacer.gif" width="101" height="1" alt=""></td>
		<td>
			<img src="./鸟哥的 Linux 私房菜12 -- 学习 bash shell_files/Spacer.gif" width="263" height="1" alt=""></td>
		<td>
			<img src="./鸟哥的 Linux 私房菜12 -- 学习 bash shell_files/Spacer.gif" width="53" height="1" alt=""></td>
		<td>
			<img src="./鸟哥的 Linux 私房菜12 -- 学习 bash shell_files/Spacer.gif" width="15" height="1" alt=""></td>
		<td>
			<img src="./鸟哥的 Linux 私房菜12 -- 学习 bash shell_files/Spacer.gif" width="91" height="1" alt=""></td>
		<td>
			<img src="./鸟哥的 Linux 私房菜12 -- 学习 bash shell_files/Spacer.gif" width="27" height="1" alt=""></td>
		<td>
			<img src="./鸟哥的 Linux 私房菜12 -- 学习 bash shell_files/Spacer.gif" width="5" height="1" alt=""></td>
		<td>
			<img src="./鸟哥的 Linux 私房菜12 -- 学习 bash shell_files/Spacer.gif" width="42" height="1" alt=""></td>
		<td>
			<img src="./鸟哥的 Linux 私房菜12 -- 学习 bash shell_files/Spacer.gif" width="60" height="1" alt=""></td>
		<td>
			<img src="./鸟哥的 Linux 私房菜12 -- 学习 bash shell_files/Spacer.gif" width="37" height="1" alt=""></td>
		<td>
			<img src="./鸟哥的 Linux 私房菜12 -- 学习 bash shell_files/Spacer.gif" width="28" height="1" alt=""></td>
		<td>
			<img src="./鸟哥的 Linux 私房菜12 -- 学习 bash shell_files/Spacer.gif" width="47" height="1" alt=""></td>
		<td>
			<img src="./鸟哥的 Linux 私房菜12 -- 学习 bash shell_files/Spacer.gif" width="35" height="1" alt=""></td>
		<td>
			<img src="./鸟哥的 Linux 私房菜12 -- 学习 bash shell_files/Spacer.gif" width="74" height="1" alt=""></td>
		<td>
			<img src="./鸟哥的 Linux 私房菜12 -- 学习 bash shell_files/Spacer.gif" width="22" height="1" alt=""></td>
	</tr>
</tbody></table>
<!-- End ImageReady Slices -->
<script type="text/javascript">
<!--
var MenuBar1 = new Spry.Widget.MenuBar("MenuBar1", {imgDown:"SpryAssets/SpryMenuBarDownHover.gif", imgRight:"SpryAssets/SpryMenuBarRightHover.gif"});
var MenuBar2 = new Spry.Widget.MenuBar("MenuBar2", {imgDown:"SpryAssets/SpryMenuBarDownHover.gif", imgRight:"SpryAssets/SpryMenuBarRightHover.gif"});
//-->
</script>
</div>
<table summary="本文内容的排版" style="width: 898px;" border="0" cellpadding="0" cellspacing="0">
<tbody><tr><td style="width: 16px; height: 16px;">　</td>
    <td style="width: 866px; height: 16px;">　</td>
    <td style="width: 16px; height: 16px;">　</td></tr>
<tr><td style="width: 16px; font-size: 6px;">　</td>
    <td width="866">
<!-- 本文的档头部分 -->
<div style="text-align: center;">
    <a href="http://cn.linux.vbird.org/linux_basic/0320bash.php">
    <span class="text_head0">第十一章、认识与学习<span class="text_head_en"> BASH </span></span></a><br>
</div>
    <div style="text-align: right;">
        <span class="text_history">最近升级日期：2009/08/25</span>
    </div>


<!-- 本文的档头部分 -->
<center><table class="head1" summary="排版：文章档头的说明"><tbody><tr><td class="head1">
	在 Linux 的环境下，如果你不懂 bash 是什么，那么其他的东西就不用学了！因为前面几章我们使用终端机下达命令的方式，
	就是透过 bash 的环境来处理的喔！所以说，他很重要吧！bash 的东西非常的多，包括变量的配置与使用、
	bash 操作环境的建置、数据流重导向的功能，还有那好用的管线命令！好好清一清脑门，准备用功去啰～ ^_^
	这个章节几乎是所有命令列模式 (command line) 与未来主机维护与管理的重要基础，一定要好好仔细的阅读喔！
</td></tr></tbody></table></center><br>

<!-- 本文的连结区部分 -->
<div class="block1">
<span class="text_h1">
1. <a href="http://cn.linux.vbird.org/linux_basic/0320bash.php#bash">认识 BASH 这个 Shell</a><br>
	<span class="text_h2">
	　　1.1 <a href="http://cn.linux.vbird.org/linux_basic/0320bash.php#bash_what">硬件、核心与 Shell</a><br>
	　　1.2 <a href="http://cn.linux.vbird.org/linux_basic/0320bash.php#bash_why">为何要学文字接口的 shell</a><br>
	　　1.3 <a href="http://cn.linux.vbird.org/linux_basic/0320bash.php#bash_shells">系统的合法 shell 与 /etc/shells 功能</a><br>
	　　1.4 <a href="http://cn.linux.vbird.org/linux_basic/0320bash.php#bash_bash">Bash shell 的功能</a><br>
	　　1.5 <a href="http://cn.linux.vbird.org/linux_basic/0320bash.php#bash_type">Bash shell 的内建命令： type</a><br>
	　　1.6 <a href="http://cn.linux.vbird.org/linux_basic/0320bash.php#bash_command">命令的下达</a><br>
	</span>
2. <a href="http://cn.linux.vbird.org/linux_basic/0320bash.php#variable">Shell 的变量功能</a><br>
	<span class="text_h2">
	　　2.1 <a href="http://cn.linux.vbird.org/linux_basic/0320bash.php#variable_var">什么是变量？</a><br>
	　　2.2 <a href="http://cn.linux.vbird.org/linux_basic/0320bash.php#variable_echo">变量的取用与配置</a>：<a href="http://cn.linux.vbird.org/linux_basic/0320bash.php#echo">echo</a>, 
		<a href="http://cn.linux.vbird.org/linux_basic/0320bash.php#variable_rule">变量配置守则</a>, <a href="http://cn.linux.vbird.org/linux_basic/0320bash.php#unset">unset</a><br>
	　　2.3 <a href="http://cn.linux.vbird.org/linux_basic/0320bash.php#variable_environ">环境变量的功能</a>：
		<a href="http://cn.linux.vbird.org/linux_basic/0320bash.php#env">env 与常见环境变量说明</a>, 
		<a href="http://cn.linux.vbird.org/linux_basic/0320bash.php#set">set</a>, <a href="http://cn.linux.vbird.org/linux_basic/0320bash.php#export">export</a><br>
	　　2.4 <a href="http://cn.linux.vbird.org/linux_basic/0320bash.php#variable_locale">影响显示结果的语系变量 (locale)</a><br>
	　　2.5 <a href="http://cn.linux.vbird.org/linux_basic/0320bash.php#variable_range">变量的有效范围</a>：<br>
	　　2.6 <a href="http://cn.linux.vbird.org/linux_basic/0320bash.php#variable_read">变量键盘读取、数组与宣告</a>： <a href="http://cn.linux.vbird.org/linux_basic/0320bash.php#read">read</a>, 
		<a href="http://cn.linux.vbird.org/linux_basic/0320bash.php#declare">declare</a>, <a href="http://cn.linux.vbird.org/linux_basic/0320bash.php#array">array</a><br>
	　　2.7 <a href="http://cn.linux.vbird.org/linux_basic/0320bash.php#variable_ulimit">与文件系统及程序的限制关系： ulimit</a><br>
	　　2.8 <a href="http://cn.linux.vbird.org/linux_basic/0320bash.php#variable_other">变量内容的删除、取代与替换：</a>, 
		<a href="http://cn.linux.vbird.org/linux_basic/0320bash.php#variable_other_replace">删除与取代</a>,
		<a href="http://cn.linux.vbird.org/linux_basic/0320bash.php#variable_other_re">测试与替换</a><br>
	</span>
3. <a href="http://cn.linux.vbird.org/linux_basic/0320bash.php#alias_history">命令别名与历史命令</a><br>
	<span class="text_h2">
	　　3.1 <a href="http://cn.linux.vbird.org/linux_basic/0320bash.php#alias">命令别名配置： alias, unalias</a><br>
	　　3.2 <a href="http://cn.linux.vbird.org/linux_basic/0320bash.php#history">历史命令： history, HISTSIZE</a><br>
	</span>
4. <a href="http://cn.linux.vbird.org/linux_basic/0320bash.php#settings">Bash shell 的操作环境</a><br>
	<span class="text_h2">
	　　4.1 <a href="http://cn.linux.vbird.org/linux_basic/0320bash.php#settings_path">路径与命令搜寻顺序</a><br>
	　　4.2 <a href="http://cn.linux.vbird.org/linux_basic/0320bash.php#settings_issue">bash 的进站与欢迎信息： /etc/issue, /etc/motd</a><br>
	　　4.3 <a href="http://cn.linux.vbird.org/linux_basic/0320bash.php#settings_bashrc">环境配置文件:</a>
		<a href="http://cn.linux.vbird.org/linux_basic/0320bash.php#settings_bashrc_shell">login, non-login shell</a>, 
		<a href="http://cn.linux.vbird.org/linux_basic/0320bash.php#settings_bashrc_profile">/etc/profile</a>, 
		<a href="http://cn.linux.vbird.org/linux_basic/0320bash.php#settings_bashrc_bash_profile">~/.bash_profile</a>, 
		<a href="http://cn.linux.vbird.org/linux_basic/0320bash.php#source">source</a>, 
		<a href="http://cn.linux.vbird.org/linux_basic/0320bash.php#settings_bashrc_bashrc">~/.bashrc</a><br>
	　　4.4 <a href="http://cn.linux.vbird.org/linux_basic/0320bash.php#settings_set">终端机的环境配置： stty, set</a><br>
	　　4.5 <a href="http://cn.linux.vbird.org/linux_basic/0320bash.php#settings_wildcard">通配符与特殊符号</a><br>
	</span>
5. <a href="http://cn.linux.vbird.org/linux_basic/0320bash.php#redirect">数据流重导向 (Redirection)</a><br>
	<span class="text_h2">
	　　5.1 <a href="http://cn.linux.vbird.org/linux_basic/0320bash.php#redirect_redirect">何谓数据流重导向？</a><br>
	　　5.2 <a href="http://cn.linux.vbird.org/linux_basic/0320bash.php#redirect_com">命令运行的判断依据： ; , &amp;&amp;, ||</a><br>
	</span>
6. <a href="http://cn.linux.vbird.org/linux_basic/0320bash.php#pipe">管线命令 (pipe)</a><br>
	<span class="text_h2">
	　　6.1 <a href="http://cn.linux.vbird.org/linux_basic/0320bash.php#pipe_1">撷取命令：</a> <a href="http://cn.linux.vbird.org/linux_basic/0320bash.php#cut">cut</a>, <a href="http://cn.linux.vbird.org/linux_basic/0320bash.php#grep">grep</a><br>
	　　6.2 <a href="http://cn.linux.vbird.org/linux_basic/0320bash.php#pipe_2">排序命令：</a> <a href="http://cn.linux.vbird.org/linux_basic/0320bash.php#sort">sort</a>, <a href="http://cn.linux.vbird.org/linux_basic/0320bash.php#uniq">uniq</a>, 
		<a href="http://cn.linux.vbird.org/linux_basic/0320bash.php#wc">wc</a><br>
	　　6.3 <a href="http://cn.linux.vbird.org/linux_basic/0320bash.php#pipe_3">双向重导向：</a> <a href="http://cn.linux.vbird.org/linux_basic/0320bash.php#tee">tee</a><br>
	　　6.4 <a href="http://cn.linux.vbird.org/linux_basic/0320bash.php#pipe_4">字符转换命令：</a> <a href="http://cn.linux.vbird.org/linux_basic/0320bash.php#tr">tr</a>, <a href="http://cn.linux.vbird.org/linux_basic/0320bash.php#col">col</a>, 
		<a href="http://cn.linux.vbird.org/linux_basic/0320bash.php#join">join</a>, <a href="http://cn.linux.vbird.org/linux_basic/0320bash.php#paste">paste</a>, <a href="http://cn.linux.vbird.org/linux_basic/0320bash.php#expand">expand</a><br>
	　　6.5 <a href="http://cn.linux.vbird.org/linux_basic/0320bash.php#split">分割命令： split</a><br>
	　　6.6 <a href="http://cn.linux.vbird.org/linux_basic/0320bash.php#xargs">参数代换： xargs</a><br>
	　　6.7 <a href="http://cn.linux.vbird.org/linux_basic/0320bash.php#pipe_7">关于减号 - 的用途</a><br>
	</span>
7. <a href="http://cn.linux.vbird.org/linux_basic/0320bash.php#hint">重点回顾</a><br>
8. <a href="http://cn.linux.vbird.org/linux_basic/0320bash.php#ex">本章习题</a><br>
9. <a href="http://cn.linux.vbird.org/linux_basic/0320bash.php#reference">参考数据与延伸阅读</a><br>
<span class="text_h2">
10. <a href="http://phorum.vbird.org/viewtopic.php?t=23884" target="_blank">针对本文的建议：http://phorum.vbird.org/viewtopic.php?t=23884</a>
</span>
</span>
</div>


<!-- 本文的正式部分 -->
<hr><a name="bash"></a><img src="./鸟哥的 Linux 私房菜12 -- 学习 bash shell_files/logo.png" alt="大标题的图示" width="35" align="middle" height="34"><span class="text_h1">认识 BASH 这个 Shell</span><br>
<div class="block1">
	<p>我们在<a href="http://cn.linux.vbird.org/linux_basic/0110whatislinux.php">第一章 Linux 是什么</a>当中提到了：
	管理整个计算机硬件的其实是操作系统的核心 (kernel)，这个核心是需要被保护的！
	所以我们一般使用者就只能透过 shell 来跟核心沟通，以让核心达到我们所想要达到的工作。
	那么系统有多少 shell 可用呢？为什么我们要使用 bash 啊？底下分别来谈一谈喔！<br><br></p>

	<hr><a name="bash_what"></a><img src="./鸟哥的 Linux 私房菜12 -- 学习 bash shell_files/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">硬件、核心与 Shell</span><br>
	<div class="block2">
		<p>这应该是个蛮有趣的话题：『<span class="text_import2">什么是 Shell</span>
		』？相信只要摸过计算机，对于操作系统 (不论是 Linux 、 Unix 或者是 Windows) 
		有点概念的朋友们大多听过这个名词，因为只要有『操作系统』那么就离不开
		Shell 这个东西。不过，在讨论 Shell 之前，我们先来了解一下计算机的运行状况吧！
		举个例子来说：<span class="text_import2">当你要计算机传输出来『音乐』的时候，你的计算机需要什么东西呢</span>？</p>

		<ol>
		<li>硬件：当然就是需要你的硬件有『声卡芯片』这个配备，否则怎么会有声音；</li>
		<li>核心管理：操作系统的核心可以支持这个芯片组，当然还需要提供芯片的驱动程序啰；</li>
		<li>应用程序：需要使用者 (就是你) 输入发生声音的命令啰！</li>
		</ol>

		<p>这就是基本的一个输出声音所需要的步骤！也就是说，你必须要『输入』一个命令之后，
		『硬件』才会透过你下达的命令来工作！那么硬件如何知道你下达的命令呢？那就是
		kernel (核心) 的控制工作了！也就是说，<span class="text_import2">我们必须要透过『
		Shell 』将我们输入的命令与 Kernel 沟通，好让 Kernel 可以控制硬件来正确无误的工作</span>！
		基本上，我们可以透过底下这张图来说明一下：</p>

		<center><img src="./鸟哥的 Linux 私房菜12 -- 学习 bash shell_files/0320bash_1.jpg" alt="硬件、核心与用户的相关性图标" title="硬件、核心与用户的相关性图示" border="0"><br>
		图 1.1.1、硬件、核心与用户的相关性图示<br></center>

		<p>我们在<a href="http://cn.linux.vbird.org/linux_basic/0105computers.php#program_os">第零章内的操作系统小节</a>曾经提到过，
		<span class="text_import2">操作系统其实是一组软件，由于这组软件在控制整个硬件与管理系统的活动监测，
		如果这组软件能被用户随意的操作，若使用者应用不当，将会使得整个系统崩溃</span>！因为操作系统管理的就是整个硬件功能嘛！
		所以当然不能够随便被一些没有管理能力的终端用户随意使用啰！</p>

		<p>但是我们总是需要让用户操作系统的，所以就有了在操作系统上面发展的应用程序啦！用户可以透过应用程序来指挥核心，
		让核心达成我们所需要的硬件任务！如果考虑如<a href="http://cn.linux.vbird.org/linux_basic/0105computers/os_01.gif" target="_blank">第零章所提供的操作系统图标(图4.2.1)</a>，
		我们可以发现应用程序其实是在最外层，就如同鸡蛋的外壳一样，因此这个咚咚也就被称呼为壳程序 (shell) 啰！</p>

		<p>其实壳程序的功能只是提供用户操作系统的一个接口，因此这个壳程序需要可以呼叫其他软件才好。
		我们在第五章到第十章提到过很多命令，包括 man, chmod, chown, vi, fdisk, mkfs 等等命令，这些命令都是独立的应用程序，
		但是我们可以透过壳程序 (就是命令列模式) 来操作这些应用程序，让这些应用程序呼叫核心来运行所需的工作哩！
		这样对于壳程序是否有了一定的概念了？</p>

		<div style="padding: 10pt 0pt;" align="right"><table width="90%"><tbody><tr><td><b>Tips:</b><br><span style="color: rgb(0, 144, 0);"><font size="-1">		也就是说，只要能够操作应用程序的接口都能够称为壳程序。狭义的壳程序指的是命令列方面的软件，包括本章要介绍的 bash 等。
		广义的壳程序则包括图形接口的软件！因为图形接口其实也能够操作各种应用程序来呼叫核心工作啊！
		不过在本章中，我们主要还是在使用 bash 啦！
		</font></span></td><td><img src="./鸟哥的 Linux 私房菜12 -- 学习 bash shell_files/vbird_face.gif" alt="鸟哥的图示" title="鸟哥的图示"></td></tr></tbody></table></div>	</div>

	<hr><a name="bash_why"></a><img src="./鸟哥的 Linux 私房菜12 -- 学习 bash shell_files/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">为何要学文字接口的 shell？</span><br>
	<div class="block2">
		<p><span class="text_import2">文字接口的 shell 是很不好学的，但是学了之后好处多多</span>！所以，
		在这里鸟哥要先对您进行一些心理建设，先来了解一下为啥学习 shell 是有好处的，这样你才会有信心继续玩下去 ^_^
		<br><br></p>

		<hr><ul class="list1"><li class="text_import1">文字接口的 shell：大家都一样！</li></ul>

		<p>鸟哥常常听到这个问题：『<span class="text_import2">我干嘛要学习 shell 呢？
		不是已经有很多的工具可以提供我配置我的主机了？我为何要花这么多时间去学命令呢？不是以
		X Window 按一按几个按钮就可以搞定了吗？</span>』唉～还是得一再地强调，
		X Window 还有 Web 接口的配置工具例如 Webmin (<a href="http://cn.linux.vbird.org/linux_basic/0320bash.php#ps1">注1</a>) 是真的好用的家伙，
		他真的可以帮助我们很简易的配置好我们的主机，甚至是一些很进阶的配置都可以帮我们搞定。</p>

		<p>但是鸟哥在前面的章节里面也已经提到过相当多次了， X Window 与 web 接口的工具，他的接口虽然亲善，功能虽然强大，
		但毕竟他是将所有利用到的软件都整合在一起的一组应用程序而已，
		并非是一个完整的套件，所以某些时候当你升级或者是使用其他套件管理模块 (例如 tarball 而非 rpm 文件等等)
		时，就会造成配置的困扰了。甚至不同的 distribution 所设计的 X window 接口也都不相同，这样也造成学习方面的困扰。</p>

		<p>文字接口的 shell 就不同了！几乎各家 distributions 使用的 bash 都是一样的！如此一来，
		你就能够轻轻松松的转换不同的 distributions ，就像武侠小说里面提到的『一法通、万法通！』<br><br></p>

		<hr><ul class="list1"><li class="text_import1">远程管理：文字接口就是比较快！</li></ul>

		<p>此外，Linux 的管理常常需要透过远程联机，而联机时<span class="text_import2">文字接口的传输速度一定比较快，
		而且，较不容易出现断线或者是信息外流的问题</span>，因此，shell 真的是得学习的一项工具。而且，他可以让您更深入 
		Linux ，更了解他，而不是只会按一按鼠标而已！所谓『天助自助者！』多摸一点文本模式的东西，会让你与
		Linux 更亲近呢！<br><br></p>

		<hr><ul class="list1"><li class="text_import1">Linux 的任督二脉： shell 是也！</li></ul>

		<p>有些朋友也很可爱，常会说：『<span class="text_import2">我学这么多干什么？
		又不常用，也用不到</span>！』嘿嘿！有没有听过『书到用时方恨少？』
		当你的主机一切安然无恙的时候，您当然会觉得好像学这么多的东西一点帮助也没有呀！
		万一，某一天真的不幸给他中标了，您该如何是好？是直接重新安装？
		还是先追踪入侵来源后进行漏洞的修补？或者是干脆就关站好了？这当然涉及很多的考虑，
		但就以鸟哥的观点来看，多学一点总是好的，尤其我们可以有备而无患嘛！甚至学的不精也没有关系，了解概念也就
		OK 啦！毕竟没有人要您一定要背这么多的内容啦！了解概念就很了不起了！</p>

		<p>此外，<span class="text_import2">如果你真的有心想要将您的主机管理的好，那么良好的
		shell 程序编写是一定需要的啦</span>！就鸟哥自己来说，鸟哥管理的主机虽然还不算多，
		只有区区不到十部，但是如果每部主机都要花上几十分钟来查阅他的登录文件信息以及相关的信息，
		那么鸟哥可能会疯掉！基本上，也太没有效率了！这个时候，如果能够藉由 shell 提供的数据流重导向以及管线命令，呵呵！
		那么鸟哥分析登录信息只要花费不到十分钟就可以看完所有的主机之重要信息了！相当的好用呢！</p>

		<p>由于学习 shell 的好处真的是多多啦！所以，如果你是个系统管理员，或者有心想要管理系统的话，那么
		shell 与 shell scripts 这个东西真的有必要看一看！因为他就像『打通任督二脉，任何武功都能随你应用』的说！</p>
	</div>

	<hr><a name="bash_shells"></a><img src="./鸟哥的 Linux 私房菜12 -- 学习 bash shell_files/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">系统的合法 shell 与 /etc/shells 功能</span><br>
	<div class="block2">
		<p>知道什么是 Shell 之后，那么我们来了解一下 Linux 使用的是哪一个
		shell 呢？什么！哪一个？难道说 shell 不就是『一个 shell 吗？』哈哈！那可不！由于早年的
		Unix 年代，发展者众，所以由于 shell 依据发展者的不同就有许多的版本，例如常听到的
		Bourne SHell (sh) 、在 Sun 里头默认的 C SHell、 商业上常用的 K SHell、,
		还有 TCSH 等等，每一种 Shell 都各有其特点。至于 Linux 使用的这一种版本就称为『
		<span class="text_import2">Bourne Again SHell (简称 bash)</span>  』，这个 Shell 是 
		Bourne Shell 的增强版本，也是基准于 GNU 的架构下发展出来的呦！</p>

		<p>在介绍 shell 的优点之前，先来说一说 shell 的简单历史吧(<a href="http://cn.linux.vbird.org/linux_basic/0320bash.php#ps2">注2</a>)：第一个流行的
		shell 是由 Steven Bourne 发展出来的，为了纪念他所以就称为 Bourne shell
		，或直接简称为 sh ！而后来另一个广为流传的 shell 是由柏克莱大学的 Bill
		Joy 设计依附于 BSD 版的 Unix 系统中的 shell ，这个 shell 的语法有点类似
		C 语言，所以才得名为 C shell ，简称为 csh ！由于在学术界 Sun 
		主机势力相当的庞大，而 Sun 主要是 BSD 的分支之一，所以 C shell 
		也是另一个很重要而且流传很广的 shell 之一 。</p>

		<div style="padding: 10pt 0pt;" align="right"><table width="90%"><tbody><tr><td><b>Tips:</b><br><span style="color: rgb(0, 144, 0);"><font size="-1">		由于 Linux 为 C 程序语言撰写的，很多程序设计师使用 C 来开发软件，因此 C shell 相对的就很热门了。
		另外，还记得我们在<a href="http://cn.linux.vbird.org/linux_basic/0110whatislinux.php">第一章、Linux 是什么</a>提到的吧？
		Sun 公司的创始人就是 Bill Joy，而 BSD 最早就是 Bill Joy 发展出来的啊。
		</font></span></td><td><img src="./鸟哥的 Linux 私房菜12 -- 学习 bash shell_files/vbird_face.gif" alt="鸟哥的图示" title="鸟哥的图示"></td></tr></tbody></table></div>
		<p>那么目前我们的 Linux (以 CentOS 5.x 为例) 有多少我们可以使用的 shells 呢？
		你可以检查一下 /etc/shells 这个文件，至少就有底下这几个可以用的 shells：</p>

		<ul>
		<li>/bin/sh (已经被 /bin/bash 所取代)</li>
		<li>/bin/bash (就是 Linux 默认的 shell)</li>
		<li>/bin/ksh (Kornshell 由 AT&amp;T Bell lab. 发展出来的，兼容于 bash)</li>
		<li>/bin/tcsh (整合 C Shell ，提供更多的功能)</li>
		<li>/bin/csh (已经被 /bin/tcsh 所取代)</li>
		<li>/bin/zsh (基于 ksh 发展出来的，功能更强大的 shell)</li>
		</ul>

		<p>虽然各家 shell 的功能都差不多，但是在某些语法的下达方面则有所不同，因此建议你还是得要选择某一种 shell 来熟悉一下较佳。
		Linux 默认就是使用 bash ，所以最初你只要学会 bash 就非常了不起了！ ^_^！
		另外，咦！<span class="text_import2">为什么我们系统上合法的 shell 要写入 /etc/shells 这个文件啊？</span>
		这是因为系统某些服务在运行过程中，会去检查使用者能够使用的 shells ，而这些 shell 
		的查询就是藉由 /etc/shells 这个文件啰！</p>

		<p>举例来说，某些 FTP 网站会去检查使用者的可用 shell ，而如果你不想要让这些使用者使用 FTP 
		以外的主机资源时，可能会给予该使用者一些怪怪的 shell，让使用者无法以其他服务登陆主机。
		这个时候，你就得将那些怪怪的 shell 写到 /etc/shells 当中了。举例来说，我们的 CentOS 5.x
		的 /etc/shells 里头就有个 /sbin/nologin 文件的存在，这个就是我们说的怪怪的 shell 啰～</p>

		<p>那么，再想一想，<span class="text_import2">我这个使用者什么时候可以取得 shell 来工作呢？还有，
		我这个使用者默认会取得哪一个 shell 啊</span>？还记得我们在<a href="http://cn.linux.vbird.org/linux_basic/0160startlinux.php#start_cmd">第五章的在终端界面登陆linux小节</a>当中提到的登陆动作吧？
		当我登陆的时候，系统就会给我一个 shell 让我来工作了。
		而这个登陆取得的 shell 就记录在 /etc/passwd 这个文件内！这个文件的内容是啥？</p>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">cat /etc/passwd</span>
root:x:0:0:root:/root:<span class="term_write">/bin/bash</span>
bin:x:1:1:bin:/bin:<span class="term_write">/sbin/nologin</span>
daemon:x:2:2:daemon:/sbin:<span class="term_write">/sbin/nologin</span>
<span class="term_say">.....(底下省略).....</span>
</pre></td></tr></tbody></table>

		<p>如上所示，在每一行的最后一个数据，就是你登陆后可以取得的默认的 shell 啦！那你也会看到， root 是 
		/bin/bash ，不过，系统账号 bin 与 daemon 等等，就使用那个怪怪的 /sbin/nologin 
		啰～关于使用者这部分的内容，我们留在<a href="http://cn.linux.vbird.org/linux_basic/0410accountmanager.php">第十四章的账号管理</a>时提供更多的说明。</p>
	</div>

	<hr><a name="bash_bash"></a><img src="./鸟哥的 Linux 私房菜12 -- 学习 bash shell_files/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">Bash shell 的功能</span><br>
	<div class="block2">
		<p>既然 /bin/bash 是 Linux 默认的 shell ，那么总是得了解一下这个玩意儿吧！bash 是 GNU 计划中重要的工具软件之一，目前也是
		Linux distributions 的标准 shell 。 bash 主要兼容于 sh ，并且依据一些使用者需求，而加强的
		shell 版本。不论你使用的是那个 distribution ，你都难逃需要学习 bash 的宿命啦！那么这个
		shell 有什么好处，干嘛 Linux 要使用他作为默认的 shell 呢？ bash 主要的优点有底下几个：<br><br></p>

		<hr><ul class="list1"><li class="text_import1">命令编修能力 (history)：</li></ul>
		<p>bash 的功能里头，鸟哥个人认为相当棒的一个就是『他能记忆使用过的命令！』
		这功能真的相当的棒！因为我只要在命令列按『上下键』就可以找到前/后一个输入的命令！而在很多
		distribution 里头，默认的命令记忆功能可以到达 1000 个！也就是说，
		你曾经下达过的命令几乎都被记录下来了。</p>

		<p>这么多的命令记录在哪里呢？在你的家目录内的 <span class="text_import2">.bash_history</span> 啦！
		不过，需要留意的是，<span class="text_import2">~/.bash_history 记录的是前一次登陆以前所运行过的命令，
		而至于这一次登陆所运行的命令都被缓存在内存中，当你成功的注销系统后，该命令记忆才会记录到 .bash_history 当中</span>！</p>

		<p>这有什么功能呢？最大的好处就是可以『<span class="text_import2">查询曾经做过的举动</span>！』
		如此可以知道你的运行步骤，那么就可以追踪你曾下达过的命令，以作为除错的工具！
		但如此一来也有个烦恼，就是如果被黑客入侵了，那么他只要翻你曾经运行过的命令，
		刚好你的命令又跟系统有关 (例如直接输入 MySQL 的密码在命令列上面)，那你的主机可就伤脑筋了！
		到底记录命令的数目越多还是越少越好？这部份是见仁见智啦，没有一定的答案的。<br><br></p>

		<a name="tab"></a>
		<hr><ul class="list1"><li class="text_import1">命令与文件补全功能： ([tab] 按键的好处)</li></ul>

		<p>还记得我们在<a href="http://cn.linux.vbird.org/linux_basic/0160startlinux.php#cmd_hkey">第五章内的重要的几个热键小节</a>当中提到的
		[tab] 这个按键吗？这个按键的功能就是在 bash 里头才有的啦！常常在 bash 环境中使用 [tab] 
		是个很棒的习惯喔！因为至少可以让你 <span class="text_import2">1)少打很多字； 2)确定输入的数据是正确的！</span>
		使用 [tab] 按键的时机依据 [tab] 接在命令后或参数后而有所不同。我们再复习一次：</p>

		<ul class="text_import2">
		<li>[Tab] 接在一串命令的第一个字的后面，则为命令补全；</li>
		<li>[Tab] 接在一串命令的第二个字以后时，则为『文件补齐』！</li>
		</ul>

		<p>所以说，如果我想要知道我的环境中，所有可以运行的命令有几个？
		就直接在 bash 的提示字符后面连续按两次 [tab] 按键就能够显示所有的可运行命令了。
		那如果想要知道系统当中所有以 c 为开头的命令呢？就按下『 c[tab][tab] 』就好啦！ ^_^</p>

		<p>是的！真的是很方便的功能，所以，<span class="text_import2">有事没事，在
		bash shell 底下，多按几次 [tab] 是一个不错的习惯啦</span>！<br><br></p>

		<hr><ul class="list1"><li class="text_import1">命令别名配置功能： (alias)</li></ul>

		<p>假如我需要知道这个目录底下的所有文件 (包含隐藏档) 及所有的文件属性，那么我就必须要下达『
		ls -al 』这样的命令串，唉！真麻烦，有没有更快的取代方式？呵呵！就使用命令别名呀！例如鸟哥最喜欢直接以
		lm 这个自定义的命令来取代上面的命令，也就是说， <span class="text_import2">lm 会等于 ls -al</span>
		这样的一个功能，嘿！那么要如何作呢？就使用 alias 即可！你可以在命令列输入 alias 
		就可以知道目前的命令别名有哪些了！也可以直接下达命令来配置别名呦：</p>
		<blockquote class="text_import2" style="font-family: &#39;细明体&#39;;">alias lm='ls -al'</blockquote><br>

		<hr><ul class="list1"><li class="text_import1">工作控制、前景背景控制： (job control, foreground, background)</li></ul>

		<p>这部分我们在<a href="http://cn.linux.vbird.org/linux_basic/0440processcontrol.php">第十七章 Linux 过程控制</a>中再提及！
		使用前、背景的控制可以让工作进行的更为顺利！至于工作控制(jobs)的用途则更广，
		可以让我们随时将工作丢到背景中运行！而不怕不小心使用了
		[Ctrl] + c 来停掉该程序！真是好样的！此外，也可以在单一登录的环境中，达到多任务的目的呢！<br><br></p>

		<hr><ul class="list1"><li class="text_import1">程序化脚本： (shell scripts)</li></ul>

		<p>在 DOS 年代还记得将一堆命令写在一起的所谓的『批处理文件』吧？在 Linux 底下的
		shell scripts 则发挥更为强大的功能，可以将你平时管理系统常需要下达的连续命令写成一个文件，
		该文件并且可以透过对谈交互式的方式来进行主机的侦测工作！也可以藉由
		shell 提供的环境变量及相关命令来进行设计，哇！整个设计下来几乎就是一个小型的程序语言了！该
		scripts 的功能真的是超乎我的想象之外！以前在 DOS 底下需要程序语言才能写的东西，在
		Linux 底下使用简单的 shell scripts 就可以帮你达成了！真的厉害！这部分我们在<a href="http://cn.linux.vbird.org/linux_basic/0340bashshell-scripts.php">第十三章</a>再来谈！<br><br></p>

		<hr><ul class="list1"><li class="text_import1">通配符： (Wildcard)</li></ul>

		<p>除了完整的字符串之外， bash 还支持许多的通配符来帮助用户查询与命令下达。
		举例来说，想要知道 /usr/bin 底下有多少以 X 为开头的文件吗？使用：『
		ls -l /usr/bin/X* 』就能够知道啰～此外，还有其他可供利用的通配符，
		这些都能够加快使用者的操作呢！</p>
	</div>

	<hr><a name="bash_type"></a><img src="./鸟哥的 Linux 私房菜12 -- 学习 bash shell_files/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">Bash shell 的内建命令： type</span><br>
	<div class="block2">
		<p>我们在<a href="http://cn.linux.vbird.org/linux_basic/0160startlinux.php">第五章</a>提到关于
		<a href="http://cn.linux.vbird.org/linux_basic/0160startlinux.php#manual_man">Linux 的联机帮助文件</a>部分，也就是 
		man page 的内容，那么 bash 有没有什么说明文件啊？开玩笑～
		这么棒的东西怎么可能没有说明文件！请你在 shell 的环境下，直接输入 man bash 瞧一瞧，
		嘿嘿！不是盖的吧！让你看个几天几夜也无法看完的 bash 说明文件，可是很详尽的数据啊！ ^_^</p>

		<p>不过，在这个 bash 的 man page 当中，不知道你是否有察觉到，咦！
		怎么这个说明文件里面有其他的文件说明啊？举例来说，那个 cd 命令的说明就在这个 man page 内？
		然后我直接输入 man cd 时，怎么出现的画面中，最上方竟然出现一堆命令的介绍？这是怎么回事？
		为了方便 shell 的操作，其实 bash 已经『内建』了很多命令了，例如上面提到的 cd ，
		还有例如 umask 等等的命令，都是内建在 bash 当中的呢！</p>

		<p>那我怎么知道这个命令是来自于外部命令(指的是其他非 bash 所提供的命令) 或是内建在 bash 当中的呢？
		嘿嘿！利用 type 这个命令来观察即可！举例来说：</p>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">type [-tpa] name</span>
<span class="term_say">选项与参数：
    ：不加任何选项与参数时，type 会显示出 name 是外部命令还是 bash 内建命令
-t  ：当加入 -t 参数时，type 会将 name 以底下这些字眼显示出他的意义：
      file    ：表示为外部命令；
      alias   ：表示该命令为命令别名所配置的名称；
      builtin ：表示该命令为 bash 内建的命令功能；
-p  ：如果后面接的 name 为外部命令时，才会显示完整文件名；
-a  ：会由 PATH 变量定义的路径中，将所有含 name 的命令都列出来，包含 alias</span>

<span class="term_hd">范例一：查询一下 ls 这个命令是否为 bash 内建？</span>
[root@www ~]# <span class="term_command">type ls</span>
ls is aliased to `ls --color=tty' <span class="term_note">&lt;==未加任何参数，列出 ls 的最主要使用情况</span>
[root@www ~]# <span class="term_command">type -t ls</span>
alias                             <span class="term_note">&lt;==仅列出 ls 运行时的依据</span>
[root@www ~]# <span class="term_command">type -a ls</span>
ls is aliased to `ls --color=tty' <span class="term_note">&lt;==最先使用 aliase</span>
ls is /bin/ls                     <span class="term_note">&lt;==还有找到外部命令在 /bin/ls</span>

<span class="term_hd">范例二：那么 cd 呢？</span>
[root@www ~]# <span class="term_command">type cd</span>
cd is a shell builtin             <span class="term_note">&lt;==看到了吗？ cd 是 shell 内建命令</span>
</pre></td></tr></tbody></table>

		<p>透过 type 这个命令我们可以知道每个命令是否为 bash 的内建命令。
		此外，由于利用 type 搜寻后面的名称时，如果后面接的名称并不能以运行档的状态被找到，
		那么该名称是不会被显示出来的。也就是说， type 主要在找出『运行档』而不是一般文件档名喔！
		呵呵！所以，<span class="text_import2">这个 type 也可以用来作为类似 <a href="http://cn.linux.vbird.org/linux_basic/0220filemanager.php#which">which</a>
		命令的用途啦！</span>找命令用的！</p>
	</div>

	<hr><a name="bash_command"></a><img src="./鸟哥的 Linux 私房菜12 -- 学习 bash shell_files/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">命令的下达</span><br>
	<div class="block2">
		<p>我们在<a href="http://cn.linux.vbird.org/linux_basic/0160startlinux.php#cmd_cmd">第五章的开始下达命令小节</a>已经提到过在
		shell 环境下的命令下达方法，如果你忘记了请回到第五章再去回忆一下！这里不重复说明了。
		鸟哥这里仅就反斜杠 (\) 来说明一下命令下达的方式啰！</p>

<table class="term"><tbody><tr><td class="term"><pre><span class="term_hd">范例：如果命令串太长的话，如何使用两行来输出？</span>
[vbird@www ~]# <span class="term_command">cp /var/spool/mail/root /etc/crontab \</span>
&gt; <span class="term_command">/etc/fstab /root</span>
</pre></td></tr></tbody></table>

		<p>上面这个命令用途是将三个文件复制到 /root 这个目录下而已。不过，因为命令太长，
		于是鸟哥就利用『 \[Enter] 』来将 [Enter] 这个按键『跳脱！』开来，让
		[Enter] 按键不再具有『开始运行』的功能！好让命令可以继续在下一行输入。
		<span class="text_import2">需要特别留意， [Enter] 按键是紧接着反斜杠 (\) 的，两者中间没有其他字符。
		因为 \ 仅跳脱『紧接着的下一个字符』而已</span>！所以，万一我写成：
		『<span class="text_import2" style="font-family: &#39;细明体&#39;;"> \ [Enter]</span> 』，亦即 
		[Enter] 与反斜杠中间有一个空格时，则 \ 跳脱的是『空格键』而不是 [Enter] 按键！这个地方请再仔细的看一遍！很重要！</p>

		<p>如果顺利跳脱 [Enter] 后，下一行最前面就会主动出现 &gt; 的符号，
		你可以继续输入命令啰！也就是说，那个 &gt; 是系统自动出现的，你不需要输入。</p>

		<p>总之，当我们顺利的在终端机 (tty) 上面登陆后， Linux 就会依据 /etc/passwd 
		文件的配置给我们一个 shell (默认是 bash)，然后我们就可以依据上面的命令下达方式来操作 shell，
		之后，我们就可以透过 man 这个在线查询来查询命令的使用方式与参数说明，
		很不错吧！那么我们就赶紧更进一步来操作 bash 这个好玩的东西啰！</p>
	</div>
</div>


<hr><a name="variable"></a><img src="./鸟哥的 Linux 私房菜12 -- 学习 bash shell_files/logo.png" alt="大标题的图示" width="35" align="middle" height="34"><span class="text_h1">Shell 的变量功能</span><br>
<div class="block1">
	<p>变量是 bash 环境中非常重要的一个玩意儿，我们知道 Linux 是多人多任务的环境，每个人登陆系统都能取得一个 bash ，
	每个人都能够使用 bash 下达 mail 这个命令来收受『自己』的邮件，问题是， bash 是如何得知你的邮件信箱是哪个文件？
	这就需要『变量』的帮助啦！所以，你说变量重不重要呢？底下我们将介绍重要的环境变量、变量的取用与配置等数据，
	呼呼！动动脑时间又来到啰！^_^<br><br></p>

	<hr><a name="variable_var"></a><img src="./鸟哥的 Linux 私房菜12 -- 学习 bash shell_files/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">什么是变量？</span><br>
	<div class="block2">
		<p>那么，什么是『变量』呢？简单的说，就是让某一个特定字符串代表不固定的内容就是了。举个大家在国中都会学到的数学例子，
		那就是：『 y = ax + b 』这东西，<span class="text_import2">在等号左边的(y)就是变量，在等号右边的(ax+b)就是变量内容。
		要注意的是，左边是未知数，右边是已知数喔！</span>
		讲的更简单一点，我们可以『<span class="text_import2">用一个简单的 "字眼" 
		来取代另一个比较复杂或者是容易变动的数据</span>』。这有什么好处啊？最大的好处就是『方便！』。<br><br></p>

		<hr><ul class="list1"><li class="text_import1">变量的可变性与方便性</li></ul>

		<a name="mail"></a>
		<p>举例来说，我们每个账号的邮件信箱默认是以 MAIL 这个变量来进行存取的，
		当 dmtsai 这个使用者登陆时，他便会取得 MAIL 这个变量，而这个变量的内容其实就是 /var/spool/mail/dmtsai，
		那如果 vbird 登陆呢？他取得的 MAIL 这个变量的内容其实就是 /var/spool/mail/vbird 。
		而我们使用信件读取命令 mail 来读取自己的邮件信箱时，嘿嘿，这支程序可以直接读取 MAIL 这个变量的内容，
		就能够自动的分辨出属于自己的信箱信件啰！这样一来，设计程序的设计师就真的很方便的啦！</p>

		<center><img src="./鸟哥的 Linux 私房菜12 -- 学习 bash shell_files/var_01.gif" alt="程序、变量与不同用户的关系" title="程序、变量与不同用户的关系" border="0"><br>
		图 2.1.1、程序、变量与不同用户的关系<br></center>

		<p>如上图所示，由于系统已经帮我们规划好 MAIL 这个变量，所以用户只要知道 mail 这个命令如何使用即可，
		mail 会主动的取用 MAIL 这个变量，就能够如上图所示的取得自己的邮件信箱了！(注意大小写，小写的 mail 是命令，
		大写的 MAIL 则是变量名称喔！)</p>

		<p>那么使用变量真的比较好吗？这是当然的！想象一个例子，如果 mail 这个命令将 root 收信的邮件信箱 (mailbox) 档名为
		/var/spool/mail/root 直接写入程序代码中。那么当 dmtsai 要使用 mail 时，将会取得 /var/spool/mail/root 这个文件的内容！
		不合理吧！所以你就需要帮 dmtsai 也设计一个 mail 的程序，将 /var/spool/mail/dmtsai 写死到 mail 的程序代码当中！
		天吶！那系统要有多少个 mail 命令啊？反过来说，使用变量就变的很简单了！因为你不需要更动到程序代码啊！
		只要将 MAIL 这个变量带入不同的内容即可让所有使用者透过 mail 取得自己的信件！当然简单多了！<br><br></p>

		<hr><ul class="list1"><li class="text_import1">影响 bash 环境操作的变量</li></ul>

		<p>某些特定变量会影响到 bash 的环境喔！举例来说，我们前面已经提到过很多次的那个 PATH 变量！
		你能不能在任何目录下运行某个命令，与 PATH 这个变量有很大的关系。例如你下达 ls 这个命令时，系统就是透过 PATH 
		这个变量里面的内容所记录的路径顺序来搜寻命令的呢！如果在搜寻完 PATH 变量内的路径还找不到 ls 这个命令时，
		就会在屏幕上显示『 command not found 』的错误信息了。</p>

		<p>如果说的学理一点，那么由于在 Linux System 下面，所有的线程都是需要一个运行码，
		而就如同上面提到的，你『<span class="text_import2">真正以
		shell 来跟 Linux 沟通，是在正确的登陆 Linux 之后！</span>』这个时候你就有一个
		bash 的运行程序，也才可以真正的经由 bash 来跟系统沟通啰！而在进入 shell
		之前，也正如同上面提到的，由于系统需要一些变量来提供他数据的存取 (或者是一些环境的配置参数值，
		例如是否要显示彩色等等的) ，所以就有一些所谓的『<span class="text_import2">环境变量</span>』
		需要来读入系统中了！这些环境变量例如 PATH、HOME、MAIL、SHELL 等等，都是很重要的，
		为了区别与自定义变量的不同，环境变量通常以大写字符来表示呢！<br><br></p>

		<hr><ul class="list1"><li class="text_import1">脚本程序设计 (shell script) 的好帮手</li></ul>

		<p>这些还都只是系统默认的变量的目的，如果是个人的配置方面的应用呢：例如你要写一个大型的
		script 时，有些数据因为可能由于用户习惯的不同而有差异，比如说路径好了，由于该路径在
		script 被使用在相当多的地方，如果下次换了一部主机，都要修改 script 里面的所有路径，那么我一定会疯掉！
		这个时候如果使用变量，而将该变量的定义写在最前面，后面相关的路径名称都以变量来取代，
		嘿嘿！那么你只要修改一行就等于修改整篇 script 了！方便的很！所以，良好的程序设计师都会善用变量的定义！</p>

		<center><img src="./鸟哥的 Linux 私房菜12 -- 学习 bash shell_files/var_02.gif" alt="变量应用于 shell script 的示意图" title="变量应用于 shell script 的示意图" border="0"><br>
		图 2.1.2、变量应用于 shell script 的示意图<br></center>

		<p>最后我们就简单的对『<span class="text_import2">什么是变量</span>』作个简单定义好了：
		『<span class="text_import2">变量就是以一组文字或符号等，来取代一些配置或者是一串保留的数据！</span>』，
		例如：我配置了『myname』就是『VBird』，所以当你读取
		myname 这个变量的时候，系统自然就会知道！哈！那就是 VBird 啦！
		那么如何『<span class="text_import2">显示变量</span>』呢？这就需要使用到 echo 这个命令啦！</p>
	</div>

	<hr><a name="variable_echo"></a><img src="./鸟哥的 Linux 私房菜12 -- 学习 bash shell_files/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">变量的取用与配置：echo, 
	变量配置守则, unset</span><br>
	<div class="block2">
		<p>说的口沫横飞的，也不知道『变量』与『变量代表的内容』有啥关系？
		那我们就将『变量』的『内容』拿出来给您瞧瞧好了。你可以利用 echo 这个命令来取用变量，
		但是，变量在被取用时，前面必须要加上钱字号『 $ 』才行，举例来说，要知道 PATH 的内容，该如何是好？<br><br></p>

		<a name="echo"></a>
		<hr><ul class="list1"><li class="text_import1">变量的取用: echo</li></ul>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">echo $variable</span>
[root@www ~]# <span class="term_command">echo $PATH</span>
/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/root/bin
[root@www ~]# <span class="term_command">echo ${PATH}</span>
</pre></td></tr></tbody></table>

		<p>变量的取用就如同上面的范例，利用 echo 就能够读出，只是需要在变量名称前面加上 $ ，
		或者是以 ${变量} 的方式来取用都可以！当然啦，那个 echo 的功能可是很多的，
		我们这里单纯是拿 echo 来读出变量的内容而已，更多的 echo 使用，请自行给他 man echo 吧！ ^_^</p>

<table border="1" cellpadding="5" cellspacing="0" width="90%"><tbody><tr><td>
例题：<div class="block2">
请在屏幕上面显示出您的环境变量 HOME 与 MAIL：
</div>
答：<div class="block2">
<span class="text_import2" style="font-family: &#39;细明体&#39;;">echo $HOME 或者是 echo ${HOME}<br>echo $MAIL 或者是 echo ${MAIL}</span>
</div>
</td></tr></tbody></table><br>

		<p>现在我们知道了变量与变量内容之间的相关性了，好了，那么我要如何『配置』或者是『修改』
		某个变量的内容啊？很简单啦！用『等号(=)』连接变量与他的内容就好啦！举例来说：
		我要将 myname 这个变量名称的内容配置为 VBird ，那么：</p>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">echo $myname</span>
       <span class="term_note">&lt;==这里并没有任何数据～因为这个变量尚未被配置！是空的！</span>
[root@www ~]# <span class="term_command">myname=VBird</span>
[root@www ~]# <span class="term_command">echo $myname</span>
VBird  <span class="term_note">&lt;==出现了！因为这个变量已经被配置了！</span>
</pre></td></tr></tbody></table>

		<p>瞧！如此一来，这个变量名称 myname 的内容就带有 VBird 这个数据啰～
		而由上面的例子当中，我们也可以知道：
		<span class="text_import2">在 bash 当中，当一个变量名称尚未被配置时，默认的内容是『空』的</span>。
		另外，变量在配置时，还是需要符合某些规定的，否则会配置失败喔！
		这些守则如下所示啊！<br><br></p>

		<a name="variable_rule"></a>
		<hr><ul class="list1"><li class="text_import1">变量的配置守则</li></ul>

		<ol style="font-family: &#39;细明体&#39;;">
		<li><span class="text_import2">变量与变量内容以一个等号『=』来连结</span>，如下所示：
			<br>『myname=VBird』<br><br></li>
		<li><span class="text_import2">等号两边不能直接接空格符</span>，如下所示为错误：
			<br>『myname = VBird』或『myname=VBird Tsai』<br><br></li>
		<li>变量名称只能是英文字母与数字，但是<span class="text_import2">开头字符不能是数字</span>，如下为错误：
			<br>『2myname=VBird』<br><br></li>
		<li>变量内容若有空格符可使用双引号『"』或单引号『'』将变量内容结合起来，但
			<ul style="padding-left: 15px;">
			<li><span class="text_import2">双引号内的特殊字符如 $ 等，可以保有原本的特性</span>，如下所示：<br>
			『var="lang is $LANG"』则『echo $var』可得『lang is en_US』</li>
			<li><span class="text_import2">单引号内的特殊字符则仅为一般字符 (纯文本)</span>，如下所示：<br>
			『var='lang is $LANG'』则『echo $var』可得『lang is $LANG』</li>
			</ul><br></li>
		<li>可用<span class="text_import2">跳脱字符『 \ 』</span>将特殊符号(如 [Enter], $, \, 空格符, 
			'等)变成一般字符；<br><br></li>
		<li>在一串命令中，还需要藉由其他的命令提供的信息，可以<span class="text_import2">使用反单引号『`命令`』或
			『$(命令)』</span>。特别注意，那个 ` 是键盘上方的数字键 1 左边那个按键，而不是单引号！
			例如想要取得核心版本的配置：<br>『version=$(uname -r)』再『echo 
			$version』可得『2.6.18-128.el5』<br><br></li>
		<li>若该变量为扩增变量内容时，则可用 "$变量名称" 或 ${变量} 累加内容，如下所示：<br>
			『PATH="$PATH":/home/bin』<br><br></li>
		<li>若该变量需要在其他子程序运行，则<span class="text_import2">需要以 export 来使变量变成环境变量</span>：<br>
			『export PATH』<br><br></li>
		<li>通常大写字符为系统默认变量，自行配置变量可以使用小写字符，方便判断 (纯粹依照使用者兴趣与嗜好) ；<br><br></li>
		<li><a name="unset"></a><span class="text_import2">取消变量的方法为使用 unset</span> ：『unset 
			变量名称』例如取消 myname 的配置：<br>
			『unset myname』</li>
		</ol>

		<p>底下让鸟哥举几个例子来让你试看看，就知道怎么配置好你的变量啰！</p>

<table class="term"><tbody><tr><td class="term"><pre><span class="term_hd">范例一：配置一变量 name ，且内容为 VBird</span>
[root@www ~]# <span class="term_command">12name=VBird</span>
-bash: 12name=VBird: command not found  <span class="term_note">&lt;==屏幕会显示错误！因为不能以数字开头！</span>
[root@www ~]# <span class="term_command">name = VBird</span>            <span class="term_note">&lt;==还是错误！因为有空白！</span>
[root@www ~]# <span class="term_command">name=VBird</span>              <span class="term_note">&lt;==OK 的啦！</span>

<span class="term_hd">范例二：承上题，若变量内容为 VBird's name 呢，就是变量内容含有特殊符号时：</span>
[root@www ~]# <span class="term_command">name=VBird's name</span>  
<span class="term_say"># <u>单引号与双引号必须要成对</u>，在上面的配置中仅有一个单引号，因此当你按下 enter 后，
# 你还可以继续输入变量内容。这与我们所需要的功能不同，失败啦！
# 记得，失败后要复原请按下 [ctrl]-c 结束！</span>
[root@www ~]# <span class="term_command">name="VBird's name"</span>    <span class="term_note">&lt;==OK 的啦！</span>
<span class="term_say"># 命令是由左边向右找→，先遇到的引号先有用，因此如上所示，单引号会失效！</span>
[root@www ~]# <span class="term_command">name='VBird's name'</span>    <span class="term_note">&lt;==失败的啦！</span>
<span class="term_say"># 因为前两个单引号已成对，后面就多了一个不成对的单引号了！因此也就失败了！</span>
[root@www ~]# <span class="term_command">name=VBird\'s\ name</span>     <span class="term_note">&lt;==OK 的啦！</span>
<span class="term_say"># 利用反斜杠 (\) 跳脱特殊字符，例如单引号与空格键，这也是 OK 的啦！</span>

<span class="term_hd">范例三：我要在 PATH 这个变量当中『累加』:/home/dmtsai/bin 这个目录</span>
[root@www ~]# <span class="term_command">PATH=$PATH:/home/dmtsai/bin</span>
[root@www ~]# <span class="term_command">PATH="$PATH":/home/dmtsai/bin</span>
[root@www ~]# <span class="term_command">PATH=${PATH}:/home/dmtsai/bin</span>
<span class="term_say"># 上面这三种格式在 PATH 里头的配置都是 OK 的！但是底下的例子就不见得啰！</span>

<span class="term_hd">范例四：承范例三，我要将 name 的内容多出 "yes" 呢？</span>
[root@www ~]# <span class="term_command">name=$nameyes</span>  
<span class="term_say"># 知道了吧？如果没有双引号，那么变量成了啥？name 的内容是 $nameyes 这个变量！
# 呵呵！我们可没有配置过 nameyes 这个变量吶！所以，应该是底下这样才对！</span>
[root@www ~]# <span class="term_command">name="$name"yes</span>
[root@www ~]# <span class="term_command">name=${name}yes</span>  <span class="term_note">&lt;==以此例较佳！</span>

<span class="term_hd">范例五：如何让我刚刚配置的 name=VBird 可以用在下个 shell 的程序？</span>
[root@www ~]# <span class="term_command">name=VBird</span>
[root@www ~]# <span class="term_command">bash      </span>  <span class="term_note">&lt;==进入到所谓的子程序</span>
[root@www ~]# <span class="term_command">echo $name</span>  <span class="term_note">&lt;==子程序：再次的 echo 一下；</span>
       <span class="term_note">&lt;==嘿嘿！并没有刚刚配置的内容喔！</span>
[root@www ~]# <span class="term_command">exit      </span>  <span class="term_note">&lt;==子程序：离开这个子程序</span>
[root@www ~]# <span class="term_command">export name</span>
[root@www ~]# <span class="term_command">bash      </span>  <span class="term_note">&lt;==进入到所谓的子程序</span>
[root@www ~]# <span class="term_command">echo $name</span>  <span class="term_note">&lt;==子程序：在此运行！</span>
VBird  <span class="term_note">&lt;==看吧！出现配置值了！</span>
[root@www ~]# <span class="term_command">exit      </span>  <span class="term_note">&lt;==子程序：离开这个子程序</span>
</pre></td></tr></tbody></table>

		<p>什么是『子程序』呢？就是说，在我目前这个 shell 的情况下，去激活另一个新的 shell ，新的那个 shell 
		就是子程序啦！在一般的状态下，父程序的自定义变量是无法在子程序内使用的。但是透过 export 
		将变量变成环境变量后，就能够在子程序底下应用了！很不赖吧！至于程序的相关概念，
		我们会在<a href="http://cn.linux.vbird.org/linux_basic/0440processcontrol.php">第十七章程序管理</a>当中提到的喔！</p>

<table class="term"><tbody><tr><td class="term"><pre><span class="term_hd">范例六：如何进入到您目前核心的模块目录？</span>
[root@www ~]# <span class="term_command">cd /lib/modules/`uname -r`/kernel</span>
[root@www ~]# <span class="term_command">cd /lib/modules/$(uname -r)/kernel</span>
</pre></td></tr></tbody></table>

		<p>每个 Linux 都能够拥有多个核心版本，且几乎 distribution 的核心版本都不相同。以 CentOS 5.3 (未升级前) 
		为例，他的默认核心版本是 2.6.18-128.el5 ，所以核心模块目录在 /lib/modules/2.6.18-128.el5/kernel/ 内。
		也由于每个 distributions 的这个值都不相同，但是我们却可以利用 uname -r 
		这个命令先取得版本信息。所以啰，就可以透过上面命令当中的内含命令 `uname -r` 
		先取得版本输出到 cd ... 那个命令当中，就能够顺利的进入目前核心的驱动程序所放置的目录啰！很方便吧！</p>

		<p>其实上面的命令可以说是作了两次动作，亦即是：</p>

		<ol>
		<li>先进行反单引号内的动作『uname -r』并得到核心版本为 2.6.18-128.el5</li>
		<li>将上述的结果带入原命令，故得命令为：『cd /lib/modules/2.6.18-128.el5/kernel/』</li>
		</ol>

<table class="term"><tbody><tr><td class="term"><pre><span class="term_hd">范例七：取消刚刚配置的 name 这个变量内容</span>
[root@www ~]# <span class="term_command">unset name</span>
</pre></td></tr></tbody></table>

		<p>根据上面的案例你可以试试看！就可以了解变量的配置啰！这个是很重要的呦！请勤加练习！
		其中，较为重要的一些特殊符号的使用啰！例如单引号、双引号、跳脱字符、钱字号、反单引号等等，底下的例题想一想吧！</p>

<table border="1" cellpadding="5" cellspacing="0" width="90%"><tbody><tr><td>
例题：<div class="block2">
在变量的配置当中，单引号与双引号的用途有何不同？<br>
</div>
答：<div class="block2">
单引号与双引号的最大不同在于<span class="text_import2">双引号仍然可以保有变量的内容，但单引号内仅能是一般字符
，而不会有特殊符号。</span>我们以底下的例子做说明：假设您定义了一个变量， name=VBird ，现在想以 
name 这个变量的内容定义出 myname 显示 VBird its me 这个内容，要如何订定呢？
<blockquote class="text_import2" style="font-family: &#39;细明体&#39;;">
[root@www ~]# name=VBird<br>
[root@www ~]# echo $name<br>
VBird<br>
[root@www ~]# myname="$name its me"<br>
[root@www ~]# echo $myname<br>
VBird its me<br>
[root@www ~]# myname='$name its me'<br>
[root@www ~]# echo $myname<br>
$name its me</blockquote>
发现了吗？没错！使用了单引号的时候，那么 $name 将失去原有的变量内容，仅为一般字符的显示型态而已！这里必需要特别小心在意！
</div>
</td></tr></tbody></table><br>

<table border="1" cellpadding="5" cellspacing="0" width="90%"><tbody><tr><td>
例题：<div class="block2">
在命令下达的过程中，反单引号( ` )这个符号代表的意义为何？
</div>
答：<div class="block2">
在一串命令中，在 ` 之内的命令将会被先运行，而其运行出来的结果将做为外部的输入信息！例如 
uname -r 会显示出目前的核心版本，而我们的核心版本在 /lib/modules 里面，因此，你可以先运行 
uname -r 找出核心版本，然后再以『 cd 目录』到该目录下，当然也可以运行如同上面范例六的运行内容啰。
<br><br>另外再举个例子，我们也知道， <a href="http://cn.linux.vbird.org/linux_basic/0220filemanager.php#locate">locate</a>
命令可以列出所有的相关文件档名，但是，如果我想要知道各个文件的权限呢？举例来说，我想要知道每个 crontab 相关档名的权限：
<blockquote style="font-family: &#39;细明体&#39;;" class="text_import2">
[root@www ~]# ls -l `locate crontab`</blockquote>
如此一来，先以 locate 将文件名数据都列出来，再以 ls 命令来处理的意思啦！瞭了吗？ ^_^
</div>
</td></tr></tbody></table><br>

<table border="1" cellpadding="5" cellspacing="0" width="90%"><tbody><tr><td>
例题：<div class="block2">
若你有一个常去的工作目录名称为：『/cluster/server/work/taiwan_2005/003/』，如何进行该目录的简化？
</div>
答：<div class="block2">
在一般的情况下，如果你想要进入上述的目录得要『cd /cluster/server/work/taiwan_2005/003/』，
以鸟哥自己的案例来说，鸟哥跑数值模式常常会配置很长的目录名称(避免忘记)，但如此一来变换目录就很麻烦。
此时，鸟哥习惯利用底下的方式来降低命令下达错误的问题：<blockquote style="font-family: &#39;细明体&#39;;" class="text_import2">
[root@www ~]# work="/cluster/server/work/taiwan_2005/003/"<br>
[root@www ~]# cd $work</blockquote>
未来我想要使用其他目录作为我的模式工作目录时，只要变更 work 这个变量即可！而这个变量又可以在 <a href="http://cn.linux.vbird.org/linux_basic/0320bash.php#settings_bashrc">bash
的配置文件</a>中直接指定，那我每次登陆只要运行『 cd $work 』就能够去到数值模式仿真的工作目录了！是否很方便呢？ ^_^
</div>
</td></tr></tbody></table><br>

		<div style="padding: 10pt 0pt;" align="right"><table width="90%"><tbody><tr><td><b>Tips:</b><br><span style="color: rgb(0, 144, 0);"><font size="-1">		老实说，使用『 version=$(uname -r) 』来取代『 version=`uname -r` 』比较好，因为反单引号大家老是容易打错或看错！
		所以现在鸟哥都习惯使用 $( 命令 ) 来介绍这个功能！
		</font></span></td><td><img src="./鸟哥的 Linux 私房菜12 -- 学习 bash shell_files/vbird_face.gif" alt="鸟哥的图示" title="鸟哥的图示"></td></tr></tbody></table></div>

	</div>

	<hr><a name="variable_environ"></a><img src="./鸟哥的 Linux 私房菜12 -- 学习 bash shell_files/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">环境变量的功能</span><br>
	<div class="block2">
		<p>环境变量可以帮我们达到很多功能～包括家目录的变换啊、提示字符的显示啊、运行文件搜寻的路径啊等等的，
		还有很多很多啦！那么，既然环境变量有那么多的功能，问一下，目前我的 shell 环境中，
		有多少默认的环境变量啊？我们可以利用两个命令来查阅，分别是 env 与 export 呢！<br><br></p>

		<a name="env"></a>
		<hr><ul class="list1"><li class="text_import1">用 env 观察环境变量与常见环境变量说明</li></ul>

<table class="term"><tbody><tr><td class="term"><pre><span class="term_hd">范例一：列出目前的 shell 环境下的所有环境变量与其内容。</span>
[root@www ~]# <span class="term_command">env</span>
HOSTNAME=www.vbird.tsai    <span class="term_note">&lt;== 这部主机的主机名</span>
TERM=xterm                 <span class="term_note">&lt;== 这个终端机使用的环境是什么类型</span>
SHELL=/bin/bash            <span class="term_note">&lt;== 目前这个环境下，使用的 Shell 是哪一个程序？</span>
HISTSIZE=1000              <span class="term_note">&lt;== 『记录命令的笔数』在 CentOS 默认可记录 1000 笔</span>
USER=root                  <span class="term_note">&lt;== 使用者的名称啊！</span>
LS_COLORS=no=00:fi=00:di=00;34:ln=00;36:pi=40;33:so=00;35:bd=40;33;01:cd=40;33;01:
or=01;05;37;41:mi=01;05;37;41:ex=00;32:*.cmd=00;32:*.exe=00;32:*.com=00;32:*.btm=0
0;32:*.bat=00;32:*.sh=00;32:*.csh=00;32:*.tar=00;31:*.tgz=00;31:*.arj=00;31:*.taz=
00;31:*.lzh=00;31:*.zip=00;31:*.z=00;31:*.Z=00;31:*.gz=00;31:*.bz2=00;31:*.bz=00;3
1:*.tz=00;31:*.rpm=00;31:*.cpio=00;31:*.jpg=00;35:*.gif=00;35:*.bmp=00;35:*.xbm=00
;35:*.xpm=00;35:*.png=00;35:*.tif=00;35: <span class="term_note">&lt;== 一些颜色显示</span>
MAIL=/var/spool/mail/root  <span class="term_note">&lt;== 这个用户所取用的 mailbox 位置</span>
PATH=/sbin:/usr/sbin:/bin:/usr/bin:/usr/X11R6/bin:/usr/local/bin:/usr/local/sbin:
/root/bin                  <span class="term_note">&lt;== 不再多讲啊！是运行文件命令搜寻路径</span>
INPUTRC=/etc/inputrc       <span class="term_note">&lt;== 与键盘按键功能有关。可以配置特殊按键！</span>
PWD=/root                  <span class="term_note">&lt;== 目前用户所在的工作目录 (利用 pwd 取出！)</span>
LANG=en_US                 <span class="term_note">&lt;== 这个与语系有关，底下会再介绍！</span>
HOME=/root                 <span class="term_note">&lt;== 这个用户的家目录啊！</span>
_=/bin/env                 <span class="term_note">&lt;== 上一次使用的命令的最后一个参数(或命令本身)</span>
</pre></td></tr></tbody></table>

		<p>env 是 environment (环境) 的简写啊，上面的例子当中，是列出来所有的环境变量。当然，如果使用 export 也会是一样的内容～
		只不过， export 还有其他额外的功能就是了，我们等一下再提这个 export 命令。
		那么上面这些变量有些什么功用呢？<a name="variable_environ_im"></a>底下我们就一个一个来分析分析！</p>

		<ul style="padding-left: 25px;">
		<li><span class="text_import1">HOME</span><br>代表用户的家目录。还记得我们可以使用 cd ~ 
			去到自己的家目录吗？或者利用 cd 就可以直接回到用户家目录了。那就是取用这个变量啦～
			有很多程序都可能会取用到这个变量的值！<br><br></li>
		<li><span class="text_import1">SHELL</span><br>告知我们，目前这个环境使用的 SHELL 是哪支程序？
			Linux 默认使用 /bin/bash 的啦！<br><br></li>
		<li><span class="text_import1">HISTSIZE</span><br>这个与『历史命令』有关，亦即是，
			我们曾经下达过的命令可以被系统记录下来，而记录的『笔数』则是由这个值来配置的。<br><br></li>
		<li><span class="text_import1">MAIL</span><br>当我们使用 mail 这个命令在收信时，系统会去读取的邮件信箱文件 
			(mailbox)。<br><br></li>
		<li><span class="text_import1">PATH</span><br>就是运行文件搜寻的路径啦～目录与目录中间以冒号(:)分隔，
			由于文件的搜寻是依序由 PATH 的变量内的目录来查询，所以，目录的顺序也是重要的喔。<br><br></li>
		<li><span class="text_import1">LANG</span><br>这个重要！就是语系数据啰～很多信息都会用到他，
			举例来说，当我们在启动某些 perl 的程序语言文件时，他会主动的去分析语系数据文件，
			如果发现有他无法解析的编码语系，可能会产生错误喔！一般来说，我们中文编码通常是 zh_TW.Big5 或者是 
			zh_TW.UTF-8，这两个编码偏偏不容易被解译出来，所以，有的时候，可能需要修订一下语系数据。
			这部分我们会在下个小节做介绍的！<br><br></li>
		<li><span class="text_import1">RANDOM</span><br>这个玩意儿就是『随机随机数』的变量啦！目前大多数的
			distributions 都会有随机数生成器，那就是<span class="text_import2"> /dev/random</span> 这个文件。
			我们可以透过这个随机数文件相关的变量 ($RANDOM) 来随机取得随机数值喔。在 BASH 的环境下，这个 RANDOM 
			变量的内容，介于 0~32767 之间，所以，你只要 echo $RANDOM 时，系统就会主动的随机取出一个介于
			0~32767 的数值。万一我想要使用 0~9 之间的数值呢？呵呵～利用 declare 宣告数值类型，
			然后这样做就可以了：<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">declare -i number=$RANDOM*10/32768 ; echo $number</span>
8   <span class="term_note">&lt;== 此时会随机取出 0~9 之间的数值喔！</span>
</pre></td></tr></tbody></table></li>
		</ul>

		<p>大致上是有这些环境变量啦～里面有些比较重要的参数，在底下我们都会另外进行一些说明的～<br><br></p>

		<a name="set"></a>
		<hr><ul class="list1"><li class="text_import1">用 set 观察所有变量 (含环境变量与自定义变量)</li></ul>

		<p>bash 可不只有环境变量喔，还有一些与 bash 操作接口有关的变量，以及用户自己定义的变量存在的。
		那么这些变量如何观察呢？这个时候就得要使用 set 这个命令了。  set 除了环境变量之外，
		还会将其他在 bash 内的变量通通显示出来哩！信息很多，底下鸟哥仅列出几个重要的内容：</p>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">set</span>
BASH=/bin/bash           <span class="term_note">&lt;== bash 的主程序放置路径</span>
BASH_VERSINFO=([0]="3" [1]="2" [2]="25" [3]="1" [4]="release" 
[5]="i686-redhat-linux-gnu")      <span class="term_note">&lt;== bash 的版本啊！</span>
BASH_VERSION='3.2.25(1)-release'  <span class="term_note">&lt;== 也是 bash 的版本啊！</span>
COLORS=/etc/DIR_COLORS.xterm      <span class="term_note">&lt;== 使用的颜色纪录文件</span>
COLUMNS=115              <span class="term_note">&lt;== 在目前的终端机环境下，使用的字段有几个字符长度</span>
<span class="term_write">HISTFILE=/root/.bash_history</span>      <span class="term_note">&lt;== 历史命令记录的放置文件，隐藏档</span>
HISTFILESIZE=1000        <span class="term_note">&lt;== 存起来(与上个变量有关)的文件之命令的最大纪录笔数。</span>
HISTSIZE=1000            <span class="term_note">&lt;== 目前环境下，可记录的历史命令最大笔数。</span>
HOSTTYPE=i686            <span class="term_note">&lt;== 主机安装的软件主要类型。我们用的是 i686 兼容机器软件</span>
IFS=$' \t\n'             <span class="term_note">&lt;== 默认的分隔符</span>
LINES=35                 <span class="term_note">&lt;== 目前的终端机下的最大行数</span>
MACHTYPE=i686-redhat-linux-gnu    <span class="term_note">&lt;== 安装的机器类型</span>
<span class="term_write">MAILCHECK=60</span>             <span class="term_note">&lt;== 与邮件有关。每 60 秒去扫瞄一次信箱有无新信！</span>
OLDPWD=/home             <span class="term_note">&lt;== 上个工作目录。我们可以用 cd - 来取用这个变量。</span>
OSTYPE=linux-gnu         <span class="term_note">&lt;== 操作系统的类型！</span>
PPID=20025               <span class="term_note">&lt;== 父程序的 PID (会在后续章节才介绍)</span>
<span class="term_write">PS1='[\u@\h \W]\$ '</span>      <span class="term_note">&lt;== PS1 就厉害了。这个是命令提示字符，也就是我们常见的
                             [root@www ~]# 或 [dmtsai ~]$ 的配置值啦！可以更动的！</span>
<span class="term_write">PS2='&gt; '           </span>      <span class="term_note">&lt;== 如果你使用跳脱符号 (\) 第二行以后的提示字符也</span>
name=VBird               <span class="term_note">&lt;== 刚刚配置的自定义变量也可以被列出来喔！</span>
<span class="term_write">$</span>                        <span class="term_note">&lt;== 目前这个 shell 所使用的 PID</span>
<span class="term_write">?</span>                        <span class="term_note">&lt;== 刚刚运行完命令的回传值。</span>
</pre></td></tr></tbody></table>

		<p>一般来说，不论是否为环境变量，只要跟我们目前这个 shell 的操作接口有关的变量，
		通常都会被配置为大写字符，也就是说，『<span class="text_import2">基本上，在 Linux 
		默认的情况中，使用{大写的字母}来配置的变量一般为系统内定需要的变量</span>』。
		OK！OK！那么上头那些变量当中，有哪些是比较重要的？大概有这几个吧！</p>

		<ul style="padding-left: 20px;">
		<li><span class="text_import1">PS1</span>：(提示字符的配置)<br><br>
			这是 PS1 (数字的 1 不是英文字母)，这个东西就是我们的『<span class="text_import2">命令提示字符</span>』喔！
			当我们每次按下 [Enter] 按键去运行某个命令后，最后要再次出现提示字符时，
			就会主动去读取这个变量值了。上头 PS1 内显示的是一些特殊符号，这些特殊符号可以显示不同的信息，
			每个 distributions 的 bash 默认的 PS1 变量内容可能有些许的差异，不要紧，『习惯你自己的习惯』就好了。
			你可以用 man bash (<a href="http://cn.linux.vbird.org/linux_basic/0320bash.php#ps3">注3</a>)去查询一下 PS1 的相关说明，以理解底下的一些符号意义。<br><br>
			<ul style="font-family: &#39;细明体&#39;; padding-left: 20px;">
			<li>\d ：可显示出『星期 月 日』的日期格式，如："Mon Feb 2"</li>
			<li>\H ：完整的主机名。举例来说，鸟哥的练习机为『www.vbird.tsai』</li>
			<li>\h ：仅取主机名在第一个小数点之前的名字，如鸟哥主机则为『www』后面省略</li>
			<li>\t ：显示时间，为 24 小时格式的『HH:MM:SS』</li>
			<li>\T ：显示时间，为 12 小时格式的『HH:MM:SS』</li>
			<li>\A ：显示时间，为 24 小时格式的『HH:MM』</li>
			<li>\@ ：显示时间，为 12 小时格式的『am/pm』样式</li>
			<li>\u ：目前使用者的账号名称，如『root』；</li>
			<li>\v ：BASH 的版本信息，如鸟哥的测试主板本为 3.2.25(1)，仅取『3.2』显示</li>
			<li>\w ：完整的工作目录名称，由根目录写起的目录名称。但家目录会以 ~ 取代；</li>
			<li>\W ：利用 basename 函数取得工作目录名称，所以仅会列出最后一个目录名。</li>
			<li>\# ：下达的第几个命令。</li>
			<li>\$ ：提示字符，如果是 root 时，提示字符为 # ，否则就是 $ 啰～</li>
			</ul><br>

			好了，让我们来看看 CentOS 默认的 PS1 内容吧：『[\u@\h \W]\$ 』，现在你知道那些反斜杠后的数据意义了吧？
			要注意喔！那个反斜杠后的数据为 PS1 的特殊功能，与 bash 的变量配置没关系啦！不要搞混了喔！
			那你现在知道为何你的命令提示字符是：『 [root@www ~]# 』了吧？
			好了，那么假设我想要有类似底下的提示字符：
			<blockquote class="text_import2">
			[root@www /home/dmtsai 16:50 #12]# </blockquote>
			那个 # 代表第 12 次下达的命令。那么应该如何配置 PS1 呢？可以这样啊：<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~ ]# <span class="term_command">cd /home</span>
[root@www home]# <span class="term_command">PS1='[\u@\h \w \A #\#]\$ '</span>
[root@www /home 17:02 #85]# 
<span class="term_say"># 看到了吗？提示字符变了！变的很有趣吧！其中，那个 #85 比较有趣，
# 如果您再随便输入几次 ls 后，该数字就会添加喔！为啥？上面有说明滴！</span>
</pre></td></tr></tbody></table>
		<br></li>

		<li><span class="text_import1">$</span>：(关于本 shell 的 PID)<br><br>
			钱字号本身也是个变量喔！这个咚咚代表的是『目前这个 Shell 的线程代号』，亦即是所谓的 PID (Process ID)。
			更多的程序观念，我们会在第四篇的时候提及。想要知道我们的 shell 的 PID ，就可以用：『
			echo $$ 』即可！出现的数字就是你的 PID 号码。<br><br></li>

		<li><a name="returnvar"></a><span class="text_import1">?</span>：(关于上个运行命令的回传值)<br><br>
			什么？问号也是一个特殊的变量？没错！在 bash 里面这个变量可重要的很！
			这个变量是：『<span class="text_import2">上一个运行的命令所回传的值</span>』，
			上面这句话的重点是『上一个命令』与『回传值』两个地方。<span class="text_import2">当我们运行某些命令时，
			这些命令都会回传一个运行后的代码。一般来说，如果成功的运行该命令，
			则会回传一个 0 值</span>，如果运行过程发生错误，就会回传『错误代码』才对！一般就是以非为 0 的数值来取代。
			我们以底下的例子来看看：<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">echo $SHELL</span>
/bin/bash                                  <span class="term_note">&lt;==可顺利显示！没有错误！</span>
[root@www ~]# <span class="term_command">echo $?</span>
0                                          <span class="term_note">&lt;==因为没问题，所以回传值为 0</span>
[root@www ~]# <span class="term_command">12name=VBird</span>
-bash: 12name=VBird: command not found     <span class="term_note">&lt;==发生错误了！bash回报有问题</span>
[root@www ~]# <span class="term_command">echo $?</span>
127                                        <span class="term_note">&lt;==因为有问题，回传错误代码(非为0)</span>
<span class="term_say"># 错误代码回传值依据软件而有不同，我们可以利用这个代码来搜寻错误的原因喔！</span>
[root@www ~]# <span class="term_command">echo $?</span>
0
<span class="term_say"># 咦！怎么又变成正确了？这是因为 "?" 只与『上一个运行命令』有关，
# 所以，我们上一个命令是运行『 echo $? 』，当然没有错误，所以是 0 没错！</span>
</pre></td></tr></tbody></table>
		<br></li>

		<li><span class="text_import1">OSTYPE, HOSTTYPE, MACHTYPE</span>：(主机硬件与核心的等级)<br><br>
			我们在<a href="http://cn.linux.vbird.org/linux_basic/0105computers.php#pc_cpu">第零章、计算器概论内的 CPU 等级</a>说明中谈过 CPU ，
			目前个人计算机的 CPU 主要分为 32/64 位，其中 32 位又可分为 i386, i586, i686，而 64 位则称为 x86_64。
			由于不同等级的 CPU 命令集不太相同，因此你的软件可能会针对某些 CPU 进行优化，以求取较佳的软件性能。
			所以软件就有 i386, i686 及 x86_64 之分。以目前 (2009) 的主流硬件来说，几乎都是 x86_64 的天下！
			但是毕竟旧机器还是非常多，以鸟哥的环境来说，我用 P-III 等级的计算机，所以上头就发现我的等级是 i686 啦！<br><br>

			要留意的是，较高阶的硬件通常会向下兼容旧有的软件，但较高阶的软件可能无法在旧机器上面安装！
			我们在<a href="http://cn.linux.vbird.org/linux_basic/0130designlinux.php#beforeinstall_distro">第三章</a>就曾说明过，
			这里再强调一次，你可以在 x86_64 的硬件上安装 i386 的 Linux 操作系统，但是你无法在 i686 的硬件上安装
			x86_64 的 Linux 操作系统！这点得要牢记在心！<br><br></li>
		</ul>

		<a name="export"></a><hr><ul class="list1"><li class="text_import1">export： 自定义变量转成环境变量</li></ul>

		<p>谈了 env 与 set 现在知道有所谓的环境变量与自定义变量，那么这两者之间有啥差异呢？其实这两者的差异在于『
		<span class="text_import2">该变量是否会被子程序所继续引用</span>』啦！唔！那么啥是父程序？子程序？
		这就得要了解一下命令的下达行为了。</p>

		<p>当你登陆 Linux 并取得一个 bash 之后，你的 bash 就是一个独立的程序，被称为 PID 的就是。
		接下来你在这个 bash 底下所下达的任何命令都是由这个 bash 所衍生出来的，那些被下达的命令就被称为子程序了。
		我们可以用底下的图示来简单的说明一下父程序与子程序的概念：</p>

		<center><img src="./鸟哥的 Linux 私房菜12 -- 学习 bash shell_files/ppid.gif" alt="程序相关性示意图" title="程序相关性示意图" border="1"><br>
		图 2.3.1、程序相关性示意图<br></center>

		<p>如上所示，我们在原本的 bash 底下运行另一个 bash ，结果操作的环境接口会跑到第二个 bash 去(就是子程序)，
		那原本的 bash 就会在暂停的情况 (睡着了，就是 sleep)。整个命令运行的环境是实线的部分！若要回到原本的 bash 去，
		就只有将第二个 bash 结束掉 (下达 exit 或 logout) 才行。更多的程序概念我们会在第四篇谈及，这里只要有这个概念即可。</p>

		<p>这个程序概念与变量有啥关系啊？关系可大了！因为<span class="text_import2">子程序仅会继承父程序的环境变量，
		子程序不会继承父程序的自定义变量</span>啦！所以你在原本 bash 的自定义变量在进入了子程序后就会消失不见，
		一直到你离开子程序并回到原本的父程序后，这个变量才会又出现！</p>

		<p>换个角度来想，也就是说，如果我能将自定义变量变成环境变量的话，那不就可以让该变量值继续存在于子程序了？
		呵呵！没错！此时，那个 export 命令就很有用啦！如你想要让该变量内容继续的在子程序中使用，那么就请运行：</p>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">export 变量名称</span>
</pre></td></tr></tbody></table>

		<p>这东西用在『<span class="text_import2">分享自己的变量配置给后来呼叫的文件或其他程序</span>』啦！
		像鸟哥常常在自己的主控文件后面呼叫其他附属文件(类似函式的功能)，但是主控文件与附属文件内都有相同的变量名称，
		若一再重复配置时，要修改也很麻烦，此时只要在原本的第一个文件内配置好『 export 变量 』，
		后面所呼叫的文件就能够使用这个变量配置了！而不需要重复配置，这非常实用于 shell script 当中喔！
		如果仅下达 export 而没有接变量时，那么此时将会把所有的『环境变量』秀出来喔！例如：</p>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">export</span>
declare -x HISTSIZE="1000"
declare -x HOME="/root"
declare -x HOSTNAME="www.vbird.tsai"
declare -x INPUTRC="/etc/inputrc"
declare -x LANG="en_US"
declare -x LOGNAME="root"
<span class="term_say"># 后面的鸟哥就都直接省略了！不然....浪费版面～ ^_^</span>
</pre></td></tr></tbody></table>

		<p>那如何将环境变量转成自定义变量呢？可以使用本章后续介绍的 <a href="http://cn.linux.vbird.org/linux_basic/0320bash.php#declare">declare</a> 呢！<br></p>
	</div>

	<hr><a name="variable_locale"></a><img src="./鸟哥的 Linux 私房菜12 -- 学习 bash shell_files/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">影响显示结果的语系变量 (locale)</span><br>
	<div class="block2">

		<p>还记得我们在<a href="http://cn.linux.vbird.org/linux_basic/0160startlinux.php#cmd_cmd_lang">第五章里面提到的语系问题</a>吗？
		就是当我们使用 man command 的方式去查询某个数据的说明文件时，该说明档的内容可能会因为我们使用的语系不同而产生乱码。
		另外，利用 ls 查询文件的时间时，也可能会有乱码出现在时间的部分。那个问题其实就是语系的问题啦。</p>

		<p>目前大多数的 Linux distributions 已经都是支持日渐流行的万国码了，也都支持大部分的国家语系。
		这有赖于 <a href="http://cn.linux.vbird.org/linux_basic/0320bash.php#ps4">i18n (注4)</a> 支持的帮助呢！
		那么我们的 Linux 到底支持了多少的语系呢？这可以由 locale 这个命令来查询到喔！</p>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">locale -a</span>
<span class="term_say">....(前面省略)....</span>
zh_TW
zh_TW.big5     <span class="term_note">&lt;==大五码的中文编码</span>
zh_TW.euctw
zh_TW.utf8     <span class="term_note">&lt;==万国码的中文编码</span>
zu_ZA
zu_ZA.iso88591
zu_ZA.utf8
</pre></td></tr></tbody></table>

		<p>正体中文语系至少支持了两种以上的编码，一种是目前还是很常见的 big5 ，另一种则是越来越热门的 utf-8 编码。
		那么我们如何修订这些编码呢？其实可以透过底下这些变量的说：</p>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">locale</span>  <span class="term_note">&lt;==后面不加任何选项与参数即可！</span>
LANG=en_US                   <span class="term_note">&lt;==主语言的环境</span>
LC_CTYPE="en_US"             <span class="term_note">&lt;==字符(文字)辨识的编码</span>
LC_NUMERIC="en_US"           <span class="term_note">&lt;==数字系统的显示信息</span>
LC_TIME="en_US"              <span class="term_note">&lt;==时间系统的显示数据</span>
LC_COLLATE="en_US"           <span class="term_note">&lt;==字符串的比较与排序等</span>
LC_MONETARY="en_US"          <span class="term_note">&lt;==币值格式的显示等</span>
LC_MESSAGES="en_US"          <span class="term_note">&lt;==信息显示的内容，如菜单、错误信息等</span>
LC_ALL=                      <span class="term_note">&lt;==整体语系的环境</span>
<span class="term_say">....(后面省略)....</span>
</pre></td></tr></tbody></table>

		<p>基本上，你可以逐一配置每个与语系有关的变量数据，但事实上，如果其他的语系变量都未配置，
		且<span class="text_import2">你有配置 LANG 或者是 LC_ALL 时，则其他的语系变量就会被这两个变量所取代！</span>
		这也是为什么我们在 Linux 当中，通常说明仅配置 LANG 这个变量而已，因为他是最主要的配置变量！
		好了，那么你应该要觉得奇怪的是，为什么在 Linux 主机的终端机接口 (tty1 ~ tty6) 
		的环境下，如果配置『 LANG=zh_TW.big5 』这个配置值生效后，使用 man 或者其他信息输出时，
		都会有一堆乱码，尤其是使用 ls -l 这个参数时？</p>

		<p>因为在 Linux 主机的终端机接口环境下是无法显示像中文这么复杂的编码文字，
		所以就会产生乱码了。也就是如此，我们才会必须要在 tty1 ~ tty6 的环境下，
		加装一些中文化接口的软件，才能够看到中文啊！不过，如果你是在 MS Windows 
		主机以远程联机服务器的软件联机到主机的话，那么，嘿嘿！其实文字接口确实是可以看到中文的。
		此时反而你得要在 LANG 配置中文编码才好呢！</p>

		<div style="padding: 10pt 0pt;" align="right"><table width="90%"><tbody><tr><td><b>Tips:</b><br><span style="color: rgb(0, 144, 0);"><font size="-1">		无论如何，如果发生一些乱码的问题，那么配置系统里面保有的语系编码，
		例如： en_US 或 en_US.utf8 等等的配置，应该就 OK 的啦！好了，那么系统默认支持多少种语系呢？
		当我们使用 locale 时，系统是列出目前 Linux 主机内保有的语系文件，
		这些语系文件都放置在： <span class="text_import2">/usr/lib/locale/</span> 这个目录中。
		</font></span></td><td><img src="./鸟哥的 Linux 私房菜12 -- 学习 bash shell_files/vbird_face.gif" alt="鸟哥的图示" title="鸟哥的图示"></td></tr></tbody></table></div>
		<p>你当然可以让每个使用者自己去调整自己喜好的语系，但是整体系统默认的语系定义在哪里呢？
		其实就是在 /etc/sysconfig/i18n 啰！这个文件在 CentOS 5.x 的内容有点像这样：</p>


<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">cat /etc/sysconfig/i18n</span>
LANG="zh_TW.UTF-8"
</pre></td></tr></tbody></table>

		<p>因为鸟哥在<a href="http://cn.linux.vbird.org/linux_basic/0157installcentos5.php">第四章的安装时</a>选择的是中文语系安装画面，
		所以这个文件默认就会使用中文编码啦！你也可以自行将他改成你想要的语系编码即可。</p>

		<div style="padding: 10pt 0pt;" align="right"><table width="90%"><tbody><tr><td><b>Tips:</b><br><span style="color: rgb(0, 144, 0);"><font size="-1">		假设你有一个纯文本文件原本是在 Windows 底下创建的，那么这个文件默认应该是 big5 的编码格式。
		在你将这个文件上传到 Linux 主机后，在 X window 底下打开时，咦！怎么中文字通通变成乱码了？
		别担心！因为如上所示， i18n 默认是万国码系统嘛！你只要将开启该文件的软件编码由 utf8 
		改成 big5 就能够看到正确的中文了！
		</font></span></td><td><img src="./鸟哥的 Linux 私房菜12 -- 学习 bash shell_files/vbird_face.gif" alt="鸟哥的图示" title="鸟哥的图示"></td></tr></tbody></table></div>	</div>

	<hr><a name="variable_range"></a><img src="./鸟哥的 Linux 私房菜12 -- 学习 bash shell_files/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">变量的有效范围</span><br>
	<div class="block2">
		<p>什么？变量也有使用的『范围』？没错啊～我们在上头的 <a href="http://cn.linux.vbird.org/linux_basic/0320bash.php#export">export</a> 
		命令说明中，就提到了这个概念了。如果在跑程序的时候，有父程序与子程序的不同程序关系时，
		则『变量』可否被引用与 export 有关。被 export 后的变量，我们可以称他为『环境变量』！
		环境变量可以被子程序所引用，但是其他的自定义变量内容就不会存在于子程序中。</p>

		<div style="padding: 10pt 0pt;" align="right"><table width="90%"><tbody><tr><td><b>Tips:</b><br><span style="color: rgb(0, 144, 0);"><font size="-1">		在某些不同的书籍会谈到『全局变量, global variable』与『局部变量, local variable』。
		基本上你可以这样看待：<br>环境变量=全局变量<br>自定义变量=局部变量
		</font></span></td><td><img src="./鸟哥的 Linux 私房菜12 -- 学习 bash shell_files/vbird_face.gif" alt="鸟哥的图示" title="鸟哥的图示"></td></tr></tbody></table></div>
		<p>在学理方面，为什么环境变量的数据可以被子程序所引用呢？这是因为内存配置的关系！理论上是这样的：</p>
		<ul style="padding-left: 25px;">
		<li>当启动一个 shell，操作系统会分配一记忆区块给 shell 使用，此内存内之变量可让子程序取用</li>
		<li>若在父程序利用 export 功能，可以让自定义变量的内容写到上述的记忆区块当中(环境变量)；</li>
		<li>当加载另一个 shell 时 (亦即启动子程序，而离开原本的父程序了)，子 shell 可以将父 shell 
			的环境变量所在的记忆区块导入自己的环境变量区块当中。</li>
		</ul>
		<p>透过这样的关系，我们就可以让某些变量在相关的程序之间存在，以帮助自己更方便的操作环境喔！
		不过要提醒的是，这个『环境变量』与『bash 的操作环境』意思不太一样，举例来说， PS1 并不是环境变量，
		但是这个 PS1 会影响到 bash 的接口 (提示字符嘛)！相关性要厘清喔！^_^</p>
	</div>

	<hr><a name="variable_read"></a><img src="./鸟哥的 Linux 私房菜12 -- 学习 bash shell_files/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">变量键盘读取、数组与宣告： 
	read, array, declare</span><br>
	<div class="block2">
		<p>我们上面提到的变量配置功能，都是由命令列直接配置的，那么，可不可以让用户能够经由键盘输入？
		什么意思呢？是否记得某些程序运行的过程当中，会等待使用者输入 "yes/no" 之类的信息啊？
		在 bash 里面也有相对应的功能喔！此外，我们还可以宣告这个变量的属性，
		例如：数组或者是数字等等的。底下就来看看吧！<br><br></p>

		<a name="read"></a><hr><ul class="list1"><li class="text_import1">read</li></ul>

		<p>要读取来自键盘输入的变量，就是用 read 这个命令了。这个命令最常被用在 shell script 的撰写当中，
		想要跟使用者对谈？用这个命令就对了。关于 script 的写法，我们会在第十三章介绍，底下先来瞧一瞧 read 的相关语法吧！</p>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">read [-pt] variable</span>
<span class="term_say">选项与参数：
-p  ：后面可以接提示字符！
-t  ：后面可以接等待的『秒数！』这个比较有趣～不会一直等待使用者啦！</span>

<span class="term_hd">范例一：让用户由键盘输入一内容，将该内容变成名为 atest 的变量</span>
[root@www ~]# <span class="term_command">read atest</span>
<span class="term_command">This is a test</span>        <span class="term_note">&lt;==此时光标会等待你输入！请输入左侧文字看看</span>
[root@www ~]# <span class="term_command">echo $atest</span>
This is a test          <span class="term_note">&lt;==你刚刚输入的数据已经变成一个变量内容！</span>

<span class="term_hd">范例二：提示使用者 30 秒内输入自己的大名，将该输入字符串作为名为 named 的变量内容</span>
[root@www ~]# <span class="term_command">read -p "Please keyin your name: " -t 30 named</span>
Please keyin your name: <span class="term_command">VBird Tsai</span>   <span class="term_note">&lt;==注意看，会有提示字符喔！</span>
[root@www ~]# <span class="term_command">echo $named</span>
VBird Tsai        <span class="term_note">&lt;==输入的数据又变成一个变量的内容了！</span>
</pre></td></tr></tbody></table>

		<p>read 之后不加任何参数，直接加上变量名称，那么底下就会主动出现一个空白行等待你的输入(如范例一)。
		如果加上 -t 后面接秒数，例如上面的范例二，那么 30 秒之内没有任何动作时，
		该命令就会自动略过了～如果是加上 -p ，嘿嘿！在输入的光标前就会有比较多可以用的提示字符给我们参考！
		在命令的下达里面，比较美观啦！ ^_^<br><br></p>

		<a name="declare"></a><hr><ul class="list1"><li class="text_import1">declare / typeset</li></ul>

		<p>declare 或 typeset 是一样的功能，就是在『<span class="text_import2">宣告变量的类型</span>』。如果使用 
		declare 后面并没有接任何参数，那么 bash 就会主动的将所有的变量名称与内容通通叫出来，就好像使用 set 一样啦！
		那么 declare 还有什么语法呢？看看先：</p>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">declare [-aixr] variable</span>
<span class="term_say">选项与参数：
-a  ：将后面名为 variable 的变量定义成为数组 (array) 类型
-i  ：将后面名为 variable 的变量定义成为整数数字 (integer) 类型
-x  ：用法与 export 一样，就是将后面的 variable 变成环境变量；
-r  ：将变量配置成为 readonly 类型，该变量不可被更改内容，也不能 unset</span>

<span class="term_hd">范例一：让变量 sum 进行 100+300+50 的加总结果</span>
[root@www ~]# <span class="term_command">sum=100+300+50</span>
[root@www ~]# <span class="term_command">echo $sum</span>
100+300+50  <span class="term_note">&lt;==咦！怎么没有帮我计算加总？因为这是文字型态的变量属性啊！</span>
[root@www ~]# <span class="term_command">declare -i sum=100+300+50</span>
[root@www ~]# <span class="term_command">echo $sum</span>
450         <span class="term_note">&lt;==瞭乎？？</span>
</pre></td></tr></tbody></table>

		<p>由于在默认的情况底下， bash 对于变量有几个基本的定义：</p>
		<ul class="text_import2">
		<li>变量类型默认为『字符串』，所以若不指定变量类型，则 1+2 为一个『字符串』而不是『计算式』。
			所以上述第一个运行的结果才会出现那个情况的；</li>
		<li>bash 环境中的数值运算，默认最多仅能到达整数形态，所以 1/3 结果是 0；</li>
		</ul>

		<p>现在你晓得为啥你需要进行变量宣告了吧？如果需要非字符串类型的变量，那就得要进行变量的宣告才行啦！
		底下继续来玩些其他的 declare 功能。</p>

<table class="term"><tbody><tr><td class="term"><pre><span class="term_hd">范例二：将 sum 变成环境变量</span>
[root@www ~]# <span class="term_command">declare -x sum</span>
[root@www ~]# <span class="term_command">export | grep sum</span>
declare -ix sum="450"  <span class="term_note">&lt;==果然出现了！包括有 i 与 x 的宣告！</span>

<span class="term_hd">范例三：让 sum 变成只读属性，不可更动！</span>
[root@www ~]# <span class="term_command">declare -r sum</span>
[root@www ~]# <span class="term_command">sum=tesgting</span>
-bash: sum: readonly variable  <span class="term_note">&lt;==老天爷～不能改这个变量了！</span>

<span class="term_hd">范例四：让 sum 变成非环境变量的自定义变量吧！</span>
[root@www ~]# <span class="term_command">declare +x sum</span>  <span class="term_note">&lt;== 将 - 变成 + 可以进行『取消』动作</span>
[root@www ~]# <span class="term_command">declare -p sum</span>  <span class="term_note">&lt;== -p 可以单独列出变量的类型</span>
declare -ir sum="450" <span class="term_note">&lt;== 看吧！只剩下 i, r 的类型，不具有 x 啰！</span>
</pre></td></tr></tbody></table>

		<p>declare 也是个很有用的功能～尤其是当我们需要使用到底下的数组功能时，
		他也可以帮我们宣告数组的属性喔！不过，老话一句，数组也是在 shell script 比较常用的啦！
		比较有趣的是，如果你不小心将变量配置为『只读』，通常得要注销再登陆才能复原该变量的类型了！ @_@<br><br></p>

		<a name="array"></a><hr><ul class="list1"><li class="text_import1">数组 (array) 变量类型</li></ul>

		<p>某些时候，我们必须使用数组来宣告一些变量，这有什么好处啊？在一般人的使用上，
		果然是看不出来有什么好处的！不过，如果您曾经写过程序的话，那才会比较了解数组的意义～
		数组对写数值程序的设计师来说，可是不能错过学习的重点之一哩！好！不啰唆～
		那么要如何配置数组的变量与内容呢？在 bash 里头，数组的配置方式是：</p>

		<blockquote class="text_import2">var[index]=content</blockquote>

		<p>意思是说，我有一个数组名为 var ，而这个数组的内容为 var[1]=小明， var[2]=大明， 
		var[3]=好明 .... 等等，那个 index 就是一些数字啦，重点是用中刮号 ([ ]) 来配置的。
		目前我们 bash 提供的是一维数组。老实说，如果您不必写一些复杂的程序，
		那么这个数组的地方，可以先略过，等到有需要再来学习即可！因为要制作出数组，
		通常与循环或者其他判断式交互使用才有比较高的存在意义！</p>

<table class="term"><tbody><tr><td class="term"><pre><span class="term_hd">范例：配置上面提到的 var[1] ～ var[3] 的变量。</span>
[root@www ~]# <span class="term_command">var[1]="small min"</span>
[root@www ~]# <span class="term_command">var[2]="big min"</span>
[root@www ~]# <span class="term_command">var[3]="nice min"</span>
[root@www ~]# <span class="term_command">echo "${var[1]}, ${var[2]}, ${var[3]}"</span>
small min, big min, nice min
</pre></td></tr></tbody></table>

		<p>数组的变量类型比较有趣的地方在于『读取』，一般来说，<span class="text_import2">建议直接以 ${数组}
		的方式来读取</span>，比较正确无误的啦！</p>
	</div>

	<hr><a name="variable_ulimit"></a><img src="./鸟哥的 Linux 私房菜12 -- 学习 bash shell_files/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">与文件系统及程序的限制关系：
	ulimit</span><br>
	<div class="block2">
		<p>想象一个状况：我的 Linux 主机里面同时登陆了十个人，这十个人不知怎么搞的，
		同时开启了 100 个文件，每个文件的大小约 10MBytes ，请问一下，
		我的 Linux 主机的内存要有多大才够？ 10*100*10 = 10000 MBytes = 10GBytes ...
		老天爷，这样，系统不挂点才有鬼哩！为了要预防这个情况的发生，所以<span class="text_import2">我们的 bash 
		是可以『限制用户的某些系统资源』的，包括可以开启的文件数量，
		可以使用的 CPU 时间，可以使用的内存总量等等</span>。如何配置？用 ulimit 吧！</p>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">ulimit [-SHacdfltu] [配额]</span>
<span class="term_say">选项与参数：
-H  ：hard limit ，严格的配置，必定不能超过这个配置的数值；
-S  ：soft limit ，警告的配置，可以超过这个配置值，但是若超过则有警告信息。
      在配置上，通常 soft 会比 hard 小，举例来说，soft 可配置为 80 而 hard 
      配置为 100，那么你可以使用到 90 (因为没有超过 100)，但介于 80~100 之间时，
      系统会有警告信息通知你！
-a  ：后面不接任何选项与参数，可列出所有的限制额度；
-c  ：当某些程序发生错误时，系统可能会将该程序在内存中的信息写成文件(除错用)，
      这种文件就被称为核心文件(core file)。此为限制每个核心文件的最大容量。
-f  ：此 shell 可以创建的最大文件容量(一般可能配置为 2GB)单位为 Kbytes
-d  ：程序可使用的最大断裂内存(segment)容量；
-l  ：可用于锁定 (lock) 的内存量
-t  ：可使用的最大 CPU 时间 (单位为秒)
-u  ：单一用户可以使用的最大程序(process)数量。</span>

<span class="term_hd">范例一：列出你目前身份(假设为root)的所有限制数据数值</span>
[root@www ~]# <span class="term_command">ulimit -a</span>
core file size          (blocks, -c) 0          <span class="term_note">&lt;==只要是 0 就代表没限制</span>
data seg size           (kbytes, -d) unlimited
scheduling priority             (-e) 0
<span class="term_write">file size               (blocks, -f) unlimited</span>  <span class="term_note">&lt;==可创建的单一文件的大小</span>
pending signals                 (-i) 11774
max locked memory       (kbytes, -l) 32
max memory size         (kbytes, -m) unlimited
<span class="term_write">open files                      (-n) 1024</span>       <span class="term_note">&lt;==同时可开启的文件数量</span>
pipe size            (512 bytes, -p) 8
POSIX message queues     (bytes, -q) 819200
real-time priority              (-r) 0
stack size              (kbytes, -s) 10240
cpu time               (seconds, -t) unlimited
max user processes              (-u) 11774
virtual memory          (kbytes, -v) unlimited
file locks                      (-x) unlimited

<span class="term_hd">范例二：限制用户仅能创建 10MBytes 以下的容量的文件</span>
[root@www ~]# <span class="term_command">ulimit -f 10240</span>
[root@www ~]# <span class="term_command">ulimit -a</span>
file size               (blocks, -f) 10240 <span class="term_note">&lt;==最大量为10240Kbyes，相当10Mbytes</span>
[root@www ~]# <span class="term_command">dd if=/dev/zero of=123 bs=1M count=20</span>
File size limit exceeded <span class="term_note">&lt;==尝试创建 20MB 的文件，结果失败了！</span>
</pre></td></tr></tbody></table>

		<p>还记得我们在<a href="http://cn.linux.vbird.org/linux_basic/0230filesystem.php">第八章 Linux 磁盘文件系统</a>里面提到过，单一 filesystem
		能够支持的单一文件大小与 block 的大小有关。例如 block size 为 1024 byte 时，单一文件可达
		16GB 的容量。但是，我们可以用 ulimit 来限制使用者可以创建的文件大小喔！
		利用 ulimit -f 就可以来配置了！例如上面的范例二，要注意单位喔！单位是 Kbytes。
		若改天你一直无法创建一个大容量的文件，记得瞧一瞧 ulimit 的信息喔！</p>

		<div style="padding: 10pt 0pt;" align="right"><table width="90%"><tbody><tr><td><b>Tips:</b><br><span style="color: rgb(0, 144, 0);"><font size="-1">		想要复原 ulimit 的配置最简单的方法就是注销再登陆，否则就是得要重新以 ulimit 配置才行！
		不过，要注意的是，一般身份使用者如果以 ulimit 配置了 -f 的文件大小，
		那么他『只能继续减小文件容量，不能添加文件容量喔！』另外，若想要管控使用者的 ulimit 限值，
		可以参考<a href="http://cn.linux.vbird.org/linux_basic/0410accountmanager.php#limits">第十四章的 pam</a> 的介绍。
		</font></span></td><td><img src="./鸟哥的 Linux 私房菜12 -- 学习 bash shell_files/vbird_face.gif" alt="鸟哥的图示" title="鸟哥的图示"></td></tr></tbody></table></div>	</div>

	<hr><a name="variable_other"></a><img src="./鸟哥的 Linux 私房菜12 -- 学习 bash shell_files/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">变量内容的删除、取代与替换</span><br>
	<div class="block2">
		<p>变量除了可以直接配置来修改原本的内容之外，有没有办法透过简单的动作来将变量的内容进行微调呢？
		举例来说，进行变量内容的删除、取代与替换等！是可以的！我们可以透过几个简单的小步骤来进行变量内容的微调喔！
		底下就来试试看！<br><br></p>

		<a name="variable_other_replace"></a>
		<hr><ul class="list1"><li class="text_import1">变量内容的删除与取代</li></ul>

		<p>变量的内容可以很简单的透过几个咚咚来进行删除喔！我们使用 PATH 这个变量的内容来做测试好了。
		请你依序进行底下的几个例子来玩玩，比较容易感受的到鸟哥在这里想要表达的意义：</p>

<table class="term"><tbody><tr><td class="term"><pre><span class="term_hd">范例一：先让小写的 path 自定义变量配置的与 PATH 内容相同</span>
[root@www ~]# <span class="term_command">path=${PATH}</span>
[root@www ~]# <span class="term_command">echo $path</span>
/usr/kerberos/sbin:/usr/kerberos/bin:/usr/local/sbin:/usr/local/bin:/sbin:/bin:
/usr/sbin:/usr/bin:/root/bin  <span class="term_note">&lt;==这两行其实是同一行啦！</span>

<span class="term_hd">范例二：假设我不喜欢 kerberos，所以要将前两个目录删除掉，如何显示？</span>
[root@www ~]# <span class="term_command">echo ${path#/*kerberos/bin:}</span>
/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/root/bin
</pre></td></tr></tbody></table>

		<p>上面这个范例很有趣的！他的重点可以用底下这张表格来说明：</p>

<table class="term"><tbody><tr><td class="term"><pre><span class="term_command">${</span>variable#/*kerberos/bin:<span class="term_command">}</span>
<span class="term_say">   上面的特殊字体部分是关键词！用在这种删除模式所必须存在的</span>

${<span class="term_command">variable</span>#/*kerberos/bin:}
<span class="term_say">   这就是原本的变量名称，以上面范例二来说，这里就填写 path 这个『变量名称』啦！</span>

${variable<span class="term_command">#</span>/*kerberos/bin:}
<span class="term_say">   这是重点！代表『从变量内容的最前面开始向右删除』，且仅删除最短的那个</span>

${variable#<span class="term_command">/*kerberos/bin:</span>}
<span class="term_say">   代表要被删除的部分，由于 # 代表由前面开始删除，所以这里便由开始的 / 写起。
   需要注意的是，我们还可以透过通配符 * 来取代 0 到无穷多个任意字符</span>

<span class="term_say">   以上面范例二的结果来看， path 这个变量被删除的内容如下所示：</span>
<span style="text-decoration: line-through;">/usr/kerberos/sbin:/usr/kerberos/bin:</span>/usr/local/sbin:/usr/local/bin:/sbin:/bin:
/usr/sbin:/usr/bin:/root/bin  <span class="term_note">&lt;==这两行其实是同一行啦！</span>
</pre></td></tr></tbody></table>

		<p>很有趣吧！这样了解了 # 的功能了吗？接下来让我们来看看底下的范例三！</p>

<table class="term"><tbody><tr><td class="term"><pre><span class="term_hd">范例三：我想要删除前面所有的目录，仅保留最后一个目录</span>
[root@www ~]# <span class="term_command">echo ${path#/*:}</span>
/usr/kerberos/bin:/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:
/root/bin     <span class="term_note">&lt;==这两行其实是同一行啦！</span>
<span class="term_say"># 由于一个 # 仅删除掉最短的那个，因此他删除的情况可以用底下的删除线来看：
# <span style="text-decoration: line-through;">/usr/kerberos/sbin:</span>/usr/kerberos/bin:/usr/local/sbin:/usr/local/bin:/sbin:/bin:
# /usr/sbin:/usr/bin:/root/bin  <span class="term_note">&lt;==这两行其实是同一行啦！</span></span>

[root@www ~]# <span class="term_command">echo ${path##/*:}</span>
/root/bin
<span class="term_say"># 嘿！多加了一个 # 变成 ## 之后，他变成『删除掉最长的那个数据』！亦即是：
# <span style="text-decoration: line-through;">/usr/kerberos/sbin:/usr/kerberos/bin:/usr/local/sbin:/usr/local/bin:/sbin:/bin:</span>
# <span style="text-decoration: line-through;">/usr/sbin:/usr/bin:</span>/root/bin  <span class="term_note">&lt;==这两行其实是同一行啦！</span></span>
</pre></td></tr></tbody></table>

		<p>非常有趣！不是吗？因为在 PATH 这个变量的内容中，每个目录都是以冒号『:』隔开的，
		所以要从头删除掉目录就是介于斜线 (/) 到冒号 (:) 之间的数据！但是 PATH 中不止一个冒号 (:) 啊！
		所以 # 与 ## 就分别代表：</p>

		<ul class="text_import2" style="font-family: &#39;细明体&#39;;">
		<li># ：符合取代文字的『最短的』那一个；</li>
		<li>##：符合取代文字的『最长的』那一个</li></ul>

		<p>上面谈到的是『从前面开始删除变量内容』，那么如果想要『从后面向前删除变量内容』呢？
		这个时候就得使用百分比 (%) 符号了！来看看范例四怎么做吧！</p>

<table class="term"><tbody><tr><td class="term"><pre><span class="term_hd">范例四：我想要删除最后面那个目录，亦即从 : 到 bin 为止的字符串</span>
[root@www ~]# <span class="term_command">echo ${path%:*bin}</span>
/usr/kerberos/sbin:/usr/kerberos/bin:/usr/local/sbin:/usr/local/bin:/sbin:/bin:
/usr/sbin:/usr/bin  <span class="term_note">&lt;==注意啊！最后面一个目录不见去！</span>
<span class="term_say"># 这个 % 符号代表由最后面开始向前删除！所以上面得到的结果其实是来自如下：
# /usr/kerberos/sbin:/usr/kerberos/bin:/usr/local/sbin:/usr/local/bin:/sbin:/bin:
# /usr/sbin:/usr/bin:<span style="text-decoration: line-through;">/root/bin</span>  <span class="term_note">&lt;==这两行其实是同一行啦！</span></span>

<span class="term_hd">范例五：那如果我只想要保留第一个目录呢？</span>
[root@www ~]# <span class="term_command">echo ${path%%:*bin}</span>
/usr/kerberos/sbin
<span class="term_say"># 同样的， %% 代表的则是最长的符合字符串，所以结果其实是来自如下：
# /usr/kerberos/sbin<span style="text-decoration: line-through;">:/usr/kerberos/bin:/usr/local/sbin:/usr/local/bin:/sbin:/bin:</span>
# <span style="text-decoration: line-through;">/usr/sbin:/usr/bin:/root/bin</span>  <span class="term_note">&lt;==这两行其实是同一行啦！</span></span>
</pre></td></tr></tbody></table>

		<p>由于我是想要由变量内容的后面向前面删除，而我这个变量内容最后面的结尾是『/root/bin』，
		所以你可以看到上面我删除的数据最终一定是『bin』，亦即是『:*bin』那个 * 代表通配符！
		至于 % 与 %% 的意义其实与 # 及 ## 类似！这样理解否？</p>

<table border="1" cellpadding="5" cellspacing="0" width="90%"><tbody><tr><td>
例题：<div class="block2">
假设你是 root ，那你的 MAIL 变量应该是 /var/spool/mail/root 。假设你只想要保留最后面那个档名 (root)，
前面的目录名称都不要了，如何利用 $MAIL 变量来达成？
</div>
答：<div class="block2">
题意其实是这样『<span style="text-decoration: line-through;">/var/spool/mail/</span>root』，亦即删除掉两条斜线间的所有数据(最长符合)。
这个时候你就可以这样做即可：

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">echo ${MAIL##/*/}</span>
</pre></td></tr></tbody></table>
相反的，如果你只想要拿掉文件名，保留目录的名称，亦即是『/var/spool/mail<span style="text-decoration: line-through;">/root</span>』
(最短符合)。但假设你并不知道结尾的字母为何，此时你可以利用通配符来处理即可，如下所示：
<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">echo ${MAIL%/*}</span>
</pre></td></tr></tbody></table>
</div>
</td></tr></tbody></table><br>

		<p>了解了删除功能后，接下来谈谈取代吧！继续玩玩范例六啰！</p>

<table class="term"><tbody><tr><td class="term"><pre><span class="term_hd">范例六：将 path 的变量内容内的 sbin 取代成大写 SBIN：</span>
[root@www ~]# <span class="term_command">echo ${path/sbin/SBIN}</span>
/usr/kerberos/<span class="term_write">SBIN</span>:/usr/kerberos/bin:/usr/local/sbin:/usr/local/bin:/sbin:/bin:
/usr/sbin:/usr/bin:/root/bin
<span class="term_say"># 这个部分就容易理解的多了！关键词在于那两个斜线，两斜线中间的是旧字符串
# 后面的是新字符串，所以结果就会出现如上述的特殊字体部分啰！</span>

[root@www ~]# <span class="term_command">echo ${path//sbin/SBIN}</span>
/usr/kerberos/<span class="term_write">SBIN</span>:/usr/kerberos/bin:/usr/local/<span class="term_write">SBIN</span>:/usr/local/bin:/<span class="term_write">SBIN</span>:/bin:
/usr/<span class="term_write">SBIN</span>:/usr/bin:/root/bin
<span class="term_say"># 如果是两条斜线，那么就变成所有符合的内容都会被取代喔！</span>
</pre></td></tr></tbody></table>

		<p>我们将这部份作个总结说明一下：</p>

<table bgcolor="lightyellow" border="1" cellpadding="3" cellspacing="0" width="95%">
<tbody><tr align="center" bgcolor="#182448"><td width="180"><font color="#FFFFFF">变量配置方式</font></td><td><font color="#FFFFFF">说明</font></td></tr>
<tr><td style="font-family: &#39;细明体&#39;;"><u>${</u>变量<u>#</u>关键词<u>}</u><br><u>${</u>变量<u>##</u>关键词<u>}</u></td>
	<td style="font-size: 10pt;">若变量内容从头开始的数据符合『关键词』，则将符合的最短数据删除<br>
	若变量内容从头开始的数据符合『关键词』，则将符合的最长数据删除</td></tr>
<tr><td style="font-family: &#39;细明体&#39;;"><u>${</u>变量<u>%</u>关键词<u>}</u><br><u>${</u>变量<u>%%</u>关键词<u>}</u></td>
	<td style="font-size: 10pt;">若变量内容从尾向前的数据符合『关键词』，则将符合的最短数据删除<br>
	若变量内容从尾向前的数据符合『关键词』，则将符合的最长数据删除</td></tr>
<tr><td style="font-family: &#39;细明体&#39;;"><u>${</u>变量<u>/</u>旧字符串<u>/</u>新字符串<u>}</u><br><u>${</u>变量<u>//</u>旧字符串<u>/</u>新字符串<u>}</u></td>
	<td style="font-size: 10pt;">若变量内容符合『旧字符串』则『第一个旧字符串会被新字符串取代』<br>
	若变量内容符合『旧字符串』则『全部的旧字符串会被新字符串取代』</td></tr>
</tbody></table><br>

		<a name="variable_other_re"></a>
		<hr><ul class="list1"><li class="text_import1">变量的测试与内容替换</li></ul>

		<p>在某些时刻我们常常需要『判断』某个变量是否存在，若变量存在则使用既有的配置，若变量不存在则给予一个常用的配置。
		我们举底下的例子来说明好了，看看能不能较容易被你所理解呢！</p>

<table class="term"><tbody><tr><td class="term"><pre><span class="term_hd">范例一：测试一下是否存在 username 这个变量，若不存在则给予 username 内容为 root</span>
[root@www ~]# <span class="term_command">echo $username</span>
           <span class="term_note">&lt;==由于出现空白，所以 username 可能不存在，也可能是空字符串</span>
[root@www ~]# <span class="term_command">username=${username-root}</span>
[root@www ~]# <span class="term_command">echo $username</span>
root       <span class="term_note">&lt;==因为 username 没有配置，所以主动给予名为 root 的内容。</span>
[root@www ~]# <span class="term_command">username="vbird tsai"</span> <span class="term_note">&lt;==主动配置 username 的内容</span>
[root@www ~]# <span class="term_command">username=${username-root}</span>
[root@www ~]# <span class="term_command">echo $username</span>
vbird tsai <span class="term_note">&lt;==因为 username 已经配置了，所以使用旧有的配置而不以 root 取代</span>
</pre></td></tr></tbody></table>

		<p>在上面的范例中，重点在于减号『 - 』后面接的关键词！基本上你可以这样理解：</p>

<table class="term"><tbody><tr><td class="term"><pre><span class="term_command">new_var</span>=${old_var-content}
   <span class="term_say">新的变量，主要用来取代旧变量。新旧变量名称其实常常是一样的</span>

new_var=<span class="term_command">${</span>old_var<span class="term_command">-</span>content<span class="term_command">}</span>
   <span class="term_say">这是本范例中的关键词部分！必须要存在的哩！</span>

new_var=${<span class="term_command">old_var</span>-content}
   <span class="term_say">旧的变量，被测试的项目！</span>

new_var=${old_var-<span class="term_command">content</span>}
   <span class="term_say">变量的『内容』，在本范例中，这个部分是在『给予未配置变量的内容』</span>
</pre></td></tr></tbody></table>

		<p>不过这还是有点问题！因为 username 可能已经被配置为『空字符串』了！果真如此的话，那你还可以使用底下的范例来给予
		username 的内容成为 root 喔！</p>

<table class="term"><tbody><tr><td class="term"><pre><span class="term_hd">范例二：若 username 未配置或为空字符串，则将 username 内容配置为 root</span>
[root@www ~]# <span class="term_command">username=""</span>
[root@www ~]# <span class="term_command">username=${username-root}</span>
[root@www ~]# <span class="term_command">echo $username</span>
      <span class="term_note">&lt;==因为 username 被配置为空字符串了！所以当然还是保留为空字符串！</span>
[root@www ~]# <span class="term_command">username=${username:-root}</span>
[root@www ~]# <span class="term_command">echo $username</span>
root  <span class="term_note">&lt;==加上『 : 』后若变量内容为空或者是未配置，都能够以后面的内容替换！</span>
</pre></td></tr></tbody></table>

		<p>在大括号内有没有冒号『 : 』的差别是很大的！加上冒号后，被测试的变量未被配置或者是已被配置为空字符串时，
		都能够用后面的内容 (本例中是使用 root 为内容) 来替换与配置！这样可以了解了吗？除了这样的测试之外，
		还有其他的测试方法喔！鸟哥将他整理如下：</p>

		<div style="padding: 10pt 0pt;" align="right"><table width="90%"><tbody><tr><td><b>Tips:</b><br><span style="color: rgb(0, 144, 0);"><font size="-1">		底下的例子当中，那个 var 与 str 为变量，我们想要针对 str 是否有配置来决定 var 的值喔！
		一般来说， str: 代表『str 没配置或为空的字符串时』；至于 str 则仅为『没有该变量』。
		</font></span></td><td><img src="./鸟哥的 Linux 私房菜12 -- 学习 bash shell_files/vbird_face.gif" alt="鸟哥的图示" title="鸟哥的图示"></td></tr></tbody></table></div>
<a name="20070715"></a>
<table class="fontwidth" bgcolor="lightyellow" border="1" cellpadding="3" cellspacing="0" width="95%"> 
<tbody><tr align="center" bgcolor="#182448"><td><font color="#FFFFFF">变量配置方式</font></td><td><font color="#FFFFFF">str 没有配置</font></td>
	<td><font color="#FFFFFF">str 为空字符串</font></td><td><font color="#FFFFFF">str 已配置非为空字符串</font></td></tr>
<tr>	<td>var=${str-expr}</td><td>var=expr</td><td>var=</td><td>var=$str</td></tr>
<tr>	<td>var=${str:-expr}</td><td>var=expr</td><td>var=expr</td><td>var=$str</td></tr>
<tr>	<td>var=${str+expr}</td><td>var=</td><td>var=expr</td><td>var=expr</td></tr>
<tr>    <td>var=${str:+expr}</td><td>var=</td><td>var=</td><td>var=expr</td></tr>
<tr>	<td>var=${str=expr}</td><td>str=expr<br>var=expr</td>
	<td>str 不变<br>var=</td><td>str 不变<br>var=$str</td></tr>
<tr>	<td>var=${str:=expr}</td><td>str=expr<br>var=expr</td>
	<td>str=expr<br>var=expr</td><td>str 不变<br>var=$str</td></tr>
<tr>	<td>var=${str?expr}</td><td>expr 输出至 stderr</td><td>var=</td><td>var=$str</td></tr>
<tr>	<td>var=${str:?expr}</td><td>expr 输出至 stderr</td><td>expr 输出至 stderr</td><td>var=$str</td></tr>
</tbody></table><br>

		<p>根据上面这张表，我们来进行几个范例的练习吧！ ^_^！首先让我们来测试一下，如果旧变量 (str) 不存在时，
		我们要给予新变量一个内容，若旧变量存在则新变量内容以旧变量来替换，结果如下：</p>

<table class="term"><tbody><tr><td class="term"><pre><span class="term_hd">测试：先假设 str 不存在 (用 unset) ，然后测试一下减号 (-) 的用法：</span>
[root@www ~]# <span class="term_command">unset str; var=${str-newvar}</span>
[root@www ~]# <span class="term_command">echo var="$var", str="$str"</span>
var=newvar, str=        <span class="term_note">&lt;==因为 str 不存在，所以 var 为 newvar</span>

<span class="term_hd">测试：若 str 已存在，测试一下 var 会变怎样？：</span>
[root@www ~]# <span class="term_command">str="oldvar"; var=${str-newvar}</span>
[root@www ~]# <span class="term_command">echo var="$var", str="$str"</span>
var=oldvar, str=oldvar  <span class="term_note">&lt;==因为 str 存在，所以 var 等于 str 的内容</span>
</pre></td></tr></tbody></table>

		<p>关于减号 (-) 其实上面我们谈过了！这里的测试只是要让你更加了解，这个减号的测试并不会影响到旧变量的内容。
		如果你想要将旧变量内容也一起替换掉的话，那么就使用等号 (=) 吧！</p>

<table class="term"><tbody><tr><td class="term"><pre><span class="term_hd">测试：先假设 str 不存在 (用 unset) ，然后测试一下等号 (=) 的用法：</span>
[root@www ~]# <span class="term_command">unset str; var=${str=newvar}</span>
[root@www ~]# <span class="term_command">echo var="$var", str="$str"</span>
var=newvar, str=newvar  <span class="term_note">&lt;==因为 str 不存在，所以 var/str 均为 newvar</span>

<span class="term_hd">测试：如果 str 已存在了，测试一下 var 会变怎样？</span>
[root@www ~]# <span class="term_command">str="oldvar"; var=${str=newvar}</span>
[root@www ~]# <span class="term_command">echo var="$var", str="$str"</span>
var=oldvar, str=oldvar  <span class="term_note">&lt;==因为 str 存在，所以 var 等于 str 的内容</span>
</pre></td></tr></tbody></table>

		<p>那如果我只是想知道，如果旧变量不存在时，整个测试就告知我『有错误』，此时就能够使用问号『 ? 』的帮忙啦！
		底下这个测试练习一下先！</p>

<table class="term"><tbody><tr><td class="term"><pre><span class="term_hd">测试：若 str 不存在时，则 var 的测试结果直接显示 "无此变量"</span>
[root@www ~]# <span class="term_command">unset str; var=${str?无此变量}</span>
-bash: str: 无此变量    <span class="term_note">&lt;==因为 str 不存在，所以输出错误信息 </span>

<span class="term_hd">测试：若 str 存在时，则 var 的内容会与 str 相同！</span>
[root@www ~]# <span class="term_command">str="oldvar"; var=${str?novar}</span>
[root@www ~]# <span class="term_command">echo var="$var", str="$str"</span>
var=oldvar, str=oldvar  <span class="term_note">&lt;==因为 str 存在，所以 var 等于 str 的内容</span>
</pre></td></tr></tbody></table>

		<p>基本上这种变量的测试也能够透过 shell script 内的 if...then... 来处理，
		不过既然 bash 有提供这么简单的方法来测试变量，那我们也可以多学一些嘛！
		不过这种变量测试通常是在程序设计当中比较容易出现，如果这里看不懂就先略过，未来有用到判断变量值时，再回来看看吧！ ^_^</p>
	</div>
</div>

<hr><a name="alias_history"></a><img src="./鸟哥的 Linux 私房菜12 -- 学习 bash shell_files/logo.png" alt="大标题的图示" width="35" align="middle" height="34"><span class="text_h1">命令别名与历史命令：</span><br>
<div class="block1">
	<p>我们知道在早期的 DOS 年代，清除屏幕上的信息可以使用 cls 来清除，但是在 Linux 里面，
	我们则是使用 clear 来清除画面的。那么可否让 cls 等于 clear 呢？可以啊！用啥方法？
	link file 还是什么的？别急！底下我们介绍不用 link file 的命令别名来达成。那么什么又是历史命令？
	曾经做过的举动我们可以将他记录下来喔！那就是历史命令啰～底下分别来谈一谈这两个玩意儿。<br><br></p>

	<hr><a name="alias"></a><img src="./鸟哥的 Linux 私房菜12 -- 学习 bash shell_files/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">命令别名配置： alias, unalias</span><br>
	<div class="block2">
		<p>命令别名是一个很有趣的东西，特别是你的惯用命令特别长的时候！还有，
		增设默认的选项在一些惯用的命令上面，可以预防一些不小心误杀文件的情况发生的时候！
		举个例子来说，如果你要查询隐藏档，并且需要长的列出与一页一页翻看，那么需要下达『
		<span class="text_import2">ls -al | more </span>』这个命令，我是觉得很烦啦！
		要输入好几个单字！那可不可以使用 lm 来简化呢？当然可以，你可以在命令行下面下达：</p>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">alias lm='ls -al | more'</span>
</pre></td></tr></tbody></table>

		<p>立刻多出了一个可以运行的命令喔！这个命令名称为 lm ，且其实他是运行 ls -al | more 啊！真是方便。不过，
		要注意的是：『alias 的定义守则与<a href="http://cn.linux.vbird.org/linux_basic/0320bash.php#variable_rule">变量定义守则</a>几乎相同』，
		所以你只要在 alias 后面加上你的 {<span class="text_import2">『别名』='命令 选项...'</span> }，
		以后你只要输入 lm 就相当于输入了 ls -al|more 这一串命令！很方便吧！</p>

		<p>另外，命令别名的配置还可以取代既有的命令喔！举例来说，我们知道 root
		可以移除 (rm) 任何数据！所以当你以 root 的身份在进行工作时，需要特别小心，
		但是总有失手的时候，那么 rm 提供了一个选项来让我们确认是否要移除该文件，那就是 -i 
		这个选项！所以，你可以这样做：</p>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">alias rm='rm -i'</span>
</pre></td></tr></tbody></table>

		<p>那么以后使用 rm 的时候，就不用太担心会有错误删除的情况了！这也是命令别名的优点啰！
		那么如何知道目前有哪些的命令别名呢？就使用 alias 呀！</p>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">alias</span>
alias cp='cp -i'
alias l.='ls -d .* --color=tty'
alias ll='ls -l --color=tty'
alias lm='ls -l | more'
alias ls='ls --color=tty'
alias mv='mv -i'
alias rm='rm -i'
alias which='alias | /usr/bin/which --tty-only --show-dot --show-tilde'
</pre></td></tr></tbody></table>

		<p>由上面的数据当中，你也会发现一件事情啊，我们在<a href="http://cn.linux.vbird.org/linux_basic/0310vi.php">第十章的 vim 程序编辑器</a>里面提到 
		vi 与 vim 是不太一样的，vim 可以多作一些额外的语法检验与颜色显示，默认的 root 是单纯使用 vi 而已。
		如果你想要使用 vi 就直接以 vim 来开启文件的话，使用『 alias vi='vim' 』这个配置即可。
		至于如果要取消命令别名的话，那么就使用 unalias 吧！例如要将刚刚的 lm 命令别名拿掉，就使用：</p>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">unalias lm</span>
</pre></td></tr></tbody></table>

		<p><span class="text_import2">那么命令别名与变量有什么不同呢</span>？命令别名是『新创一个新的命令，
		你可以直接下达该命令』的，至于变量则需要使用类似『 echo 』命令才能够呼叫出变量的内容！
		这两者当然不一样！很多初学者在这里老是搞不清楚！要注意啊！ ^_^</p>

<table border="1" cellpadding="5" cellspacing="0" width="90%"><tbody><tr><td>
例题：<div class="block2">
DOS 年代，列出目录与文件就是 dir ，而清除屏幕就是 cls ，那么如果我想要在
linux 里面也使用相同的命令呢？
</div>
答：<div class="block2">
很简单，透过 clear 与 ls 来进行命令别名的建置：
<blockquote style="font-family: &#39;细明体&#39;;" class="text_import2">
alias cls='clear'<br>alias dir='ls -l'</blockquote>
</div>
</td></tr></tbody></table><br>

	</div>

	<hr><a name="history"></a><img src="./鸟哥的 Linux 私房菜12 -- 学习 bash shell_files/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">历史命令：history</span><br>
	<div class="block2">
		<p>前面我们提过 bash 有提供命令历史的服务！那么如何查询我们曾经下达过的命令呢？就使用
		history 啰！当然，如果觉得 histsory 要输入的字符太多太麻烦，可以使用命令别名来配置呢！
		不要跟我说还不会配置呦！ ^_^</p>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">alias h='history'</span>
</pre></td></tr></tbody></table>

		<p>如此则输入 h 等于输入 history 啰！好了，我们来谈一谈 history 的用法吧！</p>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">history [n]</span>
[root@www ~]# <span class="term_command">history [-c]</span>
[root@www ~]# <span class="term_command">history [-raw] histfiles</span>
<span class="term_say">选项与参数：
n   ：数字，意思是『要列出最近的 n 笔命令行表』的意思！
-c  ：将目前的 shell 中的所有 history 内容全部消除
-a  ：将目前新增的 history 命令新增入 histfiles 中，若没有加 histfiles ，
      则默认写入 ~/.bash_history
-r  ：将 histfiles 的内容读到目前这个 shell 的 history 记忆中；
-w  ：将目前的 history 记忆内容写入 histfiles 中！</span>

<span class="term_hd">范例一：列出目前内存内的所有 history 记忆</span>
[root@www ~]# <span class="term_command">history</span>
<span class="term_say"># 前面省略</span>
 1017  man bash
 1018  ll
 1019  history 
 1020  history
<span class="term_say"># 列出的信息当中，共分两栏，第一栏为该命令在这个 shell 当中的代码，
# 另一个则是命令本身的内容喔！至于会秀出几笔命令记录，则与 HISTSIZE 有关！</span>

<span class="term_hd">范例二：列出目前最近的 3 笔数据</span>
[root@www ~]# <span class="term_command">history 3</span>
 1019  history 
 1020  history
 1021  history 3

<span class="term_hd">范例三：立刻将目前的数据写入 histfile 当中</span>
[root@www ~]# <span class="term_command">history -w</span>
<span class="term_say"># 在默认的情况下，会将历史纪录写入 ~/.bash_history 当中！</span>
[root@www ~]# <span class="term_command">echo $HISTSIZE</span>
1000
</pre></td></tr></tbody></table>

		<p>在正常的情况下，历史命令的读取与记录是这样的：</p>

		<ul>
		<li>当我们以 bash 登陆 Linux 主机之后，系统会主动的由家目录的 ~/.bash_history
		读取以前曾经下过的命令，那么 ~/.bash_history 会记录几笔数据呢？这就与你 bash 的
		HISTFILESIZE 这个变量配置值有关了！<br><br></li>
		<li>假设我这次登陆主机后，共下达过 100 次命令，『<span class="text_import2">等我注销时，
		系统就会将 101~1100 这总共 1000 笔历史命令<b>升级</b>到 ~/.bash_history 当中。</span>』
		也就是说，历史命令在我注销时，会将最近的 HISTFILESIZE 笔记录到我的纪录文件当中啦！<br><br></li>
		<li>当然，也可以用 history -w 强制立刻写入的！那为何用『升级』两个字呢？
		因为 ~/.bash_history 记录的笔数永远都是 HISTFILESIZE 那么多，旧的信息会被主动的拿掉！
		仅保留最新的！</li></ul>

		<p>那么 history 这个历史命令只可以让我查询命令而已吗？呵呵！当然不止啊！
		我们可以利用相关的功能来帮我们运行命令呢！举例来说啰：</p>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">!number</span>
[root@www ~]# <span class="term_command">!command</span>
[root@www ~]# <span class="term_command">!!</span>
<span class="term_say">选项与参数：
number  ：运行第几笔命令的意思；
command ：由最近的命令向前搜寻『命令串开头为 command』的那个命令，并运行；
!!      ：就是运行上一个命令(相当于按↑按键后，按 Enter)</span>

[root@www ~]# <span class="term_command">history</span>
   66  man rm
   67  alias
   68  man history
   69  history 
[root@www ~]# <span class="term_command">!66</span>  <span class="term_note">&lt;==运行第 66 笔命令</span>
[root@www ~]# <span class="term_command">!! </span>  <span class="term_note">&lt;==运行上一个命令，本例中亦即 !66 </span>
[root@www ~]# <span class="term_command">!al</span>  <span class="term_note">&lt;==运行最近以 al 为开头的命令(上头列出的第 67 个)</span>
</pre></td></tr></tbody></table>

		<p>经过上面的介绍，瞭乎？历史命令用法可多了！如果我想要运行上一个命令，
		除了使用上下键之外，我可以直接以『 !! 』 来下达上个命令的内容，此外，
		我也可以直接选择下达第 n 个命令，『 !n 』来运行，也可以使用命令标头，例如
		『 !vi 』来运行最近命令开头是 vi 的命令列！相当的方便而好用！</p>

		<p>基本上 history 的用途很大的！但是需要小心安全的问题！尤其是 root 的历史纪录文件，这是
		Cracker 的最爱！因为不小心的 root 会将很多的重要数据在运行的过程中会被纪录在
		~/.bash_history 当中，如果这个文件被解析的话，后果不堪吶！无论如何，使用 history 配合『
		! 』曾经使用过的命令下达是很有效率的一个命令下达方法！<br><br></p>

		<hr><ul class="list1"><li class="text_import1">同一账号同时多次登陆的 history 写入问题</li></ul>
		<p>有些朋友在练习 linux 的时候喜欢同时开好几个 bash 接口，这些 bash 的身份都是 root 。
		这样会有 ~/.bash_history 的写入问题吗？想一想，因为这些 bash 在同时以 root 的身份登陆，
		因此所有的 bash 都有自己的 1000 笔记录在内存中。因为等到注销时才会升级记录文件，所以啰，
		最后注销的那个 bash 才会是最后写入的数据。唔！如此一来其他 bash 的命令操作就不会被记录下来了
		(其实有被记录，只是被后来的最后一个 bash 所覆盖升级了) 。</p>

		<p>由于多重登陆有这样的问题，所以很多朋友都习惯单一 bash 登陆，再用<a href="http://cn.linux.vbird.org/linux_basic/0440processcontrol.php#background">工作控制 (job control, 第四篇会介绍)</a> 来切换不同工作！
		这样才能够将所有曾经下达过的命令记录下来，也才方便未来系统管理员进行命令的 debug 啊！<br><br></p>

		<hr><ul class="list1"><li class="text_import1">无法记录时间</li></ul>
		<p>历史命令还有一个问题，那就是无法记录命令下达的时间。由于这 1000 笔历史命令是依序记录的，
		但是并没有记录时间，所以在查询方面会有一些不方便。如果读者们有兴趣，其实可以透过 ~/.bash_logout 
		来进行 history 的记录，并加上 date 来添加时间参数，也是一个可以应用的方向喔！
		有兴趣的朋友可以先看看情境模拟题一吧！</p>
	</div>
</div>

<hr><a name="settings"></a><img src="./鸟哥的 Linux 私房菜12 -- 学习 bash shell_files/logo.png" alt="大标题的图示" width="35" align="middle" height="34"><span class="text_h1">Bash Shell 的操作环境：</span><br>
<div class="block1">
	<p>是否记得我们登陆主机的时候，屏幕上头会有一些说明文字，告知我们的 Linux 版本啊什么的，
	还有，登陆的时候我们还可以给予用户一些信息或者欢迎文字呢。此外，
	我们习惯的环境变量、命令别名等等的，是否可以登陆就主动的帮我配置好？
	这些都是需要注意的。另外，这些配置值又可以分为系统整体配置值与各人喜好配置值，
	仅是一些文件放置的地点不同啦！这我们后面也会来谈一谈的！<br><br></p>

	<hr><a name="settings_path"></a><img src="./鸟哥的 Linux 私房菜12 -- 学习 bash shell_files/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">路径与命令搜寻顺序</span><br>
	<div class="block2">
		<p>我们在<a href="http://cn.linux.vbird.org/linux_basic/0210filepermission.php#dir_path">第六章</a>与<a href="http://cn.linux.vbird.org/linux_basic/0220filemanager.php#dir_pathway">第七章</a>都曾谈过『相对路径与绝对路径』的关系，
		在本章的前几小节也谈到了 alias 与 bash 的内建命令。现在我们知道系统里面其实有不少的 ls 命令，
		或者是包括内建的 echo 命令，那么来想一想，如果一个命令 (例如 ls) 被下达时，
		到底是哪一个 ls 被拿来运行？很有趣吧！基本上，命令运行的顺序可以这样看：</p>

		<ol class="text_import2">
		<li>以相对/绝对路径运行命令，例如『 /bin/ls 』或『 ./ls 』；</li>
		<li>由 alias 找到该命令来运行；</li>
		<li>由 bash 内建的 (builtin) 命令来运行；</li>
		<li>透过 $PATH 这个变量的顺序搜寻到的第一个命令来运行。</li>
		</ol>

		<p>举例来说，你可以下达 /bin/ls 及单纯的 ls 看看，会发现使用 ls 有颜色但是 /bin/ls 则没有颜色。
		因为 /bin/ls 是直接取用该命令来下达，而 ls 会因为『 alias ls='ls --color=tty' 』这个命令别名而先使用！
		如果想要了解命令搜寻的顺序，其实透过 type -a ls 也可以查询的到啦！上述的顺序最好先了解喔！</p>

<table border="1" cellpadding="5" cellspacing="0" width="90%"><tbody><tr><td>
例题：<div class="block2">
配置 echo 的命令别名成为 echo -n ，然后再观察 echo 运行的顺序
</div>
答：<div class="block2">
<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">alias echo='echo -n'</span>
[root@www ~]# <span class="term_command">type -a echo</span>
echo is aliased to `echo -n'
echo is a shell builtin
echo is /bin/echo
</pre></td></tr></tbody></table>
瞧！很清楚吧！先 alias 再 builtin 再由 $PATH 找到 /bin/echo 啰！
</div>
</td></tr></tbody></table><br>

	</div>

	<hr><a name="settings_issue"></a><img src="./鸟哥的 Linux 私房菜12 -- 学习 bash shell_files/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">bash 的进站与欢迎信息：
	/etc/issue, /etc/motd</span><br>
	<div class="block2">
		<p>什么！ bash 也有进站画面与欢迎信息喔？真假？真的啊！
		还记得在终端机接口 (tty1 ~ tty6) 登陆的时候，会有几行提示的字符串吗？那就是进站画面啊！
		那个字符串写在哪里啊？呵呵！在 /etc/issue 里面啊！先来看看：</p>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">cat /etc/issue</span>
CentOS release 5.3 (Final)
Kernel \r on an \m

</pre></td></tr></tbody></table>

		<p>鸟哥是以完全未升级过的 CentOS 5.3 作为范例，里面默认有三行，较有趣的地方在于 \r 与 \m。
		就如同 $PS1 这变量一样，issue 这个文件的内容也是可以使用反斜杠作为变量取用喔！你可以 man issue 配合 
		man mingetty 得到底下的结果：</p>

<table bgcolor="lightyellow" border="1" cellpadding="3" cellspacing="0" width="95%">
<tbody><tr align="center" bgcolor="#182448"><td><font color="#FFFFFF">issue 内的各代码意义</font></td></tr>
<tr><td style="font-family: &#39;细明体&#39;;">\d 本地端时间的日期；<br>
\l 显示第几个终端机接口；<br>
\m 显示硬件的等级 (i386/i486/i586/i686...)；<br>
\n 显示主机的网络名称；<br>
\o 显示 domain name；<br>
\r 操作系统的版本 (相当于 uname -r)<br>
\t 显示本地端时间的时间；<br>
\s 操作系统的名称；<br>
\v 操作系统的版本。</td></tr>
</tbody></table>

		<p>做一下底下这个练习，看看能不能取得你要的进站画面？</p>

<table border="1" cellpadding="5" cellspacing="0" width="90%"><tbody><tr><td>
例题：<div class="block2">
如果你在 tty3 的进站画面看到如下显示，该如何配置才能得到如下画面？
<blockquote class="text_import2" style="font-family: &#39;细明体&#39;;">
CentOS release 5.3 (Final) (terminal: tty3)<br>
Date: 2009-02-05 17:29:19<br>
Kernel 2.6.18-128.el5 on an i686<br>
Welcome!<br>
<br>
</blockquote>注意，tty3 在不同的 tty 有不同显示，日期则是再按下 [enter] 后就会所有不同。
</div>
答：<div class="block2">
很简单，参考上述的反斜杠功能去修改 /etc/issue 成为如下模样即可(共五行)：

<table class="term"><tbody><tr><td class="term"><pre><span class="term_write">CentOS release 5.3 (Final) (terminal: \l)
Date: \d \t
Kernel \r on an \m
Welcome!
</span>
</pre></td></tr></tbody></table>
曾有鸟哥的学生在这个 /etc/issue 内修改数据，光是利用简单的英文字母作出属于他自己的进站画面，
画面里面有他的中文名字呢！非常厉害！也有学生做成类似很大一个『囧』在进站画面，都非常有趣！
</div>
</td></tr></tbody></table><br>

		<p>你要注意的是，除了 /etc/issue 之外还有个 /etc/issue.net 呢！这是啥？这个是提供给 telnet 这个远程登录程序用的。
		当我们使用 telnet 连接到主机时，主机的登陆画面就会显示 /etc/issue.net 而不是 /etc/issue 呢！</p>

		<p>至于如果<span class="text_import2">您想要让使用者登陆后取得一些信息，例如您想要让大家都知道的信息，
		那么可以将信息加入 /etc/motd 里面去</span>！例如：当登陆后，告诉登陆者，
		系统将会在某个固定时间进行维护工作，可以这样做：</p>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">vi /etc/motd</span>
<span class="term_write">Hello everyone,
Our server will be maintained at 2009/02/28 0:00 ~ 24:00.
Please don't login server at that time. ^_^</span>
</pre></td></tr></tbody></table>

		<p>那么当你的使用者(包括所有的一般账号与 root)登陆主机后，就会显示这样的信息出来：</p>

<table class="term"><tbody><tr><td class="term"><pre>Last login: Thu Feb  5 22:35:47 2009 from 127.0.0.1
Hello everyone,
Our server will be maintained at 2009/02/28 0:00 ~ 24:00.
Please don't login server at that time. ^_^
</pre></td></tr></tbody></table>

	</div>

	<hr><a name="settings_bashrc"></a><img src="./鸟哥的 Linux 私房菜12 -- 学习 bash shell_files/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">bash 的环境配置文件</span><br>
	<div class="block2">
		<p>你是否会觉得奇怪，怎么我们什么动作都没有进行，但是一进入 bash 就取得一堆有用的变量了？
		这是因为系统有一些环境配置文件案的存在，让 bash 在启动时直接读取这些配置文件，以规划好 bash 的操作环境啦！
		而这些配置文件又可以分为全体系统的配置文件以及用户个人偏好配置文件。要注意的是，
		我们前几个小节谈到的命令别名啦、自定义的变量啦，在你注销 bash 后就会失效，所以你想要保留你的配置，
		就得要将这些配置写入配置文件才行。底下就让我们来聊聊吧！<br><br></p>

		<a name="settings_bashrc_shell"></a>
		<hr><ul class="list1"><li class="text_import1">login 与 non-login shell</li></ul>

		<p>在开始介绍 bash 的配置文件前，我们一定要先知道的就是 login shell 与 non-login shell！
		重点在于有没有登陆 (login) 啦！</p>
		<ul class="text_import2">
		<li>login shell：取得 bash 时需要完整的登陆流程的，就称为 login shell。举例来说，你要由 tty1 ~ tty6 
		登陆，需要输入用户的账号与密码，此时取得的 bash 就称为『 login shell 』啰；<br><br></li>
		<li>non-login shell：取得 bash 接口的方法不需要重复登陆的举动，举例来说，(1)你以 X window 登陆 Linux 后，
		再以 X 的图形化接口启动终端机，此时那个终端接口并没有需要再次的输入账号与密码，那个 bash 的环境就称为
		non-login shell了。(2)你在原本的 bash 环境下再次下达 bash 这个命令，同样的也没有输入账号密码，
		那第二个 bash (子程序) 也是 non-login shell 。</li>
		</ul>

		<p>为什么要介绍 login, non-login shell 呢？这是因为这两个取得 bash 的情况中，读取的配置文件数据并不一样所致。
		由于我们需要登陆系统，所以先谈谈 login shell 会读取哪些配置文件？一般来说，login shell 其实只会读取这两个配置文件：</p>

		<ol class="text_import2">
		<li>/etc/profile：这是系统整体的配置，你最好不要修改这个文件；</li>
		<li>~/.bash_profile 或 ~/.bash_login 或 ~/.profile：属于使用者个人配置，你要改自己的数据，就写入这里！</li>
		</ol>

		<p>那么，就让我们来聊一聊这两个文件吧！这两个文件的内容可是非常繁复的喔！<br><br></p>

		<a name="settings_bashrc_profile"></a>
		<hr><ul class="list1"><li class="text_import1">/etc/profile (login shell 才会读)</li></ul>

		<p>你可以使用 vim 去阅读一下这个文件的内容。这个配置文件可以利用使用者的标识符 (UID) 来决定很多重要的变量数据，
		这也是<span class="text_import2">每个使用者登陆取得 bash 时一定会读取的配置文件</span>！
		所以如果你想要帮所有使用者配置整体环境，那就是改这里啰！不过，没事还是不要随便改这个文件喔
		这个文件配置的变量主要有：</p>

		<ul class="text_import2">
		<li>PATH：会依据 UID 决定 PATH 变量要不要含有 sbin 的系统命令目录；</li>
		<li>MAIL：依据账号配置好使用者的 mailbox 到 /var/spool/mail/账号名；</li>
		<li>USER：根据用户的账号配置此一变量内容；</li>
		<li>HOSTNAME：依据主机的 hostname 命令决定此一变量内容；</li>
		<li>HISTSIZE：历史命令记录笔数。CentOS 5.x 配置为 1000 ；</li>
		</ul>

		<p>/etc/profile 可不止会做这些事而已，他还会去呼叫外部的配置数据喔！在 CentOS 5.x 默认的情况下，
		底下这些数据会依序的被呼叫进来：</p>

		<ul>
		<li><span class="text_import2">/etc/inputrc</span><br><br>
		其实这个文件并没有被运行啦！/etc/profile 会主动的判断使用者有没有自定义输入的按键功能，如果没有的话， /etc/profile
		就会决定配置『INPUTRC=/etc/inputrc』这个变量！此一文件内容为 bash 的热键啦、[tab]要不要有声音啦等等的数据！
		因为鸟哥觉得 bash 默认的环境已经很棒了，所以不建议修改这个文件！<br><br></li>

		<li><span class="text_import2">/etc/profile.d/*.sh</span><br><br>
		其实这是个目录内的众多文件！只要在 /etc/profile.d/ 这个目录内且扩展名为 .sh ，另外，使用者能够具有 r 的权限，
		那么该文件就会被 /etc/profile 呼叫进来。在 CentOS 5.x 中，这个目录底下的文件规范了 bash 操作接口的颜色、
		语系、ll 与 ls 命令的命令别名、vi 的命令别名、which 的命令别名等等。如果你需要帮所有使用者配置一些共享的命令别名时，
		可以在这个目录底下自行创建扩展名为 .sh 的文件，并将所需要的数据写入即可喔！<br><br></li>

		<li><span class="text_import2">/etc/sysconfig/i18n</span><br><br>
		这个文件是由 /etc/profile.d/lang.sh 呼叫进来的！这也是我们决定 bash 默认使用何种语系的重要配置文件！
		文件里最重要的就是 LANG 这个变量的配置啦！我们在前面的 <a href="http://cn.linux.vbird.org/linux_basic/0320bash.php#variable_locale">locale</a> 讨论过这个文件啰！
		自行回去瞧瞧先！<br></li>
		</ul>

		<p>反正你只要记得，<span class="text_import2">bash 的 login shell 情况下所读取的整体环境配置文件其实只有 
		/etc/profile</span>，但是 /etc/profile 还会呼叫出其他的配置文件，所以让我们的 bash 操作接口变的非常的友善啦！
		接下来，让我们来瞧瞧，那么个人偏好的配置文件又是怎么回事？<br><br></p>

		<a name="settings_bashrc_bash_profile"></a>
		<hr><ul class="list1"><li class="text_import1">~/.bash_profile (login shell 才会读) </li></ul>

		<p>bash 在读完了整体环境配置的 /etc/profile 并藉此呼叫其他配置文件后，接下来则是会读取使用者的个人配置文件。
		在 login shell 的 bash 环境中，所读取的个人偏好配置文件其实主要有三个，依序分别是：</p>
		<ol class="text_import2">
		<li>~/.bash_profile</li>
		<li>~/.bash_login</li>
		<li>~/.profile</li>
		</ol>
		<p><span class="text_import2">其实 bash 的 login shell 配置只会读取上面三个文件的其中一个，
		而读取的顺序则是依照上面的顺序。</span>也就是说，如果 ~/.bash_profile 存在，那么其他两个文件不论有无存在，都不会被读取。
		如果 ~/.bash_profile 不存在才会去读取 ~/.bash_login，而前两者都不存在才会读取 ~/.profile 的意思。
		会有这么多的文件，其实是因应其他 shell 转换过来的使用者的习惯而已。
		先让我们来看一下 root 的 /root/.bash_profile 的内容是怎样呢？</p>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">cat ~/.bash_profile</span>
# .bash_profile

# Get the aliases and functions
if [ -f ~/.bashrc ]; then   <span class="term_note">&lt;==底下这三行在判断并读取 ~/.bashrc</span>
        <span class="term_write">. ~/.bashrc</span>
fi

# User specific environment and startup programs
<span class="term_write">PATH=$PATH:$HOME/bin        <span class="term_note">&lt;==底下这几行在处理个人化配置</span>
export PATH</span>
unset USERNAME
</pre></td></tr></tbody></table>

		<p>这个文件内有配置 PATH 这个变量喔！而且还使用了 export 将 PATH 变成环境变量呢！
		由于 PATH 在 /etc/profile 当中已经配置过，所以在这里就以累加的方式添加用户家目录下的 ~/bin/ 
		为额外的运行文件放置目录。这也就是说，你可以将自己创建的运行档放置到你自己家目录下的 ~/bin/ 目录啦！
		那就可以直接运行该运行档而不需要使用绝对/相对路径来运行该文件。</p>

		<p>这个文件的内容比较有趣的地方在于 if ... then ... 那一段！那一段程序代码我们会在<a href="http://cn.linux.vbird.org/linux_basic/0340bashshell-scripts.php">第十三章 shell script</a> 谈到，假设你现在是看不懂的。
		该段的内容指的是『<span class="text_import2">判断家目录下的 ~/.bashrc 存在否，若存在则读入 ~/.bashrc 的配置</span>』。
		bash 配置文件的读入方式比较有趣，主要是透过一个命令『 source 』来读取的！
		也就是说 ~/.bash_profile 其实会再呼叫 ~/.bashrc 的配置内容喔！最后，我们来看看整个 login shell
		的读取流程：</p>

		<center><img src="./鸟哥的 Linux 私房菜12 -- 学习 bash shell_files/bashrc_1.gif" alt="login shell 的配置文件读取流程" title="login shell 的配置文件读取流程" border="0"><br>
		图 4.3.1、login shell 的配置文件读取流程<br></center>

		<p>实线的的方向是主线流程，虚线的方向则是被呼叫的配置文件！从上面我们也可以清楚的知道，在 CentOS 
		的 login shell 环境下，最终被读取的配置文件是『 ~/.bashrc 』这个文件喔！所以，你当然可以将自己的偏好配置写入该文件即可。
		底下我们还要讨论一下 source 与 ~/.bashrc 喔！<br><br></p>

		<a name="source"></a>
		<hr><ul class="list1"><li class="text_import1">source ：读入环境配置文件的命令</li></ul>

		<p>由于 /etc/profile 与 ~/.bash_profile 都是在取得 login shell 的时候才会读取的配置文件，所以，
		如果你将自己的偏好配置写入上述的文件后，通常都是得注销再登陆后，该配置才会生效。那么，能不能直接读取配置文件而不注销登陆呢？
		可以的！那就得要利用 source 这个命令了！</p>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">source 配置文件档名</span>

<span class="term_hd">范例：将家目录的 ~/.bashrc 的配置读入目前的 bash 环境中</span>
[root@www ~]# <span class="term_command">source ~/.bashrc</span>  <span class="term_note">&lt;==底下这两个命令是一样的！</span>
[root@www ~]# <span class="term_command"> .  ~/.bashrc</span>
</pre></td></tr></tbody></table>

		<p>利用 source 或小数点 (.) 都可以将配置文件的内容读进来目前的 shell 环境中！
		举例来说，我修改了 ~/.bashrc ，那么不需要注销，立即以 source ~/.bashrc 
		就可以将刚刚最新配置的内容读进来目前的环境中！很不错吧！还有，包括 ~/bash_profile 以及 /etc/profile 的配置中，
		很多时候也都是利用到这个 source (或小数点) 的功能喔！</p>

		<p>有没有可能会使用到不同环境配置文件的时候？有啊！
		最常发生在一个人的工作环境分为多种情况的时候了！举个例子来说，在鸟哥的大型主机中，
		常常需要负责两到三个不同的案子，每个案子所需要处理的环境变量订定并不相同，
		那么鸟哥就将这两三个案子分别编写属于该案子的环境变量配置文件案，当需要该环境时，就直接『
		source 变量文件 』，如此一来，环境变量的配置就变的更简便而灵活了！<br><br></p>

		<a name="settings_bashrc_bashrc"></a>
		<hr><ul class="list1"><li class="text_import1">~/.bashrc (non-login shell 会读)</li></ul>

		<p>谈完了 login shell 后，那么 non-login shell 这种非登陆情况取得 bash 操作接口的环境配置文件又是什么？
		当你取得 non-login shell 时，该 bash 配置文件仅会读取 ~/.bashrc 而已啦！那么默认的 ~/.bashrc 内容是如何？</p>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">cat ~/.bashrc</span>
# .bashrc

# User specific aliases and functions
alias rm='rm -i'             <span class="term_note">&lt;==使用者的个人配置</span>
alias cp='cp -i'
alias mv='mv -i'

# Source global definitions
<span class="term_write">if [ -f /etc/bashrc ]; then  <span class="term_note">&lt;==整体的环境配置</span>
        . /etc/bashrc
fi</span>
</pre></td></tr></tbody></table>

		<p>特别注意一下，由于 root 的身份与一般使用者不同，鸟哥是以 root 的身份取得上述的数据，
		如果是一般使用者的 ~/.bashrc 会有些许不同。看一下，你会发现在 root 的 ~/.bashrc 中其实已经规范了较为保险的命令别名了。
		此外，咱们的 CentOS 5.x 还会主动的呼叫 /etc/bashrc 这个文件喔！为什么需要呼叫 /etc/bashrc 呢？
		因为 <span class="text_import2">/etc/bashrc</span> 帮我们的 bash 定义出底下的数据：</p>

		<ul class="text_import2">
		<li>依据不同的 UID 规范出 <a href="http://cn.linux.vbird.org/linux_basic/0220filemanager.php#umask">umask</a> 的值；</li>
		<li>依据不同的 UID 规范出提示字符 (就是 PS1 变量)；</li>
		<li>呼叫 /etc/profile.d/*.sh 的配置</li>
		</ul>

		<p>你要注意的是，这个 /etc/bashrc 是 CentOS 特有的 (其实是 Red Hat 系统特有的)，其他不同的 distributions 
		可能会放置在不同的档名就是了。由于这个 ~/.bashrc 会呼叫 /etc/bashrc 及 /etc/profile.d/*.sh ，
		所以，万一你没有 ~/.bashrc (可能自己不小心将他删除了)，那么你会发现你的 bash 提示字符可能会变成这个样子：</p>

<table class="term"><tbody><tr><td class="term"><pre>-bash-3.2$ <span class="term_white"> </span>
</pre></td></tr></tbody></table>

		<p>不要太担心啦！这是正常的，因为你并没有呼叫 /etc/bashrc 来规范 PS1 变量啦！而且这样的情况也不会影响你的 bash 使用。
		如果你想要将命令提示字符捉回来，那么可以复制 /etc/skel/.bashrc 到你的家目录，再修订一下你所想要的内容，
		并使用 source 去呼叫 ~/.bashrc ，那你的命令提示字符就会回来啦！<br><br></p>

		<hr><ul class="list1"><li class="text_import1">其他相关配置文件</li></ul>

		<p>事实上还有一些配置文件可能会影响到你的 bash 操作的，底下就来谈一谈：</p>

		<ul style="padding-left: 20px;">
		<li><a name="man"></a><span class="text_import1">/etc/man.config</span><br><br>
		这个文件乍看之下好像跟 bash 没相关性，但是对于系统管理员来说，
		却也是很重要的一个文件！这的文件的内容『<span class="text_import2">规范了使用
		<a href="http://cn.linux.vbird.org/linux_basic/0160startlinux.php#manual_man">man</a> 的时候， man page 
		的路径到哪里去寻找！</span>』所以说的简单一点，这个文件规定了下达
		man 的时候，该去哪里查看数据的路径配置！<br><br>

		那么什么时候要来修改这个文件呢？如果你是以
		tarball 的方式来安装你的数据，那么你的 man page 可能会放置在
		/usr/local/softpackage/man 里头，那个 softpackage 是你的套件名称，
		这个时候你就得以手动的方式将该路径加到 /etc/man.config 里头，否则使用 man 
		的时候就会找不到相关的说明档啰。<br><br>

		事实上，这个文件内最重要的其实是 MANPATH 这个变量配置啦！
		我们搜寻 man page 时，会依据 MANPATH 的路径去分别搜寻啊！另外，要注意的是，
		这个文件在各大不同版本 Linux distributions 中，檔名都不太相同，例如 CentOS 用的是
		/etc/man.config ，而 SuSE 用的则是 /etc/manpath.config ，
		可以利用 [tab] 按键来进行文件名的补齐啦！<br><br></li>

		<li><span class="text_import1">~/.bash_history</span><br><br>
		还记得我们在<a href="http://cn.linux.vbird.org/linux_basic/0320bash.php#history">历史命令</a>提到过这个文件吧？默认的情况下，
		我们的历史命令就记录在这里啊！而这个文件能够记录几笔数据，则与 HISTFILESIZE
		这个变量有关啊。每次登陆 bash 后，bash 会先读取这个文件，将所有的历史命令读入内存，
		因此，当我们登陆 bash 后就可以查知上次使用过哪些命令啰。至于更多的历史命令，
		请自行回去参考喔！<br><br></li>

		<li><span class="text_import1">~/.bash_logout</span><br><br>
		这个文件则记录了『<span class="text_import2">当我注销 bash 后，系统再帮我做完什么动作后才离开</span>』的意思。
		你可以去读取一下这个文件的内容，默认的情况下，注销时， bash 只是帮我们清掉屏幕的信息而已。
		不过，你也可以将一些备份或者是其他你认为重要的工作写在这个文件中 (例如清空缓存盘)，
		那么当你离开 Linux 的时候，就可以解决一些烦人的事情啰！<br></li>
		</ul>
	</div>

	<hr><a name="settings_set"></a><img src="./鸟哥的 Linux 私房菜12 -- 学习 bash shell_files/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">终端机的环境配置： stty, set</span><br>
	<div class="block2">
		<p>我们在<a href="http://cn.linux.vbird.org/linux_basic/0160startlinux.php">第五章首次登陆 Linux</a> 时就提过，可以在 tty1 ~ tty6 
		这六个文字接口的终端机 (terminal) 环境中登陆，登陆的时候我们可以取得一些字符配置的功能喔！
		举例来说，我们可以利用退格键 (backspace，就是那个←符号的按键) 来删除命令行上的字符，
		也可以使用 [ctrl]+c 来强制终止一个命令的运行，当输入错误时，就会有声音跑出来警告。这是怎么办到的呢？
		很简单啊！因为登陆终端机的时候，会自动的取得一些终端机的输入环境的配置啊！</p>

		<p>事实上，目前我们使用的 Linux distributions 都帮我们作了最棒的使用者环境了，
		所以大家可以不用担心操作环境的问题。不过，在某些 Unix like 的机器中，还是可能需要动用一些手脚，
		才能够让我们的输入比较快乐～举例来说，利用 [backspace] 删除，要比利用 [Del] 按键来的顺手吧！
		但是某些 Unix 偏偏是以 [del] 来进行字符的删除啊！所以，这个时候就可以动动手脚啰～</p>

		<p>那么如何查阅目前的一些按键内容呢？可以利用 stty (setting tty 终端机的意思) 呢！
		stty 也可以帮助配置终端机的输入按键代表意义喔！</p>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">stty [-a]</span>
<span class="term_say">选项与参数：
-a  ：将目前所有的 stty 参数列出来；</span>

<span class="term_hd">范例一：列出所有的按键与按键内容</span>
[root@www ~]# <span class="term_command">stty -a</span>
speed 38400 baud; rows 24; columns 80; line = 0;
<span class="term_write">intr = ^C</span>; quit = ^\; <span class="term_write">erase = ^?</span>; kill = ^U; <span class="term_write">eof = ^D</span>; eol = &lt;undef&gt;; 
eol2 = &lt;undef&gt;; swtch = &lt;undef&gt;; start = ^Q; <span class="term_write">stop = ^S; susp = ^Z;</span>
rprnt = ^R; werase = ^W; lnext = ^V; flush = ^O; min = 1; time = 0;
<span class="term_say">....(以下省略)....</span>
</pre></td></tr></tbody></table>

		<p>我们可以利用 stty -a 来列出目前环境中所有的按键列表，在上头的列表当中，需要注意的是特殊字体那几个，
		此外，<span class="text_import2">如果出现 ^ 表示 [Ctrl] 那个按键的意思</span>。举例来说， intr = ^C 
		表示利用 [ctrl] + c 来达成的。几个重要的代表意义是：</p>

		<ul style="font-family: &#39;细明体&#39;;">
		<li>eof &nbsp;&nbsp;: End of file 的意思，代表『结束输入』。</li>
		<li>erase : 向后删除字符，</li>
		<li>intr &nbsp;: 送出一个 interrupt (中断) 的讯号给目前正在 run 的程序；</li>
		<li>kill &nbsp;: 删除在目前命令列上的所有文字；</li>
		<li>quit&nbsp; : 送出一个 quit 的讯号给目前正在 run 的程序；</li>
		<li>start : 在某个程序停止后，重新启动他的 output</li>
		<li>stop &nbsp;: 停止目前屏幕的输出；</li>
		<li>susp &nbsp;: 送出一个 terminal stop 的讯号给正在 run 的程序。</li>
		</ul>

		<p>记不记得我们在<a href="http://cn.linux.vbird.org/linux_basic/0160startlinux.php#cmd_hkey">第五章讲过几个 Linux 热键</a>啊？没错！
		就是这个 stty 配置值内的 intr / eof 啰～至于删除字符，就是 erase 那个配置值啦！
		如果你想要用 [ctrl]+h 来进行字符的删除，那么可以下达：</p>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">stty erase ^h</span>
</pre></td></tr></tbody></table>

		<p>那么从此之后，你的删除字符就得要使用 [ctrl]+h 啰，按下 [backspace] 则会出现 ^? 字样呢！
		如果想要回复利用 [backspace] ，就下达 <span class="text_import2">stty erase ^?</span> 即可啊！
		至于更多的 stty 说明，记得参考一下 man stty 的内容喔！</p>

		<p>除了 stty 之外，其实我们的 bash 还有自己的一些终端机配置值呢！那就是利用 set 来配置的！
		我们之前提到一些变量时，可以利用 set 来显示，除此之外，其实 set 还可以帮我们配置整个命令输出/输入的环境。
		例如记录历史命令、显示错误内容等等。</p>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">set [-uvCHhmBx]</span>
<span class="term_say">选项与参数：
-u  ：默认不激活。若激活后，当使用未配置变量时，会显示错误信息；
-v  ：默认不激活。若激活后，在信息被输出前，会先显示信息的原始内容；
-x  ：默认不激活。若激活后，在命令被运行前，会显示命令内容(前面有 ++ 符号)
-h  ：默认激活。与历史命令有关；
-H  ：默认激活。与历史命令有关；
-m  ：默认激活。与工作管理有关；
-B  ：默认激活。与刮号 [] 的作用有关；
-C  ：默认不激活。若使用 &gt; 等，则若文件存在时，该文件不会被覆盖。</span>

<span class="term_hd">范例一：显示目前所有的 set 配置值</span>
[root@www ~]# <span class="term_command">echo $-</span>
himBH
<span class="term_say"># 那个 $- 变量内容就是 set 的所有配置啦！ bash 默认是 himBH 喔！</span>

<span class="term_hd">范例二：配置 "若使用未定义变量时，则显示错误信息" </span>
[root@www ~]# <span class="term_command">set -u</span>
[root@www ~]# <span class="term_command">echo $vbirding</span>
-bash: vbirding: unbound variable
<span class="term_say"># 默认情况下，未配置/未宣告 的变量都会是『空的』，不过，若配置 -u 参数，
# 那么当使用未配置的变量时，就会有问题啦！很多的 shell 都默认激活 -u 参数。
# 若要取消这个参数，输入 set +u 即可！</span>

<span class="term_hd">范例三：运行前，显示该命令内容。</span>
[root@www ~]# <span class="term_command">set -x</span>
[root@www ~]# <span class="term_command">echo $HOME</span>
+ echo /root
/root
++ echo -ne '\033]0;root@www:~'
<span class="term_say"># 看见否？要输出的命令都会先被打印到屏幕上喔！前面会多出 + 的符号！</span>
</pre></td></tr></tbody></table>

		<p>另外，其实我们还有其他的按键配置功能呢！就是在前一小节提到的 /etc/inputrc 这个文件里面配置。</p>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">cat /etc/inputrc</span>
# do not bell on tab-completion
#set bell-style none

set meta-flag on
set input-meta on
set convert-meta off
set output-meta on
<span class="term_say">.....以下省略.....</span>
</pre></td></tr></tbody></table>

		<p>还有例如 /etc/DIR_COLORS* 与 /etc/termcap 等，也都是与终端机有关的环境配置文件案呢！
		不过，事实上，鸟哥并不建议您修改 tty 的环境呢，这是因为 bash 的环境已经配置的很亲和了，
		我们不需要额外的配置或者修改，否则反而会产生一些困扰。不过，写在这里的数据，
		只是希望大家能够清楚的知道我们的终端机是如何进行配置的喔！ ^_^！
		最后，我们将 bash 默认的组合键给他汇整如下：</p>

<table bgcolor="lightyellow" border="1" cellpadding="3" cellspacing="0" width="95%">
<tbody><tr align="center" bgcolor="#182448"><td><font color="#FFFFFF">组合按键</font></td><td><font color="#FFFFFF">运行结果</font></td></tr>
<tr><td>Ctrl + C</td><td>终止目前的命令</td></tr>
<tr><td>Ctrl + D</td><td>输入结束 (EOF)，例如邮件结束的时候；</td></tr>
<tr><td>Ctrl + M</td><td>就是 Enter 啦！</td></tr>
<tr><td>Ctrl + S</td><td>暂停屏幕的输出</td></tr>
<tr><td>Ctrl + Q</td><td>恢复屏幕的输出</td></tr>
<tr><td>Ctrl + U</td><td>在提示字符下，将整列命令删除</td></tr>
<tr><td>Ctrl + Z</td><td>『暂停』目前的命令</td></tr>
</tbody></table><br>

	</div>

	<hr><a name="settings_wildcard"></a><img src="./鸟哥的 Linux 私房菜12 -- 学习 bash shell_files/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">通配符与特殊符号</span><br>
	<div class="block2">
		<p>在 bash 的操作环境中还有一个非常有用的功能，那就是通配符 (wildcard) ！
		我们利用 bash 处理数据就更方便了！底下我们列出一些常用的通配符喔：</p>

<table bgcolor="lightyellow" border="1" cellpadding="3" cellspacing="0" width="95%">
<tbody><tr align="center" bgcolor="#182448"><td width="50"><font color="#FFFFFF">符号</font></td><td><font color="#FFFFFF">意义</font></td></tr>
<tr><td align="center">*</td><td>代表『 0 个到无穷多个』任意字符</td></tr>
<tr><td align="center">?</td><td>代表『一定有一个』任意字符</td></tr>
<tr><td align="center">[  ]</td><td>同样代表『一定有一个在括号内』的字符(非任意字符)。例如 [abcd] 代表『一定有一个字符，
	可能是 a, b, c, d 这四个任何一个』</td></tr>
<tr><td align="center">[ - ]</td><td>若有减号在中括号内时，代表『在编码顺序内的所有字符』。例如 [0-9] 代表
	0 到 9 之间的所有数字，因为数字的语系编码是连续的！</td></tr>
<tr><td align="center">[^ ]</td><td>若中括号内的第一个字符为指数符号 (^) ，那表示『反向选择』，例如 [^abc] 代表
	一定有一个字符，只要是非 a, b, c 的其他字符就接受的意思。</td></tr>
</tbody></table>

		<p>接下来让我们利用通配符来玩些东西吧！首先，利用通配符配合 ls 找檔名看看：</p>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">LANG=C            </span>  <span class="term_note">&lt;==由于与编码有关，先配置语系一下</span>

<span class="term_hd">范例一：找出 /etc/ 底下以 cron 为开头的档名</span>
[root@www ~]# <span class="term_command">ll -d /etc/cron*  </span>  <span class="term_note">&lt;==加上 -d 是为了仅显示目录而已</span>

<span class="term_hd">范例二：找出 /etc/ 底下文件名『刚好是五个字母』的文件名</span>
[root@www ~]# <span class="term_command">ll -d /etc/?????  </span>  <span class="term_note">&lt;==由于 ? 一定有一个，所以五个 ? 就对了</span>

<span class="term_hd">范例三：找出 /etc/ 底下文件名含有数字的文件名</span>
[root@www ~]# <span class="term_command">ll -d /etc/*[0-9]*</span>  <span class="term_note">&lt;==记得中括号左右两边均需 *</span>

<span class="term_hd">范例四：找出 /etc/ 底下，档名开头非为小写字母的文件名：</span>
[root@www ~]# <span class="term_command">ll -d /etc/[^a-z]*</span>  <span class="term_note">&lt;==注意中括号左边没有 *</span>

<span class="term_hd">范例五：将范例四找到的文件复制到 /tmp 中</span>
[root@www ~]# <span class="term_command">cp -a /etc/[^a-z]* /tmp</span>
</pre></td></tr></tbody></table>

		<p>除了通配符之外，bash 环境中的特殊符号有哪些呢？底下我们先汇整一下：</p>

<table bgcolor="lightyellow" border="1" cellpadding="3" cellspacing="0" width="95%">
<tbody><tr align="center" bgcolor="#182448"><td width="60"><font color="#FFFFFF">符号</font></td><td><font color="#FFFFFF">内容</font></td></tr>
<tr><td align="center">#</td><td>批注符号：这个最常被使用在 script 当中，视为说明！在后的数据均不运行</td></tr>
<tr><td align="center">\</td><td>跳脱符号：将『特殊字符或通配符』还原成一般字符</td></tr>
<tr><td align="center">|</td><td>管线 (pipe)：分隔两个管线命令的界定(后两节介绍)；</td></tr>
<tr><td align="center">;</td><td>连续命令下达分隔符：连续性命令的界定 (注意！与管线命令并不相同)</td></tr>
<tr><td align="center">~</td><td>用户的家目录</td></tr>
<tr><td align="center">$</td><td>取用变量前导符：亦即是变量之前需要加的变量取代值</td></tr>
<tr><td align="center">&amp;</td><td>工作控制 (job control)：将命令变成背景下工作</td></tr>
<tr><td align="center">!</td><td>逻辑运算意义上的『非』 not 的意思！</td></tr>
<tr><td align="center">/</td><td>目录符号：路径分隔的符号</td></tr>
<tr><td align="center">&gt;, &gt;&gt;</td><td>数据流重导向：输出导向，分别是『取代』与『累加』</td></tr>
<tr><td align="center">&lt;, &lt;&lt;</td><td>数据流重导向：输入导向 (这两个留待下节介绍)</td></tr>
<tr><td align="center">' '</td><td>单引号，不具有变量置换的功能</td></tr>
<tr><td align="center">" "</td><td>具有变量置换的功能！</td></tr>
<tr><td align="center">` `</td><td>两个『 ` 』中间为可以先运行的命令，亦可使用 $( )</td></tr>
<tr><td align="center">(   )</td><td>在中间为子 shell 的起始与结束</td></tr>
<tr><td align="center">{   }</td><td>在中间为命令区块的组合！</td></tr>
</tbody></table>

		<p>以上为 bash 环境中常见的特殊符号汇整！理论上，你的『档名』尽量不要使用到上述的字符啦！</p>
	</div>
</div>

<hr><a name="redirect"></a><img src="./鸟哥的 Linux 私房菜12 -- 学习 bash shell_files/logo.png" alt="大标题的图示" width="35" align="middle" height="34"><span class="text_h1">数据流重导向</span><br>
<div class="block1">
	<p>数据流重导向 (redirect) 由字面上的意思来看，好像就是将『数据给他传导到其他地方去』的样子？
	没错～数据流重导向就是将某个命令运行后应该要出现在屏幕上的数据，
	给他传输到其他的地方，例如文件或者是装置 (例如打印机之类的)！这玩意儿在 Linux 的文本模式底下可重要的！
	尤其是如果我们想要将某些数据储存下来时，就更有用了！<br><br></p>

	<hr><a name="redirect_redirect"></a><img src="./鸟哥的 Linux 私房菜12 -- 学习 bash shell_files/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">什么是数据流重导向</span><br>
	<div class="block2">
		<p>什么是数据流重导向啊？这得要由命令的运行结果谈起！一般来说，如果你要运行一个命令，通常他会是这样的：</p>

		<center><img src="./鸟哥的 Linux 私房菜12 -- 学习 bash shell_files/0320bash_4.jpg" alt="命令运行过程的数据传输情况" title="命令运行过程的数据传输情况" border="0"><br>
		图 5.1.1、命令运行过程的数据传输情况<br></center>

		<p>我们运行一个命令的时候，这个命令可能会由文件读入数据，经过处理之后，再将数据输出到屏幕上。
		在上图当中， standard output 与 standard error output 分别代表『标准输出』与『标准错误输出』，
		这两个玩意儿默认都是输出到屏幕上面来的啊！那么什么是标准输出与标准错误输出呢？<br><br></p>

		<hr><ul class="list1"><li class="text_import1">standard output 与 standard error output</li></ul>

		<p>简单的说，<span class="text_import2">标准输出指的是『命令运行所回传的正确的信息』，而标准错误输出可理解为『
		命令运行失败后，所回传的错误信息』</span>。举个简单例子来说，我们的系统默认有 /etc/crontab 但却无 /etc/vbirdsay，
		此时若下达『 cat /etc/crontab /etc/vbirdsay 』这个命令时，cat 会进行：</p>

		<ul>
		<li>标准输出：读取 /etc/crontab 后，将该文件内容显示到屏幕上；</li>
		<li>标准错误输出：因为无法找到 /etc/vbirdsay，因此在屏幕上显示错误信息</li>
		</ul>

		<p>不管正确或错误的数据都是默认输出到屏幕上，所以屏幕当然是乱乱的！那能不能透过某些机制将这两股数据分开呢？
		当然可以啊！那就是数据流重导向的功能啊！数据流重导向可以将 standard output (简称 stdout) 与 standard error
		output (简称 stderr) 分别传送到其他的文件或装置去，而分别传送所用的特殊字符则如下所示：</p>

		<ol class="text_import2" style="font-family: &#39;细明体&#39;;">
		<li>标准输入　　(stdin) ：代码为 0 ，使用 &lt; 或 &lt;&lt; ；</li>
		<li>标准输出　　(stdout)：代码为 1 ，使用 &gt; 或 &gt;&gt; ；</li>
		<li>标准错误输出(stderr)：代码为 2 ，使用 2&gt; 或 2&gt;&gt; ；</li>
		</ol>

		<p>为了理解 stdout 与 stderr ，我们先来进行一个范例的练习：</p>

<table class="term"><tbody><tr><td class="term"><pre><span class="term_hd">范例一：观察你的系统根目录 (/) 下各目录的文件名、权限与属性，并记录下来</span>
[root@www ~]# <span class="term_command">ll /</span>  <span class="term_note">&lt;==此时屏幕会显示出文件名信息</span>

[root@www ~]# <span class="term_command">ll / &gt; ~/rootfile</span> <span class="term_note">&lt;==屏幕并无任何信息</span>
[root@www ~]# <span class="term_command">ll  ~/rootfile</span> <span class="term_note">&lt;==有个新档被创建了！</span>
-rw-r--r-- 1 root root 1089 Feb  6 17:00 /root/rootfile
</pre></td></tr></tbody></table>

		<p>怪了！屏幕怎么会完全没有数据呢？这是因为原本『 ll / 』所显示的数据已经被重新导向到 ~/rootfile 文件中了！
		那个 ~/rootfile 的档名可以随便你取。如果你下达『 cat ~/rootfile 』那就可以看到原本应该在屏幕上面的数据啰。
		如果我再次下达：『 ll /home &gt; ~/rootfile 』后，那个 ~/rootfile 文件的内容变成什么？
		他将变成『仅有 ll /home 的数据』而已！咦！原本的『 ll / 』数据就不见了吗？是的！因为该文件的创建方式是：</p>

		<ol class="text_import2">
		<li>该文件 (本例中是 ~/rootfile) 若不存在，系统会自动的将他创建起来，但是</li>
		<li>当这个文件存在的时候，那么系统就会先将这个文件内容清空，然后再将数据写入！</li>
		<li>也就是若以 &gt; 输出到一个已存在的文件中，那个文件就会被覆盖掉啰！</li>
		</ol>

		<p>那如果我想要将数据累加而不想要将旧的数据删除，那该如何是好？利用两个大于的符号 (&gt;&gt;)
		就好啦！以上面的范例来说，你应该要改成『 <span class="text_import2">ll / &gt;&gt; ~/rootfile</span> 』即可。
		如此一来，当 (1) ~/rootfile 不存在时系统会主动创建这个文件；(2)若该文件已存在，
		则数据会在该文件的最下方累加进去！</p>

		<p>上面谈到的是 standard output 的正确数据，那如果是 standard error output 的错误数据呢？那就透过 2&gt; 及
		2&gt;&gt; 啰！同样是覆盖 (2&gt;) 与累加 (2&gt;&gt;) 的特性！我们在刚刚才谈到 stdout 代码是 1 而 stderr 代码是 2 ，
		所以这个 2&gt; 是很容易理解的，而如果仅存在 &gt; 时，则代表默认的代码 1 啰！也就是说：</p>

		<ul class="text_import2" style="font-family: &#39;细明体&#39;;">
		<li>1&gt; ：以覆盖的方法将『正确的数据』输出到指定的文件或装置上；</li>
		<li>1&gt;&gt;：以累加的方法将『正确的数据』输出到指定的文件或装置上；</li>
		<li>2&gt; ：以覆盖的方法将『错误的数据』输出到指定的文件或装置上；</li>
		<li>2&gt;&gt;：以累加的方法将『错误的数据』输出到指定的文件或装置上；</li>
		</ul>

		<p>要注意喔，『 1&gt;&gt; 』以及『 2&gt;&gt; 』中间是没有空格的！OK！有些概念之后让我们继续聊一聊这家伙怎么应用吧！
		当你以一般身份运行 <a href="http://cn.linux.vbird.org/linux_basic/0220filemanager.php#find">find</a>
		这个命令的时候，由于权限的问题可能会产生一些错误信息。例如运行『 <span class="text_import2">find / -name 
		testing</span> 』时，可能会产生类似『 find: /root: Permission denied 』之类的信息。
		例如底下这个范例：</p>

<table class="term"><tbody><tr><td class="term"><pre><span class="term_hd">范例二：利用一般身份账号搜寻 /home 底下是否有名为 .bashrc 的文件存在</span>
[root@www ~]# <span class="term_command">su - dmtsai</span>  <span class="term_note">&lt;==假设我的系统有名为 dmtsai 的账号</span>
[dmtsai@www ~]$ <span class="term_command">find /home -name .bashrc</span> <span class="term_note">&lt;==身份是 dmtsai 喔！</span>
find: /home/lost+found: Permission denied  <span class="term_note">&lt;== Standard error</span>
find: /home/alex: Permission denied        <span class="term_note">&lt;== Standard error</span>
find: /home/arod: Permission denied        <span class="term_note">&lt;== Standard error</span>
/home/dmtsai/.bashrc                       <span class="term_note">&lt;== Standard output</span>
</pre></td></tr></tbody></table>

		<p>由于 /home 底下还有我们之前创建的账号存在，那些账号的家目录你当然不能进入啊！所以就会有错误及正确数据了。
		好了，那么假如我想要将数据输出到 list 这个文件中呢？运行『 find /home -name .bashrc &gt; list 』
		会有什么结果？呵呵，你会发现 <span class="text_import2">list 里面存了刚刚那个『正确』的输出数据，
		至于屏幕上还是会有错误的信息出现呢</span>！伤脑筋！如果想要将正确的与错误的数据分别存入不同的文件中需要怎么做？</p>

<table class="term"><tbody><tr><td class="term"><pre><span class="term_hd">范例三：承范例二，将 stdout 与 stderr 分存到不同的文件去</span>
[dmtsai@www ~]$ <span class="term_command">find /home -name .bashrc &gt; list_right 2&gt; list_error</span>
</pre></td></tr></tbody></table>

		<p>注意喔，此时『屏幕上不会出现任何信息』！因为刚刚运行的结果中，有 Permission 的那几行错误信息都会跑到 list_error 
		这个文件中，至于正确的输出数据则会存到 list_right 这个文件中啰！这样可以了解了吗？
		如果有点混乱的话，去休息一下再来看看吧！<br><br></p>

		<hr><ul class="list1"><li class="text_import1">/dev/null 垃圾桶黑洞装置与特殊写法</li></ul>

		<p>想象一下，如果我知道错误信息会发生，所以要将错误信息忽略掉而不显示或储存呢？
		这个时候黑洞装置 /dev/null 就很重要了！这个 /dev/null 可以吃掉任何导向这个装置的信息喔！将上述的范例修订一下：</p>

<table class="term"><tbody><tr><td class="term"><pre><span class="term_hd">范例四：承范例三，将错误的数据丢弃，屏幕上显示正确的数据</span>
[dmtsai@www ~]$ <span class="term_command">find /home -name .bashrc 2&gt; /dev/null</span>
/home/dmtsai/.bashrc  <span class="term_note">&lt;==只有 stdout 会显示到屏幕上， stderr 被丢弃了</span>
</pre></td></tr></tbody></table>

		<p>再想象一下，如果我要将正确与错误数据通通写入同一个文件去呢？这个时候就得要使用特殊的写法了！
		我们同样用底下的案例来说明：</p>

<table class="term"><tbody><tr><td class="term"><pre><span class="term_hd">范例五：将命令的数据全部写入名为 list 的文件中</span>
[dmtsai@www ~]$ <span class="term_command">find /home -name .bashrc &gt; list 2&gt; list</span>  <span class="term_note">&lt;==错误</span>
[dmtsai@www ~]$ <span class="term_command">find /home -name .bashrc &gt; list 2&gt;&amp;1   </span>  <span class="term_note">&lt;==正确</span>
[dmtsai@www ~]$ <span class="term_command">find /home -name .bashrc &amp;&gt; list       </span>  <span class="term_note">&lt;==正确</span>
</pre></td></tr></tbody></table>

		<p>上述表格第一行错误的原因是，<span class="text_import2">由于两股数据同时写入一个文件，又没有使用特殊的语法，
		此时两股数据可能会交叉写入该文件内，造成次序的错乱</span>。所以虽然最终 list 
		文件还是会产生，但是里面的数据排列就会怪怪的，而不是原本屏幕上的输出排序。
		至于写入同一个文件的特殊语法如上表所示，你可以使用 2&gt;&amp;1 也可以使用 &amp;&gt; ！
		一般来说，鸟哥比较习惯使用 2&gt;&amp;1 的语法啦！<br><br></p>

		<hr><ul class="list1"><li class="text_import1">standard input ： &lt; 与 &lt;&lt;</li></ul>

		<p>了解了 stderr 与 stdout 后，那么那个 &lt; 又是什么呀？呵呵！以最简单的说法来说，
		那就是『<span class="text_import2">将原本需要由键盘输入的数据，改由文件内容来取代</span>』的意思。
		我们先由底下的 cat 命令操作来了解一下什么叫做『键盘输入』吧！</p>

<table class="term"><tbody><tr><td class="term"><pre><span class="term_hd">范例六：利用 cat 命令来创建一个文件的简单流程</span>
[root@www ~]# <span class="term_command">cat &gt; catfile</span>
<span class="term_command">testing
cat file test</span>
<span class="term_note">&lt;==这里按下 [ctrl]+d 来离开</span>

[root@www ~]# <span class="term_command">cat catfile</span>
testing
cat file test
</pre></td></tr></tbody></table>

		<p>由于加入 &gt; 在 cat 后，所以那个 catfile 会被主动的创建，而内容就是刚刚键盘上面输入的那两行数据了。
		唔！那我能不能用纯文本文件取代键盘的输入，也就是说，<span class="text_import2">用某个文件的内容来取代键盘的敲击呢？</span>
		可以的！如下所示：</p>

<table class="term"><tbody><tr><td class="term"><pre><span class="term_hd">范例七：用 stdin 取代键盘的输入以创建新文件的简单流程</span>
[root@www ~]# <span class="term_command">cat &gt; catfile &lt; ~/.bashrc</span>
[root@www ~]# <span class="term_command">ll catfile ~/.bashrc</span>
-rw-r--r-- 1 root root <span class="term_write">194</span> Sep 26 13:36 /root/.bashrc
-rw-r--r-- 1 root root <span class="term_write">194</span> Feb  6 18:29 catfile
<span class="term_say"># 注意看，这两个文件的大小会一模一样！几乎像是使用 cp 来复制一般！</span>
</pre></td></tr></tbody></table>

		<p>这东西非常的有帮助！尤其是用在类似 mail 这种命令的使用上。
		理解 &lt; 之后，再来则是怪可怕一把的 &lt;&lt; 这个连续两个小于的符号了。
		他代表的是『结束的输入字符』的意思！举例来讲：『我要用 cat 直接将输入的信息输出到 catfile 中，
		且当由键盘输入 eof 时，该次输入就结束』，那我可以这样做：</p>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">cat &gt; catfile &lt;&lt; "eof"</span>
&gt; <span class="term_command">This is a test.</span>
&gt; <span class="term_command">OK now stop</span>
&gt; <span class="term_command">eof</span>  <span class="term_note">&lt;==输入这关键词，立刻就结束而不需要输入 [ctrl]+d</span>

[root@www ~]# <span class="term_command">cat catfile</span>
This is a test.
OK now stop     <span class="term_note">&lt;==只有这两行，不会存在关键词那一行！</span>
</pre></td></tr></tbody></table>

		<p>看到了吗？利用 &lt;&lt; 右侧的控制字符，我们可以终止一次输入，
		而不必输入 [crtl]+d 来结束哩！这对程序写作很有帮助喔！好了，那么为何要使用命令输出重导向呢？我们来说一说吧！</p>

		<ul class="text_import2">
		<li>屏幕输出的信息很重要，而且我们需要将他存下来的时候；</li>
		<li>背景运行中的程序，不希望他干扰屏幕正常的输出结果时；</li>
		<li>一些系统的例行命令 (例如写在 /etc/crontab 中的文件) 的运行结果，希望他可以存下来时；</li>
		<li>一些运行命令的可能已知错误信息时，想以『 2&gt; /dev/null 』将他丢掉时；</li>
		<li>错误信息与正确信息需要分别输出时。</li></ul>

		<p>当然还有很多的功能的，最简单的就是网友们常常问到的：『<span class="text_import2">为何我的 root 
		都会收到系统 crontab 寄来的错误信息呢</span>』这个咚咚是常见的错误，
		而如果我们已经知道这个错误信息是可以忽略的时候，嗯！『 2&gt; errorfile 』这个功能就很重要了吧！
		了解了吗？</p>
	</div>

	<hr><a name="redirect_com"></a><img src="./鸟哥的 Linux 私房菜12 -- 学习 bash shell_files/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">命令运行的判断依据： ; , &amp;&amp;, 
	||</span><br>
	<div class="block2">
		<p>在某些情况下，很多命令我想要一次输入去运行，而不想要分次运行时，该如何是好？基本上你有两个选择，
		一个是透过第十三章要介绍的 <a href="http://cn.linux.vbird.org/linux_basic/0340bashshell-scripts.php">shell script</a> 
		撰写脚本去运行，一种则是透过底下的介绍来一次输入多重命令喔！<br><br></p>

		<hr><ul class="list1"><li class="text_import1">cmd ; cmd (不考虑命令相关性的连续命令下达)</li></ul>

		<p>在某些时候，我们希望可以一次运行多个命令，例如在关机的时候我希望可以先运行两次 sync 同步化写入磁盘后才 shutdown 
		计算机，那么可以怎么作呢？这样做呀：</p>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">sync; sync; shutdown -h now</span>
</pre></td></tr></tbody></table>

		<p>在命令与命令中间利用分号 (;) 来隔开，这样一来，分号前的命令运行完后就会立刻接着运行后面的命令了。
		这真是方便啊～再来，换个角度来想，万一我想要在某个目录底下创建一个文件，也就是说，如果该目录存在的话，
		那我才创建这个文件，如果不存在，那就算了。也就是说这两个命令彼此之间是有相关性的，
		前一个命令是否成功的运行与后一个命令是否要运行有关！那就得动用到 &amp;&amp; 或 || 啰！<br><br></p>

		<hr><ul class="list1"><li class="text_import1">$? (命令回传值) 与 &amp;&amp; 或 ||</li></ul>

		<p>如同上面谈到的，两个命令之间有相依性，而这个相依性主要判断的地方就在于前一个命令运行的结果是否正确。
		还记得本章之前我们曾介绍过<a href="http://cn.linux.vbird.org/linux_basic/0320bash.php#returnvar">命令回传值</a>吧！嘿嘿！没错，您真聪明！就是透过这个回传值啦！
		再复习一次『<span class="text_import2">若前一个命令运行的结果为正确，在 Linux 底下会回传一个 $? = 0 的值</span>』。
		那么我们怎么透过这个回传值来判断后续的命令是否要运行呢？这就得要藉由『 &amp;&amp; 』及『 || 』的帮忙了！
		注意喔，<span class="text_import2">两个 &amp; 之间是没有空格的！那个 | 则是 [Shift]+[\] 的按键结果</span>。</p>

<table class="fontwidth" bgcolor="lightyellow" border="1" cellpadding="3" cellspacing="0" width="95%">
<tbody><tr align="center" bgcolor="#182448"><td><font color="#FFFFFF">命令下达情况</font></td><td><font color="#FFFFFF">说明</font></td></tr>
<tr><td>cmd1 &amp;&amp; cmd2</td><td>1. 若 cmd1 运行完毕且正确运行($?=0)，则开始运行 cmd2。<br>
2. 若 cmd1 运行完毕且为错误 ($?≠0)，则 cmd2 不运行。</td></tr>
<tr><td>cmd1 || cmd2</td><td>1. 若 cmd1 运行完毕且正确运行($?=0)，则 cmd2 不运行。<br>
2. 若 cmd1 运行完毕且为错误 ($?≠0)，则开始运行 cmd2。</td></tr>
</tbody></table>

		<p>上述的 cmd1 及 cmd2 都是命令。好了，回到我们刚刚假想的情况，就是想要：
		(1)先判断一个目录是否存在； (2)若存在才在该目录底下创建一个文件。由于我们尚未介绍如何判断式 (<a href="http://cn.linux.vbird.org/linux_basic/0340bashshell-scripts.php#test">test</a>) 的使用，在这里我们使用 ls 以及回传值来判断目录是否存在啦！
		让我们进行底下这个练习看看：</p>

<table class="term"><tbody><tr><td class="term"><pre><span class="term_hd">范例一：使用 ls 查阅目录 /tmp/abc 是否存在，若存在则用 touch 创建 /tmp/abc/hehe </span>
[root@www ~]# <span class="term_command">ls /tmp/abc &amp;&amp; touch /tmp/abc/hehe</span>
ls: /tmp/abc: No such file or directory 
<span class="term_say"># ls 很干脆的说明找不到该目录，但并没有 touch 的错误，表示 touch 并没有运行</span>

[root@www ~]# <span class="term_command">mkdir /tmp/abc</span>
[root@www ~]# <span class="term_command">ls /tmp/abc &amp;&amp; touch /tmp/abc/hehe</span>
[root@www ~]# <span class="term_command">ll /tmp/abc</span>
-rw-r--r-- 1 root root 0 Feb  7 12:43 hehe
</pre></td></tr></tbody></table>

		<p>看到了吧？如果 /tmp/abc 不存在时，touch 就不会被运行，若 /tmp/abc 存在的话，那么 touch 就会开始运行啰！
		很不错用吧！不过，我们还得手动自行创建目录，伤脑筋～能不能自动判断，如果没有该目录就给予创建呢？
		参考一下底下的例子先：</p>

<table class="term"><tbody><tr><td class="term"><pre><span class="term_hd">范例二：测试 /tmp/abc 是否存在，若不存在则予以创建，若存在就不作任何事情</span>
[root@www ~]# <span class="term_command">rm -r /tmp/abc               </span> <span class="term_note">&lt;==先删除此目录以方便测试</span>
[root@www ~]# <span class="term_command">ls /tmp/abc || mkdir /tmp/abc</span>
ls: /tmp/abc: No such file or directory <span class="term_note">&lt;==真的不存在喔！</span>
[root@www ~]# <span class="term_command">ll /tmp/abc                  </span>
total 0                                 <span class="term_note">&lt;==结果出现了！有进行 mkdir</span>
</pre></td></tr></tbody></table>

		<p>如果你一再重复『 ls /tmp/abc || mkdir /tmp/abc 』画面也不会出现重复 mkdir 的错误！这是因为 /tmp/abc 已经存在，
		所以后续的 mkdir 就不会进行！这样理解否？好了，让我们再次的讨论一下，如果我想要创建 /tmp/abc/hehe 这个文件，
		但我并不知道 /tmp/abc 是否存在，那该如何是好？试看看：</p>

<table class="term"><tbody><tr><td class="term"><pre><span class="term_hd">范例三：我不清楚 /tmp/abc 是否存在，但就是要创建 /tmp/abc/hehe 文件</span>
[root@www ~]# <span class="term_command">ls /tmp/abc || mkdir /tmp/abc &amp;&amp; touch /tmp/abc/hehe</span>
</pre></td></tr></tbody></table>

		<p>上面这个范例三总是会创建 /tmp/abc/hehe 的喔！不论 /tmp/abc 是否存在。那么范例三应该如何解释呢？
		由于<span class="text_import2">Linux 底下的命令都是由左往右运行</span>的，所以范例三有几种结果我们来分析一下：</p>
		<ul>
		<li>(1)若 /tmp/abc 不存在故回传 $?≠0，则 (2)因为 || 遇到非为 0 的 $? 故开始 mkdir /tmp/abc，由于 mkdir /tmp/abc
		会成功进行，所以回传 $?=0 (3)因为 &amp;&amp; 遇到 $?=0 故会运行 touch /tmp/abc/hehe，最终 hehe 
		就被创建了；<br><br></li>
		<li>(1)若 /tmp/abc 存在故回传 $?=0，则 (2)因为 || 遇到 0 的 $? 不会进行，此时 $?=0 继续向后传，故 
		(3)因为 &amp;&amp; 遇到 $?=0 就开始创建 /tmp/abc/hehe 了！最终 /tmp/abc/hehe 被创建起来。</li>
		</ul>

		<p>整个流程图示如下：</p>

		<center><img src="./鸟哥的 Linux 私房菜12 -- 学习 bash shell_files/cmd_1.gif" alt="命令依序运行的关系示意图" title="命令依序运行的关系示意图" border="0"><br>
		图 5.2.1、 命令依序运行的关系示意图<br></center>

		<p>上面这张图显示的两股数据中，上方的线段为不存在 /tmp/abc 时所进行的命令行为，下方的线段则是存在 
		/tmp/abc 所在的命令行为。如上所述，下方线段由于存在 /tmp/abc 所以导致 $?=0 ，让中间的 mkdir 就不运行了！
		并将 $?=0 继续往后传给后续的 touch 去利用啦！瞭乎？在任何时刻你都可以拿上面这张图作为示意！
		让我们来想想底下这个例题吧！</p>


<table border="1" cellpadding="5" cellspacing="0" width="90%"><tbody><tr><td>
例题：<div class="block2">
以 ls 测试 /tmp/vbirding 是否存在，若存在则显示 "exist" ，若不存在，则显示 "not exist"！
</div>
答：<div class="block2">
这又牵涉到逻辑判断的问题，如果存在就显示某个数据，若不存在就显示其他数据，那我可以这样做：
<blockquote class="text_import2" style="font-family: &#39;细明体&#39;;">
	ls /tmp/vbirding &amp;&amp; echo "exist" || echo "not exist"</blockquote>
意思是说，当 ls /tmp/vbirding 运行后，若正确，就运行 echo "exist" ，若有问题，就运行 echo "not exist" 
！那如果写成如下的状况会出现什么？
<blockquote class="text_import2" style="font-family: &#39;细明体&#39;;">
	ls /tmp/vbirding || echo "not exist" &amp;&amp; echo "exist"</blockquote>
这其实是有问题的，为什么呢？由图 5.2.1 的流程介绍我们知道命令是一个一个往后运行，
因此在上面的例子当中，如果 /tmp/vbirding 不存在时，他会进行如下动作：
<ol>
<li>若 ls /tmp/vbirding 不存在，因此回传一个非为 0 的数值；</li>
<li>接下来经过 || 的判断，发现前一个命令回传非为 0 的数值，因此，程序开始运行 echo "not exist" ，而 echo "not exist" 
程序肯定可以运行成功，因此会回传一个 0 值给后面的命令；</li>
<li>经过 &amp;&amp; 的判断，咦！是 0 啊！所以就开始运行 echo "exist" 。</li></ol>
所以啊，嘿嘿！第二个例子里面竟然会同时出现 not exist 与 exist 呢！真神奇～
</div>
</td></tr></tbody></table><br>

		<p>经过这个例题的练习，你应该会了解，<span class="text_import2">由于命令是一个接着一个去运行的，因此，如果真要使用判断，
		那么这个 &amp;&amp; 与 || 的顺序就不能搞错</span>。一般来说，假设判断式有三个，也就是：</p>
		<blockquote class="text_import2" style="font-family: &#39;细明体&#39;;">
		command1 &amp;&amp; command2 || command3</blockquote>
		<p>而且顺序通常不会变，因为一般来说， command2 与 command3 会放置肯定可以运行成功的命令，
		因此，依据上面例题的逻辑分析，您就会晓得为何要如此放置啰～这很有用的啦！而且.....考试也很常考～</p>
	</div>
</div>

<hr><a name="pipe"></a><img src="./鸟哥的 Linux 私房菜12 -- 学习 bash shell_files/logo.png" alt="大标题的图示" width="35" align="middle" height="34"><span class="text_h1">管线命令 (pipe)</span><br>
<div class="block1">
	<p>就如同前面所说的， bash 命令运行的时候有输出的数据会出现！
	那么如果这群数据必需要经过几道手续之后才能得到我们所想要的格式，应该如何来配置？
	这就牵涉到管线命令的问题了 (pipe) ，<span class="text_import2">管线命令使用的是『 | 』这个界定符号</span>！
	另外，<span class="text_import2">管线命令与『连续下达命令』是不一样的呦</span>！
	这点底下我们会再说明。底下我们先举一个例子来说明一下简单的管线命令。</p>

	<p>假设我们想要知道 /etc/ 底下有多少文件，那么可以利用 ls /etc 来查阅，不过，
	因为 /etc 底下的文件太多，导致一口气就将屏幕塞满了～不知道前面输出的内容是啥？此时，我们可以透过 
	less 命令的协助，利用：</p>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">ls -al /etc | less</span>
</pre></td></tr></tbody></table>

	<p>如此一来，使用 ls 命令输出后的内容，就能够被 less 读取，并且利用 less 
	的功能，我们就能够前后翻动相关的信息了！很方便是吧？我们就来了解一下这个管线命令『 | 』的用途吧！
	其实<span class="text_import2">这个管线命令『 | 』仅能处理经由前面一个命令传来的正确信息，也就是 standard output 
	的信息，对于 stdandard error 并没有直接处理的能力</span>。那么整体的管线命令可以使用下图表示：</p>

	<center><img src="./鸟哥的 Linux 私房菜12 -- 学习 bash shell_files/0320bash_3.png" alt="管线命令的处理示意图" title="管线命令的处理示意图" border="0"><br>
	图 6.1.1、 管线命令的处理示意图<br></center>

	<p>在每个管线后面接的第一个数据必定是『命令』喔！而且<span class="text_import2">这个命令必须要能够接受 standard input
	的数据</span>才行，这样的命令才可以是为『管线命令』，例如 less, more, head, tail 等都是可以接受 standard input
	的管线命令啦。至于例如 ls, cp, mv 等就不是管线命令了！因为 ls, cp, mv 并不会接受来自 stdin 的数据。
	也就是说，管线命令主要有两个比较需要注意的地方：</p>
	<ul class="text_import2">
	<li>管线命令仅会处理 standard output，对于 standard error output 会予以忽略</li>
	<li>管线命令必须要能够接受来自前一个命令的数据成为 standard input 继续处理才行。</li>
	</ul>
	<p>多说无益，让我们来玩一些管线命令吧！底下的咚咚对系统管理非常有帮助喔！<br><br></p>

	<hr><a name="pipe_1"></a><img src="./鸟哥的 Linux 私房菜12 -- 学习 bash shell_files/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">撷取命令： cut, grep</span><br>
	<div class="block2">
		<p>什么是撷取命令啊？说穿了，就是将一段数据经过分析后，取出我们所想要的。或者是经由分析关键词，取得我们所想要的那一行！
		不过，要注意的是，一般来说，<span class="text_import2">撷取信息通常是针对『一行一行』来分析的</span>，
		并不是整篇信息分析的喔～底下我们介绍两个很常用的信息撷取命令：<br><br></p>

		<a name="cut"></a>
		<hr><ul class="list1"><li class="text_import1">cut</li></ul>

		<p>cut 不就是『切』吗？没错啦！这个命令可以将一段信息的某一段给他『切』出来～
		处理的信息是以『行』为单位喔！底下我们就来谈一谈：</p>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">cut -d'分隔字符' -f fields</span> <span class="term_note">&lt;==用于有特定分隔字符</span>
[root@www ~]# <span class="term_command">cut -c 字符区间           </span> <span class="term_note">&lt;==用于排列整齐的信息</span>
<span class="term_say">选项与参数：
-d  ：后面接分隔字符。与 -f 一起使用；
-f  ：依据 -d 的分隔字符将一段信息分割成为数段，用 -f 取出第几段的意思；
-c  ：以字符 (characters) 的单位取出固定字符区间；</span>

<span class="term_hd"><a name="20070405"></a>范例一：将 PATH 变量取出，我要找出第五个路径。</span>
[root@www ~]# <span class="term_command">echo $PATH</span>
/bin:/usr/bin:/sbin:/usr/sbin:/usr/local/bin:/usr/X11R6/bin:/usr/games:
<span class="term_say"># 1 |    2   |  3  |    4    |       5      |     6        |    7</span>

[root@www ~]# <span class="term_command">echo $PATH | cut -d ':' -f 5</span>
<span class="term_say"># 如同上面的数字显示，我们是以『 : 』作为分隔，因此会出现 /usr/local/bin 
# 那么如果想要列出第 3 与第 5 呢？，就是这样：</span>
[root@www ~]# <span class="term_command">echo $PATH | cut -d ':' -f 3,5</span>

<span class="term_hd">范例二：将 export 输出的信息，取得第 12 字符以后的所有字符串</span>
[root@www ~]# <span class="term_command">export</span>
declare -x HISTSIZE="1000"
declare -x INPUTRC="/etc/inputrc"
declare -x KDEDIR="/usr"
declare -x LANG="zh_TW.big5"
<span class="term_say">.....(其他省略).....
# 注意看，每个数据都是排列整齐的输出！如果我们不想要『 declare -x 』时，
# 就得这么做：</span>

[root@www ~]# <span class="term_command">export | cut -c 12-</span>
HISTSIZE="1000"
INPUTRC="/etc/inputrc"
KDEDIR="/usr"
LANG="zh_TW.big5"
<span class="term_say">.....(其他省略).....
# 知道怎么回事了吧？用 -c 可以处理比较具有格式的输出数据！
# 我们还可以指定某个范围的值，例如第 12-20 的字符，就是 cut -c 12-20 等等！</span>
<a name="last"></a>
<span class="term_hd">范例三：用 last 将显示的登陆者的信息中，仅留下用户大名</span>
[root@www ~]# <span class="term_command">last</span>
root   pts/1    192.168.201.101  Sat Feb  7 12:35   still logged in
root   pts/1    192.168.201.101  Fri Feb  6 12:13 - 18:46  (06:33)
root   pts/1    192.168.201.254  Thu Feb  5 22:37 - 23:53  (01:16)
<span class="term_say"># last 可以输出『账号/终端机/来源/日期时间』的数据，并且是排列整齐的</span>

[root@www ~]# <span class="term_command">last | cut -d ' ' -f 1</span>
<span class="term_say"># 由输出的结果我们可以发现第一个空白分隔的字段代表账号，所以使用如上命令：
# 但是因为 root   pts/1 之间空格有好几个，并非仅有一个，所以，如果要找出 
# pts/1 其实不能以 cut -d ' ' -f 1,2 喔！输出的结果会不是我们想要的。</span>
</pre></td></tr></tbody></table>

		<p>cut 主要的用途在于将『同一行里面的数据进行分解！』最常使用在分析一些数据或文字数据的时候！
		这是因为有时候我们会以某些字符当作分割的参数，然后来将数据加以切割，以取得我们所需要的数据。
		鸟哥也很常使用这个功能呢！尤其是在分析 log 文件的时候！不过，cut 
		在处理多空格相连的数据时，可能会比较吃力一点。<br><br></p>

		<a name="grep"></a>
		<hr><ul class="list1"><li class="text_import1">grep</li></ul>

		<p>刚刚的 cut 是将一行信息当中，取出某部分我们想要的，而 grep 则是分析一行信息，
		若当中有我们所需要的信息，就将该行拿出来～简单的语法是这样的：</p>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">grep [-acinv] [--color=auto] '搜寻字符串' filename</span>
<span class="term_say">选项与参数：
-a ：将 binary 文件以 text 文件的方式搜寻数据
-c ：计算找到 '搜寻字符串' 的次数
-i ：忽略大小写的不同，所以大小写视为相同
-n ：顺便输出行号
-v ：反向选择，亦即显示出没有 '搜寻字符串' 内容的那一行！
--color=auto ：可以将找到的关键词部分加上颜色的显示喔！</span>

<span class="term_hd">范例一：将 last 当中，有出现 root 的那一行就取出来；</span>
[root@www ~]# <span class="term_command">last | grep 'root'</span>

<span class="term_hd">范例二：与范例一相反，只要没有 root 的就取出！</span>
[root@www ~]# <span class="term_command">last | grep -v 'root'</span>

<span class="term_hd">范例三：在 last 的输出信息中，只要有 root 就取出，并且仅取第一栏</span>
[root@www ~]# <span class="term_command">last | grep 'root' |cut -d ' ' -f1</span>
<span class="term_say"># 在取出 root 之后，利用上个命令 cut 的处理，就能够仅取得第一栏啰！</span>

<span class="term_hd">范例四：取出 /etc/man.config 内含 MANPATH 的那几行</span>
[root@www ~]# <span class="term_command">grep --color=auto 'MANPATH' /etc/man.config</span>
<span class="term_say">....(前面省略)....</span>
<span class="term_write">MANPATH</span>_MAP     /usr/X11R6/bin          /usr/X11R6/man
<span class="term_write">MANPATH</span>_MAP     /usr/bin/X11            /usr/X11R6/man
<span class="term_write">MANPATH</span>_MAP     /usr/bin/mh             /usr/share/man
<span class="term_say"># 神奇的是，如果加上 --color=auto 的选项，找到的关键词部分会用特殊颜色显示喔！</span>
</pre></td></tr></tbody></table>

		<p>grep 是个很棒的命令喔！他支持的语法实在是太多了～用在正规表示法里头，
		能够处理的数据实在是多的很～不过，我们这里先不谈正规表示法～下一章再来说明～
		您先了解一下， grep 可以解析一行文字，取得关键词，若该行有存在关键词，就会整行列出来！</p>
	</div>

	<hr><a name="pipe_2"></a><img src="./鸟哥的 Linux 私房菜12 -- 学习 bash shell_files/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">排序命令： sort, wc, uniq</span><br>
	<div class="block2">
		<p>很多时候，我们都会去计算一次数据里头的相同型态的数据总数，举例来说，
		使用 last 可以查得这个月份有登陆主机者的身份。那么我可以针对每个使用者查出他们的总登陆次数吗？
		此时就得要排序与计算之类的命令来辅助了！底下我们介绍几个好用的排序与统计命令喔！<br><br></p>

		<a name="sort"></a>
		<hr><ul class="list1"><li class="text_import1">sort</li></ul>

		<p>sort 是很有趣的命令，他可以帮我们进行排序，而且可以依据不同的数据型态来排序喔！
		例如数字与文字的排序就不一样。此外，排序的字符与语系的编码有关，因此，
		如果您需要排序时，建议使用 LANG=C 来让语系统一，数据排序比较好一些。</p>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">sort [-fbMnrtuk] [file or stdin]</span>
<span class="term_say">选项与参数：
-f  ：忽略大小写的差异，例如 A 与 a 视为编码相同；
-b  ：忽略最前面的空格符部分；
-M  ：以月份的名字来排序，例如 JAN, DEC 等等的排序方法；
-n  ：使用『纯数字』进行排序(默认是以文字型态来排序的)；
-r  ：反向排序；
-u  ：就是 uniq ，相同的数据中，仅出现一行代表；
-t  ：分隔符，默认是用 [tab] 键来分隔；
-k  ：以那个区间 (field) 来进行排序的意思</span>

<span class="term_hd">范例一：个人账号都记录在 /etc/passwd 下，请将账号进行排序。</span>
[root@www ~]# <span class="term_command">cat /etc/passwd | sort</span>
<span class="term_write">ad</span>m:x:3:4:adm:/var/adm:/sbin/nologin
<span class="term_write">ap</span>ache:x:48:48:Apache:/var/www:/sbin/nologin
<span class="term_write">b</span>in:x:1:1:bin:/bin:/sbin/nologin
<span class="term_write">d</span>aemon:x:2:2:daemon:/sbin:/sbin/nologin
<span class="term_say"># 鸟哥省略很多的输出～由上面的数据看起来， sort 是默认『以第一个』数据来排序，
# 而且默认是以『文字』型态来排序的喔！所以由 a 开始排到最后啰！</span>

<span class="term_hd">范例二：/etc/passwd 内容是以 : 来分隔的，我想以第三栏来排序，该如何？</span>
[root@www ~]# <span class="term_command">cat /etc/passwd | sort -t ':' -k 3</span>
root:x:<span class="term_write">0</span>:0:root:/root:/bin/bash
uucp:x:<span class="term_write">10</span>:14:uucp:/var/spool/uucp:/sbin/nologin
operator:x:<span class="term_write">11</span>:0:operator:/root:/sbin/nologin
bin:x:<span class="term_write">1</span>:1:bin:/bin:/sbin/nologin
games:x:<span class="term_write">12</span>:100:games:/usr/games:/sbin/nologin
<span class="term_say"># 看到特殊字体的输出部分了吧？怎么会这样排列啊？呵呵！没错啦～
# 如果是以文字型态来排序的话，原本就会是这样，想要使用数字排序：
# cat /etc/passwd | sort -t ':' -k 3 -n
# 这样才行啊！用那个 -n 来告知 sort 以数字来排序啊！</span>

<span class="term_hd">范例三：利用 last ，将输出的数据仅取账号，并加以排序</span>
[root@www ~]# <span class="term_command">last | cut -d ' ' -f1 | sort</span>
</pre></td></tr></tbody></table>

		<p>sort 同样是很常用的命令呢！因为我们常常需要比较一些信息啦！
		举个上面的第二个例子来说好了！今天假设你有很多的账号，而且你想要知道最大的使用者 
		ID 目前到哪一号了！呵呵！使用 sort 一下子就可以知道答案咯！当然其使用还不止此啦！
		有空的话不妨玩一玩！<br><br></p>

		<a name="uniq"></a>
		<hr><ul class="list1"><li class="text_import1">uniq</li></ul>

		<p>如果我排序完成了，想要将重复的数据仅列出一个显示，可以怎么做呢？</p>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">uniq [-ic]</span>
<span class="term_say">选项与参数：
-i  ：忽略大小写字符的不同；
-c  ：进行计数</span>

<span class="term_hd">范例一：使用 last 将账号列出，仅取出账号栏，进行排序后仅取出一位；</span>
[root@www ~]# <span class="term_command">last | cut -d ' ' -f1 | sort | uniq</span>

<span class="term_hd">范例二：承上题，如果我还想要知道每个人的登陆总次数呢？</span>
[root@www ~]# <span class="term_command">last | cut -d ' ' -f1 | sort | uniq -c</span>
      1
     12 reboot
     41 root
      1 wtmp
<span class="term_say"># 从上面的结果可以发现 reboot 有 12 次， root 登陆则有 41 次！
# wtmp 与第一行的空白都是 last 的默认字符，那两个可以忽略的！</span>
</pre></td></tr></tbody></table>

		<p>这个命令用来将『重复的行删除掉只显示一个』，举个例子来说，
		你要知道这个月份登陆你主机的用户有谁，而不在乎他的登陆次数，那么就使用上面的范例，
		(1)先将所有的数据列出；(2)再将人名独立出来；(3)经过排序；(4)只显示一个！
		由于这个命令是在将重复的东西减少，所以当然需要『配合排序过的文件』来处理啰！<br><br></p>

		<a name="wc"></a>
		<hr><ul class="list1"><li class="text_import1">wc</li></ul>

		<p>如果我想要知道 /etc/man.config 这个文件里面有多少字？多少行？多少字符的话，
		可以怎么做呢？其实可以利用 wc 这个命令来达成喔！他可以帮我们计算输出的信息的整体数据！</p>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">wc [-lwm]</span>
<span class="term_say">选项与参数：
-l  ：仅列出行；
-w  ：仅列出多少字(英文单字)；
-m  ：多少字符；</span>

<span class="term_hd">范例一：那个 /etc/man.config 里面到底有多少相关字、行、字符数？</span>
[root@www ~]# <span class="term_command">cat /etc/man.config | wc </span>
    141     722    4617
<span class="term_say"># 输出的三个数字中，分别代表： 『行、字数、字符数』</span>

<span class="term_hd">范例二：我知道使用 last 可以输出登陆者，但是 last 最后两行并非账号内容，
        那么请问，我该如何以一行命令串取得这个月份登陆系统的总人次？</span>
[root@www ~]# <span class="term_command">last | grep [a-zA-Z] | grep -v 'wtmp' | wc -l </span>
<span class="term_say"># 由于 last 会输出空白行与 wtmp 字样在最底下两行，因此，我利用
# grep 取出非空白行，以及去除 wtmp 那一行，在计算行数，就能够了解啰！</span>
</pre></td></tr></tbody></table>

		<p><a name="20100416"></a>wc 也可以当作命令？这可不是上洗手间的 WC 
		呢！这是相当有用的计算文件内容的一个工具组喔！举个例子来说，
		当你要知道目前你的账号文件中有多少个账号时，就使用这个方法：『
		cat /etc/passwd | wc -l 』啦！因为 /etc/passwd 里头一行代表一个使用者呀！
		所以知道行数就晓得有多少的账号在里头了！而如果要计算一个文件里头有多少个字符时，就使用
		wc -m 这个选项吧！</p>
	</div>

	<hr><a name="pipe_3"></a><img src="./鸟哥的 Linux 私房菜12 -- 学习 bash shell_files/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">双向重导向： tee</span><br>
	<div class="block2"><a name="tee"></a>
		<p>想个简单的东西，我们由前一节知道 &gt; 会将数据流整个传送给文件或装置，因此我们除非去读取该文件或装置，
		否则就无法继续利用这个数据流。万一我想要将这个数据流的处理过程中将某段信息存下来，应该怎么做？
		利用 tee 就可以啰～我们可以这样简单的看一下：</p>

		<center><img src="./鸟哥的 Linux 私房菜12 -- 学习 bash shell_files/0320bash_5.png" alt="tee 的工作流程示意图" title="tee 的工作流程示意图" border="0"><br>
		图 6.3.1、tee 的工作流程示意图<br></center>

		<p>tee 会同时将数据流分送到文件去与屏幕 (screen)；而输出到屏幕的，其实就是 stdout 
		，可以让下个命令继续处理喔！</p>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">tee [-a] file</span>
<span class="term_say">选项与参数：
-a  ：以累加 (append) 的方式，将数据加入 file 当中！</span>

[root@www ~]# <span class="term_command">last | tee last.list | cut -d " " -f1</span>
<span class="term_say"># 这个范例可以让我们将 last 的输出存一份到 last.list 文件中；</span>

[root@www ~]# <span class="term_command">ls -l /home | tee ~/homefile | more</span>
<span class="term_say"># 这个范例则是将 ls 的数据存一份到 ~/homefile ，同时屏幕也有输出信息！</span>

[root@www ~]# <span class="term_command">ls -l / | tee -a ~/homefile | more</span>
<span class="term_say"># 要注意！ tee 后接的文件会被覆盖，若加上 -a 这个选项则能将信息累加。</span>
</pre></td></tr></tbody></table>

		<p>tee 可以让 standard output 转存一份到文件内并将同样的数据继续送到屏幕去处理！
		这样除了可以让我们同时分析一份数据并记录下来之外，还可以作为处理一份数据的中间缓存盘记录之用！
		tee 这家伙在很多选择/填充的认证考试中很容易考呢！</p>
	</div>

	<hr><a name="pipe_4"></a><img src="./鸟哥的 Linux 私房菜12 -- 学习 bash shell_files/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">字符转换命令： 
	tr, col, join, paste, expand</span><br>
	<div class="block2">
		<p>我们在 <a href="http://cn.linux.vbird.org/linux_basic/0310vi.php#tips_dos">vim 程序编辑器</a>当中，提到过 DOS 
		断行字符与 Unix 断行字符的不同，并且可以使用 dos2unix 与 unix2dos 
		来完成转换。好了，那么思考一下，是否还有其他常用的字符替代？
		举例来说，要将大写改成小写，或者是将数据中的 [tab] 按键转成空格键？还有，如何将两篇信息整合成一篇？
		底下我们就来介绍一下这些字符转换命令在管线当中的使用方法：<br><br></p>

		<a name="tr"></a>
		<hr><ul class="list1"><li class="text_import1">tr</li></ul>

		<p>tr 可以用来删除一段信息当中的文字，或者是进行文字信息的替换！</p>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">tr [-ds] SET1 ...</span>
<span class="term_say">选项与参数：
-d  ：删除信息当中的 SET1 这个字符串；
-s  ：取代掉重复的字符！</span>

<span class="term_hd">范例一：将 last 输出的信息中，所有的小写变成大写字符：</span>
[root@www ~]# <span class="term_command">last | tr '[a-z]' '[A-Z]'</span>
<span class="term_say"># 事实上，没有加上单引号也是可以运行的，如：『 last | tr [a-z] [A-Z] 』</span>

<span class="term_hd">范例二：将 /etc/passwd 输出的信息中，将冒号 (:) 删除</span>
[root@www ~]# <span class="term_command">cat /etc/passwd | tr -d ':'</span>

<span class="term_hd">范例三：将 /etc/passwd 转存成 dos 断行到 /root/passwd 中，再将 ^M 符号删除</span>
[root@www ~]# <span class="term_command">cp /etc/passwd /root/passwd &amp;&amp; unix2dos /root/passwd</span>
[root@www ~]# <span class="term_command">file /etc/passwd /root/passwd</span>
/etc/passwd:  ASCII text
/root/passwd: ASCII text, with CRLF line terminators <span class="term_note">&lt;==就是 DOS 断行</span>
[root@www ~]# <span class="term_command">cat /root/passwd | tr -d '\r' &gt; /root/passwd.linux</span>
<span class="term_say"># 那个 \r 指的是 DOS 的断行字符，关于更多的字符，请参考 man tr</span>
[root@www ~]# <span class="term_command">ll /etc/passwd /root/passwd*</span>
-rw-r--r-- 1 root root <span class="term_write">1986</span> Feb  6 17:55 /etc/passwd
-rw-r--r-- 1 root root <span class="term_write">2030</span> Feb  7 15:55 /root/passwd
-rw-r--r-- 1 root root <span class="term_write">1986</span> Feb  7 15:57 /root/passwd.linux
<span class="term_say"># 处理过后，发现文件大小与原本的 /etc/passwd 就一致了！</span>
</pre></td></tr></tbody></table>

		<p>其实这个命令也可以写在『正规表示法』里头！因为他也是由正规表示法的方式来取代数据的！
		以上面的例子来说，使用 [] 可以配置一串字呢！<span class="text_import2">也常常用来取代文件中的怪异符号</span>！
		例如上面第三个例子当中，可以去除 DOS 文件留下来的 ^M 这个断行的符号！这东西相当的有用！相信处理 Linux &amp;
		Windows 系统中的人们最麻烦的一件事就是这个事情啦！亦即是 DOS 底下会自动的在每行行尾加入
		^M 这个断行符号！这个时候我们可以使用这个 tr 来将 ^M 去除！ ^M 可以使用
		\r 来代替之！<br><br></p>

		<a name="col"></a>
		<hr><ul class="list1"><li class="text_import1">col</li></ul>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">col [-xb]</span>
<span class="term_say">选项与参数：
-x  ：将 tab 键转换成对等的空格键
-b  ：在文字内有反斜杠 (/) 时，仅保留反斜杠最后接的那个字符</span>

<span class="term_hd">范例一：利用 cat -A 显示出所有特殊按键，最后以 col 将 [tab] 转成空白</span>
[root@www ~]# <span class="term_command">cat -A /etc/man.config</span>  <span class="term_note">&lt;==此时会看到很多 ^I 的符号，那就是 tab</span>
[root@www ~]# <span class="term_command">cat /etc/man.config | col -x | cat -A | more</span>
<span class="term_say"># 嘿嘿！如此一来， [tab] 按键会被取代成为空格键，输出就美观多了！</span>

<span class="term_hd">范例二：将 col 的 man page 转存成为 /root/col.man 的纯文本档</span>
[root@www ~]# <span class="term_command">man col &gt; /root/col.man</span>
[root@www ~]# <span class="term_command">vi /root/col.man</span>
COL(1)          BSD General Commands Manual               COL(1)

N^HNA^HAM^HME^HE
     c^Hco^Hol^Hl - filter reverse line feeds from input

S^HSY^HYN^HNO^HOP^HPS^HSI^HIS^HS
     c^Hco^Hol^Hl [-^H-b^Hbf^Hfp^Hpx^Hx] [-^H-l^Hl _^Hn_^Hu_^Hm]
<span class="term_say"># 你没看错！由于 man page 内有些特殊按钮会用来作为类似特殊按键与颜色显示，
# 所以这个文件内就会出现如上所示的一堆怪异字符(有 ^ 的)</span>

[root@www ~]# <span class="term_command">man col | col -b &gt; /root/col.man</span>
</pre></td></tr></tbody></table>

		<p>虽然 col 有他特殊的用途，不过，很多时候，他可以用来简单的处理将 [tab] 按键取代成为空格键！
		例如上面的例子当中，如果使用 cat -A 则 [tab] 会以 ^I 来表示。
		但经过 col -x 的处理，则会将 [tab] 取代成为对等的空格键！此外， <span class="text_import2">col 经常被利用于将 man page
		转存为纯文本文件以方便查阅的功能</span>！如上述的范例二！<br><br></p>

		<a name="join"></a>
		<hr><ul class="list1"><li class="text_import1">join</li></ul>

		<p>join 看字面上的意义 (加入/参加) 就可以知道，他是在处理两个文件之间的数据，
		而且，主要是在处理『<span class="text_import2">两个文件当中，有 <b>"相同数据"</b> 
		的那一行，才将他加在一起</span>』的意思。我们利用底下的简单例子来说明：</p>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">join [-ti12] file1 file2</span>
<span class="term_say">选项与参数：
-t  ：join 默认以空格符分隔数据，并且比对『第一个字段』的数据，
      如果两个文件相同，则将两笔数据联成一行，且第一个字段放在第一个！
-i  ：忽略大小写的差异；
-1  ：这个是数字的 1 ，代表『第一个文件要用那个字段来分析』的意思；
-2  ：代表『第二个文件要用那个字段来分析』的意思。</span>

<span class="term_hd">范例一：用 root 的身份，将 /etc/passwd 与 /etc/shadow 相关数据整合成一栏</span>
[root@www ~]# <span class="term_command">head -n 3 /etc/passwd /etc/shadow</span>
==&gt; /etc/passwd &lt;==
root:x:0:0:root:/root:/bin/bash
bin:x:1:1:bin:/bin:/sbin/nologin
daemon:x:2:2:daemon:/sbin:/sbin/nologin

==&gt; /etc/shadow &lt;==
root:$1$/3AQpE5e$y9A/D0bh6rElAs:14120:0:99999:7:::
bin:*:14126:0:99999:7:::
daemon:*:14126:0:99999:7:::
<span class="term_say"># 由输出的数据可以发现这两个文件的最左边字段都是账号！且以 : 分隔</span>

[root@www ~]# <span class="term_command">join -t ':' /etc/passwd /etc/shadow</span>
<span class="term_write">root</span>:x:0:0:root:/root:/bin/bash:<span class="term_write">$1$/3AQpE5e$y9A/D0bh6rElAs:14120:0:99999:7:::</span>
<span class="term_write">bin</span>:x:1:1:bin:/bin:/sbin/nologin:<span class="term_write">*:14126:0:99999:7:::</span>
<span class="term_write">daemon</span>:x:2:2:daemon:/sbin:/sbin/nologin:<span class="term_write">*:14126:0:99999:7:::</span>
<span class="term_say"># 透过上面这个动作，我们可以将两个文件第一字段相同者整合成一行！
# 第二个文件的相同字段并不会显示(因为已经在第一行了嘛！)</span>

<span class="term_hd">范例二：我们知道 /etc/passwd 第四个字段是 GID ，那个 GID 记录在 
        /etc/group 当中的第三个字段，请问如何将两个文件整合？</span>
[root@www ~]# <span class="term_command">head -n 3 /etc/passwd /etc/group</span>
==&gt; /etc/passwd &lt;==
root:x:0:<span class="term_write">0</span>:root:/root:/bin/bash
bin:x:1:<span class="term_write">1</span>:bin:/bin:/sbin/nologin
daemon:x:2:<span class="term_write">2</span>:daemon:/sbin:/sbin/nologin

==&gt; /etc/group &lt;==
root:x:<span class="term_write">0</span>:root
bin:x:<span class="term_write">1</span>:root,bin,daemon
daemon:x:<span class="term_write">2</span>:root,bin,daemon
<span class="term_say"># 从上面可以看到，确实有相同的部分喔！赶紧来整合一下！</span>

[root@www ~]# <span class="term_command">join -t ':' -1 4 /etc/passwd -2 3 /etc/group</span>
<span class="term_write">0</span>:root:x:0:root:/root:/bin/bash:<span class="term_write">root:x:root</span>
<span class="term_write">1</span>:bin:x:1:bin:/bin:/sbin/nologin:<span class="term_write">bin:x:root,bin,daemon</span>
<span class="term_write">2</span>:daemon:x:2:daemon:/sbin:/sbin/nologin:<span class="term_write">daemon:x:root,bin,daemon</span>
<span class="term_say"># 同样的，相同的字段部分被移动到最前面了！所以第二个文件的内容就没再显示。
# 请读者们配合上述显示两个文件的实际内容来比对！</span>
</pre></td></tr></tbody></table>

		<p>这个 join 在处理两个相关的数据文件时，就真的是很有帮助的啦！
		例如上面的案例当中，我的 /etc/passwd, /etc/shadow, /etc/group 都是有相关性的，
		其中 /etc/passwd, /etc/shadow 以账号为相关性，至于 /etc/passwd, /etc/group 
		则以所谓的 GID (账号的数字定义) 来作为他的相关性。根据这个相关性，
		我们可以将有关系的数据放置在一起！这在处理数据可是相当有帮助的！
		但是上面的例子有点难，希望您可以静下心好好的看一看原因喔！</p>

		<p><a name="20070411"></a>此外，需要特别注意的是，<span class="text_import2">在使用 join 
		之前，你所需要处理的文件应该要事先经过排序 (sort) 处理</span>！
		否则有些比对的项目会被略过呢！特别注意了！<br><br></p>

		<a name="paste"></a>
		<hr><ul class="list1"><li class="text_import1">paste</li></ul>

		<p>这个 paste 就要比 join 简单多了！相对于 join 必须要比对两个文件的数据相关性，
		paste 就直接『<span class="text_import2">将两行贴在一起，且中间以 [tab] 键隔开</span>』而已！简单的使用方法：</p>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">paste [-d] file1 file2</span>
<span class="term_say">选项与参数：
-d  ：后面可以接分隔字符。默认是以 [tab] 来分隔的！
-   ：如果 file 部分写成 - ，表示来自 standard input 的数据的意思。</span>

<span class="term_hd">范例一：将 /etc/passwd 与 /etc/shadow 同一行贴在一起</span>
[root@www ~]# <span class="term_command">paste /etc/passwd /etc/shadow</span>
bin:x:1:1:bin:/bin:/sbin/nologin        bin:*:14126:0:99999:7:::
daemon:x:2:2:daemon:/sbin:/sbin/nologin daemon:*:14126:0:99999:7:::
adm:x:3:4:adm:/var/adm:/sbin/nologin    adm:*:14126:0:99999:7:::
<span class="term_say"># 注意喔！同一行中间是以 [tab] 按键隔开的！</span>

<span class="term_hd">范例二：先将 /etc/group 读出(用 cat)，然后与范例一贴上一起！且仅取出前三行</span>
[root@www ~]# <span class="term_command">cat /etc/group|paste /etc/passwd /etc/shadow -|head -n 3</span>
<span class="term_say"># 这个例子的重点在那个 - 的使用！那玩意儿常常代表 stdin 喔！</span>
</pre></td></tr></tbody></table><br>

		<a name="expand"></a>
		<hr><ul class="list1"><li class="text_import1">expand</li></ul>

		<p>这玩意儿就是在将 [tab] 按键转成空格键啦～可以这样玩：</p>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">expand [-t] file</span>
<span class="term_say">选项与参数：
-t  ：后面可以接数字。一般来说，一个 tab 按键可以用 8 个空格键取代。
      我们也可以自行定义一个 [tab] 按键代表多少个字符呢！</span>

<span class="term_hd">范例一：将 /etc/man.config 内行首为 MANPATH 的字样就取出；仅取前三行；</span>
[root@www ~]# <span class="term_command">grep '^MANPATH' /etc/man.config | head -n 3</span>
MANPATH /usr/man
MANPATH /usr/share/man
MANPATH /usr/local/man
<span class="term_say"># 行首的代表标志为 ^ ，这个我们留待下节介绍！先有概念即可！</span>

<span class="term_hd">范例二：承上，如果我想要将所有的符号都列出来？(用 cat)</span>
[root@www ~]# <span class="term_command">grep '^MANPATH' /etc/man.config | head -n 3 |cat -A</span>
MANPATH^I/usr/man$
MANPATH^I/usr/share/man$
MANPATH^I/usr/local/man$
<span class="term_say"># 发现差别了吗？没错～ [tab] 按键可以被 cat -A 显示成为 ^I </span>

<span class="term_hd">范例三：承上，我将 [tab] 按键配置成 6 个字符的话？</span>
[root@www ~]# <span class="term_command">grep '^MANPATH' /etc/man.config | head -n 3 | \</span>
&gt; <span class="term_command"> expand -t 6 - | cat -A</span>
MANPATH     /usr/man$
MANPATH     /usr/share/man$
MANPATH     /usr/local/man$
<span class="term_say">123456123456123456.....
# 仔细看一下上面的数字说明，因为我是以 6 个字符来代表一个 [tab] 的长度，所以，
# MAN... 到 /usr 之间会隔 12 (两个 [tab]) 个字符喔！如果 tab 改成 9 的话，
# 情况就又不同了！这里也不好理解～您可以多配置几个数字来查阅就晓得！</span>
</pre></td></tr></tbody></table>

		<p>expand 也是挺好玩的～他会自动将 [tab] 转成空格键～所以，以上面的例子来说，
		使用 cat -A 就会查不到 ^I 的字符啰～此外，因为 [tab] 最大的功能就是格式排列整齐！
		我们转成空格键后，这个空格键也会依据我们自己的定义来添加大小～
		所以，并不是一个 ^I 就会换成 8 个空白喔！这个地方要特别注意的哩！
		此外，您也可以参考一下 unexpand 这个将空白转成 [tab] 的命令功能啊！ ^_^</p>
	</div>

	<hr><a name="split"></a><img src="./鸟哥的 Linux 私房菜12 -- 学习 bash shell_files/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">分割命令： split</span><br>
	<div class="block2">
		<p>如果你有文件太大，导致一些携带式装置无法复制的问题，嘿嘿！找 split 就对了！
		他可以帮你将一个大文件，依据文件大小或行数来分割，就可以将大文件分割成为小文件了！
		快速又有效啊！真不错～</p>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">split [-bl] file PREFIX</span>
<span class="term_say">选项与参数：
-b  ：后面可接欲分割成的文件大小，可加单位，例如 b, k, m 等；
-l  ：以行数来进行分割。
PREFIX ：代表前导符的意思，可作为分割文件的前导文字。</span>

<span class="term_hd">范例一：我的 /etc/termcap 有七百多K，若想要分成 300K 一个文件时？</span>
[root@www ~]# <span class="term_command">cd /tmp; split -b 300k /etc/termcap termcap</span>
[root@www tmp]# <span class="term_command">ll -k termcap*</span>
-rw-r--r-- 1 root root 300 Feb  7 16:39 termcap<span class="term_write">aa</span>
-rw-r--r-- 1 root root 300 Feb  7 16:39 termcap<span class="term_write">ab</span>
-rw-r--r-- 1 root root 189 Feb  7 16:39 termcap<span class="term_write">ac</span>
<span class="term_say"># 那个档名可以随意取的啦！我们只要写上前导文字，小文件就会以
# xxxaa, xxxab, xxxac 等方式来创建小文件的！</span>

<span class="term_hd">范例二：如何将上面的三个小文件合成一个文件，档名为 termcapback</span>
[root@www tmp]# <span class="term_command">cat termcap* &gt;&gt; termcapback</span>
<span class="term_say"># 很简单吧？就用数据流重导向就好啦！简单！</span>

<span class="term_hd">范例三：使用 ls -al / 输出的信息中，每十行记录成一个文件</span>
[root@www tmp]# <span class="term_command">ls -al / | split -l 10 - lsroot</span>
[root@www tmp]# <span class="term_command">wc -l lsroot*</span>
  10 lsrootaa
  10 lsrootab
   6 lsrootac
  26 total
<span class="term_say"># 重点在那个 - 啦！一般来说，如果需要 stdout/stdin 时，但偏偏又没有文件，
# 有的只是 - 时，那么那个 - 就会被当成 stdin 或 stdout ～</span>
</pre></td></tr></tbody></table>

		<p>在 Windows 操作系统下，你要将文件分割需要如何作？伤脑筋吧！在 Linux 
		底下就简单的多了！你要将文件分割的话，那么就使用 -b size 
		来将一个分割的文件限制其大小，如果是行数的话，那么就使用
		-l line 来分割！好用的很！如此一来，你就可以轻易的将你的文件分割成软盘 (floppy)
		的大小，方便你 copy 啰！</p>
	</div>

	<hr><a name="xargs"></a><img src="./鸟哥的 Linux 私房菜12 -- 学习 bash shell_files/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">参数代换： xargs</span><br>
	<div class="block2">
		<p>xargs 是在做什么的呢？就以字面上的意义来看， x 是加减乘除的乘号，args 则是 arguments (参数)
		的意思，所以说，<span class="text_import2">这个玩意儿就是在产生某个命令的参数的意思！</span>
		xargs 可以读入 stdin 的数据，并且以空格符或断行字符作为分辨，将 stdin 的数据分隔成为 arguments 。
		因为是以空格符作为分隔，所以，如果有一些档名或者是其他意义的名词内含有空格符的时候，
		xargs 可能就会误判了～他的用法其实也还满简单的！就来看一看先！</p>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">xargs [-0epn] command</span>
<span class="term_say">选项与参数：
-0  ：如果输入的 stdin 含有特殊字符，例如 `, \, 空格键等等字符时，这个 -0 参数
      可以将他还原成一般字符。这个参数可以用于特殊状态喔！
-e  ：这个是 EOF (end of file) 的意思。后面可以接一个字符串，当 xargs 分析到
      这个字符串时，就会停止继续工作！
-p  ：在运行每个命令的 argument 时，都会询问使用者的意思；
-n  ：后面接次数，每次 command 命令运行时，要使用几个参数的意思。看范例三。
当 xargs 后面没有接任何的命令时，默认是以 echo 来进行输出喔！</span>

<span class="term_hd">范例一：将 /etc/passwd 内的第一栏取出，仅取三行，使用 finger 这个命令将每个
        账号内容秀出来</span>
[root@www ~]# <span class="term_command">cut -d':' -f1 /etc/passwd |head -n 3| xargs finger</span>
Login: root                             Name: root
Directory: /root                        Shell: /bin/bash
Never logged in.
No mail.
No Plan.
<span class="term_say">......底下省略.....
# 由 finger account 可以取得该账号的相关说明内容，例如上面的输出就是 finger root
# 后的结果。在这个例子当中，我们利用 cut 取出账号名称，用 head 取出三个账号，
# 最后则是由 xargs 将三个账号的名称变成 finger 后面需要的参数！</span>

<span class="term_hd">范例二：同上，但是每次运行 finger 时，都要询问使用者是否动作？</span>
[root@www ~]# <span class="term_command">cut -d':' -f1 /etc/passwd |head -n 3| xargs -p finger</span>
finger root bin daemon ?...<span class="term_command">y</span>
<span class="term_say">.....(底下省略)....
# 呵呵！这个 -p 的选项可以让用户的使用过程中，被询问到每个命令是否运行！</span>

<span class="term_hd">范例三：将所有的 /etc/passwd 内的账号都以 finger 查阅，但一次仅查阅五个账号</span>
[root@www ~]# <span class="term_command">cut -d':' -f1 /etc/passwd | xargs -p -n 5 finger</span>
finger root bin daemon adm lp ?...<span class="term_command">y</span>
<span class="term_say">.....(中间省略)....</span>
finger uucp operator games gopher ftp ?...<span class="term_command">y</span>
<span class="term_say">.....(底下省略)....
# 在这里鸟哥使用了 -p 这个参数来让您对于 -n 更有概念。一般来说，某些命令后面
# 可以接的 arguments 是有限制的，不能无限制的累加，此时，我们可以利用 -n
# 来帮助我们将参数分成数个部分，每个部分分别再以命令来运行！这样就 OK 啦！^_^</span>

<span class="term_hd">范例四：同上，但是当分析到 lp 就结束这串命令？</span>
[root@www ~]# <span class="term_command">cut -d':' -f1 /etc/passwd | xargs -p -e'lp' finger</span>
finger root bin daemon adm ?...
<span class="term_say"># 仔细与上面的案例做比较。也同时注意，那个 -e'lp' 是连在一起的，中间没有空格键。
# 上个例子当中，第五个参数是 lp 啊，那么我们下达 -e'lp' 后，则分析到 lp
# 这个字符串时，后面的其他 stdin 的内容就会被 xargs 舍弃掉了！</span>
</pre></td></tr></tbody></table>

		<p>其实，在 man xargs 里面就有三四个小范例，您可以自行参考一下内容。
		此外， xargs 真的是很好用的一个玩意儿！您真的需要好好的参详参详！会使用 xargs 的原因是，
		<span class="text_import2">很多命令其实并不支持管线命令，因此我们可以透过 xargs 来提供该命令引用 standard 
		input 之用</span>！举例来说，我们使用如下的范例来说明：</p>

<table class="term"><tbody><tr><td class="term"><pre><span class="term_hd">范例五：找出 /sbin 底下具有特殊权限的档名，并使用 ls -l 列出详细属性</span>
[root@www ~]# <span class="term_command">find /sbin -perm +7000 | ls -l</span>
<span class="term_say"># 结果竟然仅有列出 root 所在目录下的文件！这不是我们要的！
# 因为 ll (ls) 并不是管线命令的原因啊！</span>

[root@www ~]# <span class="term_command">find /sbin -perm +7000 | xargs ls -l</span>
-rwsr-xr-x 1 root root 70420 May 25  2008 /sbin/mount.nfs
-rwsr-xr-x 1 root root 70424 May 25  2008 /sbin/mount.nfs4
-rwxr-sr-x 1 root root  5920 Jun 15  2008 /sbin/netreport
<span class="term_say">....(底下省略)....</span>
</pre></td></tr></tbody></table>
	</div>

	<hr><a name="pipe_7"></a><img src="./鸟哥的 Linux 私房菜12 -- 学习 bash shell_files/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">关于减号 - 的用途</span><br>
	<div class="block2">
		<p>管线命令在 bash 的连续的处理程序中是相当重要的！另外，在 log file 的分析当中也是相当重要的一环，
		所以请特别留意！另外，在管线命令当中，常常会使用到前一个命令的 stdout 作为这次的 stdin ，
		某些命令需要用到文件名 (例如 tar) 来进行处理时，该 stdin 与 stdout 可以利用减号 "-" 来替代，
		举例来说：</p>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">tar -cvf - /home | tar -xvf -</span>
</pre></td></tr></tbody></table>

		<p>上面这个例子是说：『我将 /home 里面的文件给他打包，但打包的数据不是纪录到文件，而是传送到 stdout；
		经过管线后，将 tar -cvf - /home 传送给后面的 tar -xvf - 』。后面的这个 - 则是取用前一个命令的 stdout，
		因此，我们就不需要使用 file 了！这是很常见的例子喔！注意注意！</p>
	</div>
</div>

<hr><a name="hint"></a><img src="./鸟哥的 Linux 私房菜12 -- 学习 bash shell_files/logo.png" alt="大标题的图示" width="35" align="middle" height="34"><span class="text_h1">重点回顾</span><br>
<div class="block1">
<ul class="text_import2">
	<li>由于核心在内存中是受保护的区块，因此我们必须要透过『 Shell 』将我们输入的命令与 Kernel 沟通，好让 
		Kernel 可以控制硬件来正确无误的工作</li>
	<li>学习 shell 的原因主要有：文字接口的 shell 在各大 distribution 都一样；远程管理时文字接口速度较快；
		shell 是管理 Linux 系统非常重要的一环，因为 Linux 内很多控制都是以 shell 撰写的。</li>
	<li>系统合法的 shell 均写在 /etc/shells 文件中；</li>
	<li>用户默认登陆取得的 shell 记录于 /etc/passwd 的最后一个字段；</li>
	<li>bash 的功能主要有：命令编修能力；命令与文件补全功能；命令别名配置功能；工作控制、前景背景控制；程序化脚本；通配符</li>
	<li>type 可以用来找到运行命令为何种类型，亦可用于与 which 相同的功能；</li>
	<li>变量就是以一组文字或符号等，来取代一些配置或者是一串保留的数据</li>
	<li>变量主要有环境变量与自定义变量，或称为全局变量与局部变量</li>
	<li>使用 env 与 export 可观察环境变量，其中 export 可以将自定义变量转成环境变量；</li>
	<li>set 可以观察目前 bash 环境下的所有变量；</li>
	<li>$? 亦为变量，是前一个命令运行完毕后的回传值。在 Linux 回传值为 0 代表运行成功；</li>
	<li>locale 可用于观察语系数据；</li>
	<li>可用 read 让用户由键盘输入变量的值</li>
	<li>ulimit 可用以限制用户使用系统的资源情况</li>
	<li>bash 的配置文件主要分为 login shell 与 non-login shell。login shell 主要读取 /etc/profile 与 ~/.bash_profile，
		non-login shell 则仅读取 ~/.bashrc</li>
	<li>通配符主要有： *, ?, [] 等等</li>
	<li>数据流重导向透过 &gt;, 2&gt;, &lt; 之类的符号将输出的信息转到其他文件或装置去；</li>
	<li>连续命令的下达可透过 ; &amp;&amp; || 等符号来处理</li>
	<li>管线命令的重点是：『管线命令仅会处理 standard output，对于 standard error output 会予以忽略』
		『管线命令必须要能够接受来自前一个命令的数据成为 standard input 继续处理才行。』</li>
	<li>本章介绍的管线命令主要有：cut, grep, sort, wc, uniq, tee, tr, col, join, paste, expand, split, xargs 等。</li>
</ul>
</div>


<hr><a name="ex"></a><img src="./鸟哥的 Linux 私房菜12 -- 学习 bash shell_files/logo.png" alt="大标题的图示" width="35" align="middle" height="34"><span class="text_h1">本章习题</span><br>
( 要看答案请将鼠标移动到『答：』底下的空白处，按下左键圈选空白处即可察看 )
<div class="block1">
<ul>
	<li>情境模拟题一：由于 ~/.bash_history 仅能记录命令，我想要在每次注销时都记录时间，并将后续的命令 50 笔记录下来，
	可以如何处理？<br><br>
	<ul>
	<li>目标：了解 history ，并透过数据流重导向的方式记录历史命令；</li>
	<li>前提：需要了解本章的数据流重导向，以及了解 bash 的各个环境配置文件信息。</li>
	</ul><br>
	其实处理的方式非常简单，我们可以了解 date 可以输出时间，而利用 ~/.myhistory 来记录所有历史记录，
	而目前最新的 50 笔历史记录可以使用 history 50 来显示，故可以修改 ~/.bash_logout 成为底下的模样：<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">vim ~/.bash_logout</span>
<span class="term_write">date &gt;&gt; ~/.myhistory
history 50 &gt; &gt; ~/.myhistory</span>
clear
</pre></td></tr></tbody></table><br></li>


</ul>

<hr>简答题部分：
<ul>
	<li>在 Linux 上可以找到哪些 shell(举出三个) ？那个文件记录可用的 shell ？而 Linux 默认的 shell 是？
	<div class="blockex">
		1) /bin/bash, /bin/tcsh, /bin/csh<br>
	 	2) /etc/shells<br>
		3) bash ，亦即是 /bin/bash。
	</div></li>

	<li>在 shell 环境下，有个提示字符  (prompt)，他可以修改吗？要改什么？默认的提示字符内容是？
	<div class="blockex">
		可以修改的，改 PS1 这个变量，这个 PS1 变量的默认内容为：『[\u@\h \W]\$』
	</div></li>

	<li>如何显示 HOME 这个环境变量？
	<div class="blockex">
		echo $HOME
	</div></li>

	<li>如何得知目前的所有变量与环境变量的配置值？
	<div class="blockex">
		环境变量用 env 或 export 而所有变量用 set 即可显示
	</div></li>

	<li>我是否可以配置一个变量名称为 3myhome ？
	<div class="blockex">
		不行！变量不能以数字做为开头，参考变量配置守则的内容
	</div></li>

	<li>在这样的练习中『A=B』且『B=C』，若我下达『unset $A』，则取消的变量是 A 还是 B？
	<div class="blockex">
		被取消的是 B 喔，因为 unset $A 相当于 unset B 所以取消的是 B ，A 会继续存在！
	</div></li>

	<li>如何取消变量与命令别名的内容？
	<div class="blockex">
		使用 unset 及 unalias 即可
	</div></li>

	<li>如何配置一个变量名称为 name 内容为 It's my name ？
	<div class="blockex">
		name=It\'s\ my\ name 或 name="It's my name"
	</div></li>

	<li>bash 环境配置文件主要分为哪两种类型的读取？分别读取哪些重要文件？
	<div class="blockex">
		(1)login shell：主要读取 /etc/profile 及 ~/.bash_profile<br>
		(2)non-logni shell：主要读取 ~/.bashrc 而已。
	</div></li>

	<li>CentOS 5.x 的 man page 的路径配置文件案？
	<div class="blockex">
		/etc/man.config
	</div></li>

	<li>试说明 ', ", 与 ` 这些符号在变量定义中的用途？
	<div class="blockex">
		参考变量守则那一章节，其中， " 可以具有变量的上下文属性，' 则仅有一般字符，至于 ` 之内则是可先被运行的命令。
	</div></li>

	<li>跳脱符号 \ 有什么用途？
	<div class="blockex">
		可以用来跳脱特殊字符，例如 Enter, $ 等等，使成为一般字符！
	</div></li>

	<li>连续命令中， ;, &amp;&amp;, || 有何不同？
	<div class="blockex">
		分号可以让两个 command 连续运行，不考虑 command1
		的输出状态， &amp;&amp; 则前一个命令必需要没有错误信息，亦即回传值需为
		0 则 command2 才会被运行， || 则与 &amp;&amp; 相反！
	</div></li>

	<li>如何将 last 的结果中，独立出账号，并且印出曾经登陆过的账号？
	<div class="blockex">
		&nbsp;last | cut -d ' ' -f1 | sort | uniq
	</div></li>

	<li>请问 foo1 &amp;&amp; foo2 | foo3 &gt; foo4 ，这个命令串当中， foo1/foo2/foo3/foo4 是命令还是文件？
	整串命令的意义为？
	<div class="blockex">
		foo1, foo2 与 foo3 都是命令， foo4 是装置或文件。整串命令意义为：<br>
		(1)当 foo1 运行结果有错误时，则该命令串结束；<br>
		(2)若 foo1 运行结果没有错误时，则运行 foo2 | foo3 &gt; foo4 ；其中：<br>
			(2-1)foo2 将 stdout 输出的结果传给 foo3 处理；<br>
			(2-2)foo3 将来自 foo2 的 stdout 当成 stdin ，处理完后将数据流重新导向 foo4 这个装置/文件
	</div></li>

	<li>如何秀出在 /bin 底下任何以 a 为开头的文件文件名的详细数据？
	<div class="blockex">
		ls -l /bin/a*
	</div></li>

	<li>如何秀出 /bin 底下，文件名为四个字符的文件？
	<div class="blockex">
		ls -l /bin/????
	</div></li>

	<li>如何秀出 /bin 底下，档名开头不是 a-d 的文件？
	<div class="blockex">
		ls -l /bin/[^a-d]*
	</div></li>


	<li>我想要让终端机接口的登陆提示字符修改成我自己喜好的模样，应该要改哪里？(filename)
	<div class="blockex">
		/etc/issue
	</div></li>

	<li>承上题，如果我是想要让使用者登陆后，才显示欢迎信息，又应该要改哪里？
	<div class="blockex">
		/etc/motd
	</div></li>
</ul>
</div>


<hr><a name="reference"></a><img src="./鸟哥的 Linux 私房菜12 -- 学习 bash shell_files/logo.png" alt="大标题的图示" width="35" align="middle" height="34"><span class="text_h1">参考数据与延伸阅读</span><br>
<div class="block1">
<ul>
	<li><a name="ps1"></a>注1：Webmin 的官方网站：<a href="http://www.webmin.com/" target="_blank">http://www.webmin.com/</a></li>
	<li><a name="ps2"></a>注2：关于 shell 的相关历史可以参考网络农夫兄所整理的优秀文章。不过由于网络农夫兄所建置的网站暂时关闭，
		因此底下的链接为鸟哥到网络上找到的片段文章连结。若有任何侵权事宜，请来信告知，谢谢：<br>
		<a href="http://linux.vbird.org/linux_basic/0320bash/csh/" target="_blank">http://linux.vbird.org/linux_basic/0320bash/csh/</a></li>
	<li><a name="ps3"></a>注3：使用 man bash，再以 PS1 为关键词去查询，按下数次 n 往后查询后，可以得到 PS1 的变量说明。</li>
	<li><a name="ps4"></a>注4：i18n 是由一些 Linux distribution 贡献者共同发起的大型计划，目的在于让众多的 Linux
		distributions 能够有良好的万国码 (Unicode) 语系的支持。详细的数据可以参考：<br>
		i18n 的官方网站：<a href="http://www.openi18n.org/" target="_blank">http://www.openi18n.org/</a><br>
		康桥大学 Dr Markus Kuhn 的文献：<a href="http://www.cl.cam.ac.uk/~mgk25/unicode.html" target="_blank">http://www.cl.cam.ac.uk/~mgk25/unicode.html</a><br>
		Debian 社群所写的文件：<a href="http://www.debian.org/doc/manuals/intro-i18n/" target="_blank">http://www.debian.org/doc/manuals/intro-i18n/</a></li>
	<li>卧龙小三的教学文件：<a href="http://linux.tnc.edu.tw/techdoc/shell/book1.html" target="_blank">http://linux.tnc.edu.tw/techdoc/shell/book1.html</a></li>
	<li>GNU 计划的 BASH 说明：<a href="http://www.gnu.org/manual/bash-2.05a/html_mono/bashref.html" target="_blank">http://www.gnu.org/manual/bash-2.05a/html_mono/bashref.html</a><br>
		鸟哥的备份：<a href="http://linux.vbird.org/linux_basic/0320bash/0320bash_reference.php">http://linux.vbird.org/linux_basic/0320bash/0320bash_reference.php</a></li>
	<li>man bash</li>


</ul>
</div>


<hr><span class="text_history">
2002/06/27：第一次完成<br>
2003/02/10：重新编排与加入 FAQ<br>
2005/08/17：将旧的数据放置到 <a href="http://linux.vbird.org/linux_basic/0320bash/0320bash.php">这里</a><br>
2005/08/17：终于稍微搞定了～花了半个多月不眠不休～呼～补充了较多的管线命令与数据流重导向！<br>
2005/08/18：加入<a href="http://cn.linux.vbird.org/linux_basic/0320bash.php#variable_other">额外的变量配置</a>部分！<br>
2005/08/30：加入了 login 与 non-login shell 的简单说明！<br>
2006/03/19：原先在 col 的说明当中，原本命令『cat -A /etc/man.config | col -x | cat -A | more』不该有 -A！<br>
2006/10/05：感谢小州兄的告知，修正了原本 ~/.bashrc 说明当中的错误。<br>
2007/04/05：原本的 cut 范例说明有误，原本是『我要找出第三个』应该改为『<a href="http://cn.linux.vbird.org/linux_basic/0320bash.php#20070405">我要找出第五个</a>』才对！<br>
2007/04/11：原本的 join 说明没有加上排序，应该需要<a href="http://cn.linux.vbird.org/linux_basic/0320bash.php#20070411">排序后再处理</a>才对！<br>
2007/07/15：原本的额外的变量菜单格有误，在 var=${str+expr} 与var=${str:+expr} 需要修改，请参考 <a href="http://cn.linux.vbird.org/linux_basic/0320bash.php#20070715">此处</a><br>
2009/01/13：将原本基于 FC4 写作的旧文章移动到<a href="http://linux.vbird.org/linux_basic/0320bash/0320bash-fc4.php">此处</a><br>
2009/02/03：拿掉了原本的『变量的用途』部分，改以案例说明<br>
2009/02/05：多加了变量删除、取代与替代部分的范例，看起来应该不会像前一版那样不容易理解！<br>
2009/08/25：加入了情境模拟，并且进行一些说明的细部修改而已。<br>
2010/04/16：感谢<a href="http://phorum.vbird.org/viewtopic.php?f=10&amp;t=33829">wenyenyang</a>兄的告知， wc -c 错误，是 
	<a href="http://cn.linux.vbird.org/linux_basic/0320bash.php#20100416">wc -m</a> 才是！<hr>
</span>
    </td>
    <td style="width: 16px; font-size: 6px;">　</td></tr>
<tr><td style="width: 16px; height: 16px;">　</td>
    <td style="width: 866px; height: 16px;">　</td>
    <td style="width: 16px; height: 16px;">　</td></tr>
</tbody></table>

<div style="padding-top: 0px; text-align: center;">
<span style="font-size: 80%;">
	<a href="http://linux.vbird.org/" target="_top" title="前往鸟哥的首页">http://linux.vbird.org</a>
	is designed by <a href="mailto:vbird@mail.vbird.idv.tw" title="联络鸟哥(我不要广告信！)">VBird</a>
		during 2001-2011. <a href="http://www.ksu.edu.tw/" target="_blank">ksu.edu</a></span>
         ﻿<div id="apDiv4">
      <p>本网页主要以Firefox配合解析度 1024x768 作为设计依据&nbsp;&nbsp;&nbsp;&nbsp; 鸟哥自由软件整合应用研究室</p></div></div>
</div>
</center>

</body></html>