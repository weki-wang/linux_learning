
<!-- saved from url=(0060)http://cn.linux.vbird.org/linux_basic/0440processcontrol.php -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
	
	<meta name="Author" content="2011/04/20,lee">
	<meta name="Description" content="程序管理与 SELinux 初探">
	<title>鸟哥的 Linux 私房菜 -- 程序管理与 SELinux 初探</title>
    <script src="./鸟哥的 Linux 私房菜18 -- 程序管理与 SELinux 初探_files/SpryMenuBar.js" type="text/javascript"></script>
	<script src="./鸟哥的 Linux 私房菜18 -- 程序管理与 SELinux 初探_files/index.js" type="text/javascript"></script>
	<link href="./鸟哥的 Linux 私房菜18 -- 程序管理与 SELinux 初探_files/SpryMenuBarHorizontal.css" rel="stylesheet" type="text/css">
    <link href="./鸟哥的 Linux 私房菜18 -- 程序管理与 SELinux 初探_files/main.css" rel="stylesheet" type="text/css">
    </head><body style="margin: 0pt; padding: 0pt;" class="table" onload="MM_preloadImages(&#39;image/title_19.png&#39;,&#39;image/title_26.png&#39;,&#39;image/title_27.png&#39;,&#39;image/title_28.png&#39;,&#39;image/title_06.png&#39;,&#39;image/title_08.png&#39;,&#39;image/title_10.png&#39;,&#39;image/title_12.png&#39;)">

<center>
<div id="apDiv5">
<div> <link rel="SHORTCUT ICON" href="http://cn.linux.vbird.org/linux_basic/favicon.ico">
<!-- ImageReady Slices (title3.ai) -->
<table id="___01" width="898" height="81" border="0" align="center" cellpadding="0" cellspacing="0" ;="">
	<tbody><tr>
		<td colspan="15">
			<img src="./鸟哥的 Linux 私房菜18 -- 程序管理与 SELinux 初探_files/title_01.png" width="900" height="1" alt=""></td>
	</tr>
	<tr>
		<td rowspan="4" bgcolor="#182448"><p><img src="./鸟哥的 Linux 私房菜18 -- 程序管理与 SELinux 初探_files/Count.cgi" width="93" align="left" title="計數器"></p>
	    <p><font color="#FFFFFF" size="-1">since2012/04/23</font></p></td>
		<td rowspan="4" align="left" valign="top"><a href="http://cn.linux.vbird.org/"><img src="./鸟哥的 Linux 私房菜18 -- 程序管理与 SELinux 初探_files/title_03.png" alt="" width="263" height="79" border="0"></a></td>
		<td colspan="13">
			<img src="./鸟哥的 Linux 私房菜18 -- 程序管理与 SELinux 初探_files/title_04.png" alt="" width="535" height="9" border="0"></td>
	</tr>
	<tr>
		<td rowspan="3">
			<img src="./鸟哥的 Linux 私房菜18 -- 程序管理与 SELinux 初探_files/title_05.png" alt="" width="53" height="70" border="0"></td>
		<td colspan="2" align="left" valign="top"><a href="http://cn.linux.vbird.org/linux_basic/0110whatislinux.php" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage(&#39;Image51&#39;,&#39;&#39;,&#39;image/title/title_06.png&#39;,1)"><img src="./鸟哥的 Linux 私房菜18 -- 程序管理与 SELinux 初探_files/title3_06.png" name="Image51" width="106" height="25" border="0" id="Image51" alt=""></a></td>
		<td rowspan="2">
			<img src="./鸟哥的 Linux 私房菜18 -- 程序管理与 SELinux 初探_files/title_07.png" alt="" width="27" height="37" border="0"></td>
		<td colspan="3" align="left" valign="top"><a href="http://cn.linux.vbird.org/linux_server/0110network_basic.php" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage(&#39;Image52&#39;,&#39;&#39;,&#39;image/title/title_08.png&#39;,1)"><img src="./鸟哥的 Linux 私房菜18 -- 程序管理与 SELinux 初探_files/title3_08.png" name="Image52" width="107" height="25" border="0" id="Image52" alt=""></a></td>
		<td rowspan="2">
			<img src="./鸟哥的 Linux 私房菜18 -- 程序管理与 SELinux 初探_files/title_09.png" alt="" width="37" height="37" border="0"></td>
		<td colspan="2" align="left" valign="top"><a href="http://cn.linux.vbird.org/about.php" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage(&#39;Image53&#39;,&#39;&#39;,&#39;image/title/title_10.png&#39;,1)"><img src="./鸟哥的 Linux 私房菜18 -- 程序管理与 SELinux 初探_files/title3_10.png" name="Image53" width="75" height="25" border="0" id="Image53" alt=""></a></td>
		<td rowspan="3">
			<img src="./鸟哥的 Linux 私房菜18 -- 程序管理与 SELinux 初探_files/title_11.png" alt="" width="35" height="70" border="0"></td>
		<td align="left" valign="top"><a href="mailto:vbird@mail.vbird.idv.tw" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage(&#39;Image54&#39;,&#39;&#39;,&#39;image/title/title_12.png&#39;,1)"><img src="./鸟哥的 Linux 私房菜18 -- 程序管理与 SELinux 初探_files/title3_12.png" name="Image54" width="74" height="25" border="0" id="Image54" alt=""></a></td>
		<td rowspan="3">
			<img src="./鸟哥的 Linux 私房菜18 -- 程序管理与 SELinux 初探_files/title_13.png" alt="" width="21" height="70" border="0"></td>
	</tr>
	<tr>
		<td colspan="2">
			<img src="./鸟哥的 Linux 私房菜18 -- 程序管理与 SELinux 初探_files/title_14.png" alt="" width="106" height="12" border="0"></td>
		<td colspan="3">
			<img src="./鸟哥的 Linux 私房菜18 -- 程序管理与 SELinux 初探_files/title_15.png" alt="" width="107" height="12" border="0"></td>
		<td colspan="2">
			<img src="./鸟哥的 Linux 私房菜18 -- 程序管理与 SELinux 初探_files/title_16.png" width="75" height="12" alt=""></td>
		<td rowspan="2">
			<img src="./鸟哥的 Linux 私房菜18 -- 程序管理与 SELinux 初探_files/title_17.png" alt="" width="74" height="45" border="0"></td>
	</tr>
	<tr>
		<td>
			<img src="./鸟哥的 Linux 私房菜18 -- 程序管理与 SELinux 初探_files/title_18.png" alt="" width="15" height="33" border="0"></td>
		<td colspan="3" align="left" valign="top"><ul id="MenuBar1" class="MenuBarHorizontal">
	  <li><a href="http://cn.linux.vbird.org/linux_basic/linux_basic.php" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage(&#39;Image44&#39;,&#39;&#39;,&#39;image/title/title_19.png&#39;,1)" class="MenuBarItemSubmenu"><img src="./鸟哥的 Linux 私房菜18 -- 程序管理与 SELinux 初探_files/title3_19.png" name="Image44" width="123" height="33" border="0" id="Image44"></a>
			    <ul>
			      <li><a href="http://cn.linux.vbird.org/linux_basic/Mandrake9.0/mandrake9.0.php" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage(&#39;Image46&#39;,&#39;&#39;,&#39;image/title/title_26.png&#39;,1)"><img src="./鸟哥的 Linux 私房菜18 -- 程序管理与 SELinux 初探_files/title_23.png" name="Image46" width="120" height="26" border="0" id="Image46" alt=""></a></li>
                  <li><a href="http://cn.linux.vbird.org/linux_basic/fedora_4/fc4.php" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage(&#39;Image47&#39;,&#39;&#39;,&#39;image/title/title_27.png&#39;,1)"><img src="./鸟哥的 Linux 私房菜18 -- 程序管理与 SELinux 初探_files/title_24.png" name="Image47" width="120" height="26" border="0" id="Image47" alt=""></a></li>
                  <li><a href="http://cn.linux.vbird.org/linux_basic/linux_basic.php" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage(&#39;Image48&#39;,&#39;&#39;,&#39;image/title/title_28.png&#39;,1)"><img src="./鸟哥的 Linux 私房菜18 -- 程序管理与 SELinux 初探_files/title_25.png" name="Image48" width="120" height="26" border="0" id="Image48" alt=""></a></li>
                </ul>
		      </li>
		</ul></td>
		<td>
			<img src="./鸟哥的 Linux 私房菜18 -- 程序管理与 SELinux 初探_files/title_20.png" alt="" width="42" height="33" border="0"></td>
		<td colspan="3" align="left" valign="top"><ul id="MenuBar2" class="MenuBarHorizontal">
	  <li><a href="http://cn.linux.vbird.org/linux_server/" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage(&#39;Image45&#39;,&#39;&#39;,&#39;image/title/title_21.png&#39;,1)" class="MenuBarItemSubmenu"><img src="./鸟哥的 Linux 私房菜18 -- 程序管理与 SELinux 初探_files/title3_21.png" name="Image45" width="125" height="33" border="0" id="Image45"></a>
			    <ul>
			      <li><a href="http://cn.linux.vbird.org/linux_server/linux_redhat9/redhat9.php" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage(&#39;Image43&#39;,&#39;&#39;,&#39;image/title/title_26.png&#39;,1)"><img src="./鸟哥的 Linux 私房菜18 -- 程序管理与 SELinux 初探_files/title_23.png" name="Image43" width="120" height="26" border="0" id="Image43" alt=""></a></li>
			      <li><a href="http://cn.linux.vbird.org/linux_server/centos4.php" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage(&#39;Image49&#39;,&#39;&#39;,&#39;image/title/title_27.png&#39;,1)"><img src="./鸟哥的 Linux 私房菜18 -- 程序管理与 SELinux 初探_files/title_24.png" name="Image49" width="120" height="26" border="0" id="Image49" alt=""></a></li>
			      <li><a href="http://cn.linux.vbird.org/linux_server/" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage(&#39;Image50&#39;,&#39;&#39;,&#39;image/title/title_28.png&#39;,1)"><img src="./鸟哥的 Linux 私房菜18 -- 程序管理与 SELinux 初探_files/title_25.png" name="Image50" width="120" height="26" border="0" id="Image50" alt=""></a></li>
		        </ul>
		      </li>
		</ul></td>
		<td>
			<img src="./鸟哥的 Linux 私房菜18 -- 程序管理与 SELinux 初探_files/title_22.png" alt="" width="47" height="33" border="0"></td>
	</tr>
	<tr>
		<td>
			<img src="./鸟哥的 Linux 私房菜18 -- 程序管理与 SELinux 初探_files/Spacer.gif" width="101" height="1" alt=""></td>
		<td>
			<img src="./鸟哥的 Linux 私房菜18 -- 程序管理与 SELinux 初探_files/Spacer.gif" width="263" height="1" alt=""></td>
		<td>
			<img src="./鸟哥的 Linux 私房菜18 -- 程序管理与 SELinux 初探_files/Spacer.gif" width="53" height="1" alt=""></td>
		<td>
			<img src="./鸟哥的 Linux 私房菜18 -- 程序管理与 SELinux 初探_files/Spacer.gif" width="15" height="1" alt=""></td>
		<td>
			<img src="./鸟哥的 Linux 私房菜18 -- 程序管理与 SELinux 初探_files/Spacer.gif" width="91" height="1" alt=""></td>
		<td>
			<img src="./鸟哥的 Linux 私房菜18 -- 程序管理与 SELinux 初探_files/Spacer.gif" width="27" height="1" alt=""></td>
		<td>
			<img src="./鸟哥的 Linux 私房菜18 -- 程序管理与 SELinux 初探_files/Spacer.gif" width="5" height="1" alt=""></td>
		<td>
			<img src="./鸟哥的 Linux 私房菜18 -- 程序管理与 SELinux 初探_files/Spacer.gif" width="42" height="1" alt=""></td>
		<td>
			<img src="./鸟哥的 Linux 私房菜18 -- 程序管理与 SELinux 初探_files/Spacer.gif" width="60" height="1" alt=""></td>
		<td>
			<img src="./鸟哥的 Linux 私房菜18 -- 程序管理与 SELinux 初探_files/Spacer.gif" width="37" height="1" alt=""></td>
		<td>
			<img src="./鸟哥的 Linux 私房菜18 -- 程序管理与 SELinux 初探_files/Spacer.gif" width="28" height="1" alt=""></td>
		<td>
			<img src="./鸟哥的 Linux 私房菜18 -- 程序管理与 SELinux 初探_files/Spacer.gif" width="47" height="1" alt=""></td>
		<td>
			<img src="./鸟哥的 Linux 私房菜18 -- 程序管理与 SELinux 初探_files/Spacer.gif" width="35" height="1" alt=""></td>
		<td>
			<img src="./鸟哥的 Linux 私房菜18 -- 程序管理与 SELinux 初探_files/Spacer.gif" width="74" height="1" alt=""></td>
		<td>
			<img src="./鸟哥的 Linux 私房菜18 -- 程序管理与 SELinux 初探_files/Spacer.gif" width="22" height="1" alt=""></td>
	</tr>
</tbody></table>
<!-- End ImageReady Slices -->
<script type="text/javascript">
<!--
var MenuBar1 = new Spry.Widget.MenuBar("MenuBar1", {imgDown:"SpryAssets/SpryMenuBarDownHover.gif", imgRight:"SpryAssets/SpryMenuBarRightHover.gif"});
var MenuBar2 = new Spry.Widget.MenuBar("MenuBar2", {imgDown:"SpryAssets/SpryMenuBarDownHover.gif", imgRight:"SpryAssets/SpryMenuBarRightHover.gif"});
//-->
</script>
</div>
<table summary="本文内容的排版" style="width: 898px;" border="0" cellpadding="0" cellspacing="0">
<tbody><tr><td style="width: 16px; height: 16px;">　</td>
    <td style="width: 866px; height: 16px;">　</td>
    <td style="width: 16px; height: 16px;">　</td></tr>
<tr><td style="width: 16px; font-size: 6px;">　</td>
    <td width="866">

<!-- 本文的档头部分 -->
<div style="text-align: center;">
    <a href="http://cn.linux.vbird.org/linux_basic/0440processcontrol.php">
    <span class="text_head0">第十七章、程序管理与<span class="text_head_en"> SELinux </span>初探</span></a><br>
</div>
    <div style="text-align: right;">
        <span class="text_history">最近升级日期：2009/09/11</span>
    </div>

<!-- 本文的档头部分 -->
<center><table class="head1" summary="排版：文章档头的说明"><tbody><tr><td class="head1">
	一个程序被加载到内存当中运行，那么在内存内的那个数据就被称为程序(process)。程序是操作系统上非常重要的概念，
	所有系统上面跑的数据都会以程序的型态存在。那么系统的程序有哪些状态？不同的状态会如何影响系统的运行？
	程序之间是否可以互相控管等等的，这些都是我们所必须要知道的项目。
	另外与程序有关的还有 SELinux 这个加强文件存取安全性的咚咚，也必须要做个了解呢！
</td></tr></tbody></table></center><br>

<!-- 本文的连结区部分 -->
<div class="block1">
<span class="text_h1">
1. <a href="http://cn.linux.vbird.org/linux_basic/0440processcontrol.php#whatis">什么是程序 (Process)</a><br>
	<span class="text_h2">
	　　1.1 <a href="http://cn.linux.vbird.org/linux_basic/0440processcontrol.php#whatis_program_process">程序与程序 (process &amp; program)</a>： 
		<a href="http://cn.linux.vbird.org/linux_basic/0440processcontrol.php#parent_pid">子程序与父程序</a>, <a href="http://cn.linux.vbird.org/linux_basic/0440processcontrol.php#fork_and_exec">fork-and-exec</a>,
		<a href="http://cn.linux.vbird.org/linux_basic/0440processcontrol.php#the_daemon">系统服务</a><br>
	　　1.2 <a href="http://cn.linux.vbird.org/linux_basic/0440processcontrol.php#whatis_milti_task">Linux 的多人多工环境</a><br>
	</span>
2. <a href="http://cn.linux.vbird.org/linux_basic/0440processcontrol.php#background">工作管理 (job control)</a><br>
	<span class="text_h2">
	　　2.1 <a href="http://cn.linux.vbird.org/linux_basic/0440processcontrol.php#background_what">什么是工作管理</a><br>
	　　2.2 <a href="http://cn.linux.vbird.org/linux_basic/0440processcontrol.php#background_run">job control 的管理</a>：<a href="http://cn.linux.vbird.org/linux_basic/0440processcontrol.php#the_and">&amp;</a>, <a href="http://cn.linux.vbird.org/linux_basic/0440processcontrol.php#ctrl_z">[ctrl]-z</a>, 
		<a href="http://cn.linux.vbird.org/linux_basic/0440processcontrol.php#jobs">jobs</a>, <a href="http://cn.linux.vbird.org/linux_basic/0440processcontrol.php#fg">fg</a>, <a href="http://cn.linux.vbird.org/linux_basic/0440processcontrol.php#bg">bg</a>, <a href="http://cn.linux.vbird.org/linux_basic/0440processcontrol.php#killjobs">kill</a><br>
	　　2.3 <a href="http://cn.linux.vbird.org/linux_basic/0440processcontrol.php#background_term">离线管理问题</a>： <a href="http://cn.linux.vbird.org/linux_basic/0440processcontrol.php#nohup">nohup</a><br>
	</span>
3. <a href="http://cn.linux.vbird.org/linux_basic/0440processcontrol.php#process">程序管理</a><br>
	<span class="text_h2">
	　　3.1 <a href="http://cn.linux.vbird.org/linux_basic/0440processcontrol.php#process_1">程序的观察</a>： <a href="http://cn.linux.vbird.org/linux_basic/0440processcontrol.php#ps">ps</a> (<a href="http://cn.linux.vbird.org/linux_basic/0440processcontrol.php#ps_l">ps -l</a>,
		<a href="http://cn.linux.vbird.org/linux_basic/0440processcontrol.php#ps_aux">ps aux</a>, <a href="http://cn.linux.vbird.org/linux_basic/0440processcontrol.php#zombie">zombie</a>), <a href="http://cn.linux.vbird.org/linux_basic/0440processcontrol.php#top">top</a>,
		<a href="http://cn.linux.vbird.org/linux_basic/0440processcontrol.php#pstree">pstree</a><br>
	　　3.2 <a href="http://cn.linux.vbird.org/linux_basic/0440processcontrol.php#process_2">程序的管理</a>： <a href="http://cn.linux.vbird.org/linux_basic/0440processcontrol.php#signal">signal</a>, <a href="http://cn.linux.vbird.org/linux_basic/0440processcontrol.php#kill">kill</a>, 
		<a href="http://cn.linux.vbird.org/linux_basic/0440processcontrol.php#killall">killall</a><br>
	　　3.3 <a href="http://cn.linux.vbird.org/linux_basic/0440processcontrol.php#priority">关於程序的运行顺序</a>： <a href="http://cn.linux.vbird.org/linux_basic/0440processcontrol.php#pri">priority</a>, 
		<a href="http://cn.linux.vbird.org/linux_basic/0440processcontrol.php#nice">nice</a>, <a href="http://cn.linux.vbird.org/linux_basic/0440processcontrol.php#renice">renice</a><br>
	　　3.4 <a href="http://cn.linux.vbird.org/linux_basic/0440processcontrol.php#process_3">系统资源的观察</a>： <a href="http://cn.linux.vbird.org/linux_basic/0440processcontrol.php#free">free</a>, 
		<a href="http://cn.linux.vbird.org/linux_basic/0440processcontrol.php#uname">uname</a>, <a href="http://cn.linux.vbird.org/linux_basic/0440processcontrol.php#uptime">uptime</a>, 
		<a href="http://cn.linux.vbird.org/linux_basic/0440processcontrol.php#netstat">netstat</a>, <a href="http://cn.linux.vbird.org/linux_basic/0440processcontrol.php#dmesg">dmesg</a>, <a href="http://cn.linux.vbird.org/linux_basic/0440processcontrol.php#vmstat">vmstat</a><br>
	</span>
4. <a href="http://cn.linux.vbird.org/linux_basic/0440processcontrol.php#special">特殊文件与程序</a><br>
	<span class="text_h2">
	　　4.1 <a href="http://cn.linux.vbird.org/linux_basic/0440processcontrol.php#suid_sgid">具有 SUID/SGID 权限的命令运行状态</a><br>
	　　4.2 <a href="http://cn.linux.vbird.org/linux_basic/0440processcontrol.php#proc">/proc/* 代表的意义</a><br>
	　　4.3 <a href="http://cn.linux.vbird.org/linux_basic/0440processcontrol.php#ofile">查询已开启文件或已运行程序开启之文件</a>： <a href="http://cn.linux.vbird.org/linux_basic/0440processcontrol.php#fuser">fuser</a>, 
		<a href="http://cn.linux.vbird.org/linux_basic/0440processcontrol.php#lsof">lsof</a>, <a href="http://cn.linux.vbird.org/linux_basic/0440processcontrol.php#pidof">pidof</a><br>
	</span>
5. <a href="http://cn.linux.vbird.org/linux_basic/0440processcontrol.php#selinux">SELinux 初探</a><br>
	<span class="text_h2">
	　　5.1 <a href="http://cn.linux.vbird.org/linux_basic/0440processcontrol.php#selinux_what">什么是 SELinux</a>： <a href="http://cn.linux.vbird.org/linux_basic/0440processcontrol.php#history">目标</a>, <a href="http://cn.linux.vbird.org/linux_basic/0440processcontrol.php#dac">DAC</a>,
		<a href="http://cn.linux.vbird.org/linux_basic/0440processcontrol.php#mac">MAC</a><br>
	　　5.2 <a href="http://cn.linux.vbird.org/linux_basic/0440processcontrol.php#selinux_run">SELinux 的运行模式</a>： <a href="http://cn.linux.vbird.org/linux_basic/0440processcontrol.php#selinux_com">组件</a>, <a href="http://cn.linux.vbird.org/linux_basic/0440processcontrol.php#context">安全性本文</a>,
		<a href="http://cn.linux.vbird.org/linux_basic/0440processcontrol.php#domain_type">domain/type</a><br>
	　　5.3 <a href="http://cn.linux.vbird.org/linux_basic/0440processcontrol.php#selinux_get">SELinux 的启动、关闭与观察</a>： <a href="http://cn.linux.vbird.org/linux_basic/0440processcontrol.php#getenforce">getenforce</a>,
		<a href="http://cn.linux.vbird.org/linux_basic/0440processcontrol.php#sestatus">sestatus</a>, <a href="http://cn.linux.vbird.org/linux_basic/0440processcontrol.php#on_off">启动与关闭</a>, <a href="http://cn.linux.vbird.org/linux_basic/0440processcontrol.php#setenforce">setenforce</a><br>
	　　5.4 <a href="http://cn.linux.vbird.org/linux_basic/0440processcontrol.php#selinux_http">SELinux 网络服务运行范例</a>： <a href="http://cn.linux.vbird.org/linux_basic/0440processcontrol.php#selinux_http_start">启动</a> 
		(<a href="http://cn.linux.vbird.org/linux_basic/0440processcontrol.php#ps_z">ps -Z</a>), <a href="http://cn.linux.vbird.org/linux_basic/0440processcontrol.php#selinux_http_error">错误情况</a>, 
		<a href="http://cn.linux.vbird.org/linux_basic/0440processcontrol.php#selinux_http_resolv">解决</a> (<a href="http://cn.linux.vbird.org/linux_basic/0440processcontrol.php#chcon">chcon</a>, <a href="http://cn.linux.vbird.org/linux_basic/0440processcontrol.php#restorecon">restorecon</a>)<br>
	　　5.5 <a href="http://cn.linux.vbird.org/linux_basic/0440processcontrol.php#selinux_daemon">SELinux 所需的服务</a>： <a href="http://cn.linux.vbird.org/linux_basic/0440processcontrol.php#setroubleshoot">setroubleshoot</a>, 
		<a href="http://cn.linux.vbird.org/linux_basic/0440processcontrol.php#sealert">sealert</a>, <a href="http://cn.linux.vbird.org/linux_basic/0440processcontrol.php#auditd">auditd</a>, <a href="http://cn.linux.vbird.org/linux_basic/0440processcontrol.php#audit2why">audit2why</a><br>
	　　5.6 <a href="http://cn.linux.vbird.org/linux_basic/0440processcontrol.php#selinux_policy">SELinux 的政策与守则管理</a>： <a href="http://cn.linux.vbird.org/linux_basic/0440processcontrol.php#seinfo">seinfo</a>, 
		<a href="http://cn.linux.vbird.org/linux_basic/0440processcontrol.php#sesearch">sesearch</a>, <a href="http://cn.linux.vbird.org/linux_basic/0440processcontrol.php#getsebool">getsebool</a>, <a href="http://cn.linux.vbird.org/linux_basic/0440processcontrol.php#setsebool">setsebool</a>,
		<a href="http://cn.linux.vbird.org/linux_basic/0440processcontrol.php#semanage">semanage</a><br>
	</span>
6. <a href="http://cn.linux.vbird.org/linux_basic/0440processcontrol.php#hint">重点回顾</a><br>
7. <a href="http://cn.linux.vbird.org/linux_basic/0440processcontrol.php#ex">本章习题</a><br>
8. <a href="http://cn.linux.vbird.org/linux_basic/0440processcontrol.php#reference">参考数据与延伸阅读</a><br>
<span class="text_h2">
9. <a href="http://phorum.vbird.org/viewtopic.php?t=23890" target="_blank">针对本文的建议：http://phorum.vbird.org/viewtopic.php?t=23890</a>
</span>
</span>
</div>


<!-- 本文的正式部分 -->
<hr><a name="whatis"></a><img src="./鸟哥的 Linux 私房菜18 -- 程序管理与 SELinux 初探_files/logo.png" alt="大标题的图示" width="35" align="middle" height="34"><span class="text_h1">什么是程序 (process)</span><br>
<div class="block1">
	<p>由前面一连几个章节的数据看来，我们一直强调在 Linux 底下所有的命令与你能够进行的动作都与权限有关，
	而系统如何判定你的权限呢？当然就是<a href="http://cn.linux.vbird.org/linux_basic/0410accountmanager.php">第十四章帐号管理</a>当中提到的 
	UID/GID 的相关概念，以及文件的属性相关性罗！再进一步来解释，你现在大概知道，在 Linux 
	系统当中：『<span class="text_import2">触发任何一个事件时，系统都会将他定义成为一个程序，并且给予这个程序一个 
	ID ，称为 PID，同时依据启发这个程序的使用者与相关属性关系，给予这个 PID 一组有效的权限配置。</span>』
	从此以后，这个 PID 能够在系统上面进行的动作，就与这个 PID 的权限有关了！</p>

	<p>看这个定义似乎没有什么很奇怪的地方，不过，您得要了解什么叫做『触发事件』才行啊！
	我们在什么情况下会触发一个事件？而同一个事件可否被触发多次？呵呵！来了解了解先！<br><br></p>

	<hr><a name="whatis_program_process"></a><img src="./鸟哥的 Linux 私房菜18 -- 程序管理与 SELinux 初探_files/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">程序与程序
	(process &amp; program)</span><br>
	<div class="block2">
		<p>我们如何产生一个程序呢？其实很简单啦，就是『运行一个程序或命令』就可以触发一个事件而取得一个 
		PID 罗！我们说过，系统应该是仅认识 binary file 的，那么当我们要让系统工作的时候，当然就是需要启动一个 
		binary file 罗，那个 binary file 就是程序 (program) 啦！</p>

		<p>那我们知道，每个程序都有三组人马的权限，每组人马都具有 r/w/x 的权限，所以：『不同的使用者身份运行这个 
		program 时，系统给予的权限也都不相同！』举例来说，我们可以利用 touch 来创建一个空的文件，当 root 运行这个 touch 
		命令时，他取得的是 UID/GID = 0/0 的权限，而当 dmtsai (UID/GID=501/501) 
		运行这个 touch 时，他的权限就跟 root 不同啦！我们将这个概念绘制成图示来瞧瞧如下：</p>

		<center><img src="./鸟哥的 Linux 私房菜18 -- 程序管理与 SELinux 初探_files/process_1.gif" alt="程序被加载成为程序以及相关数据的示意图" title="程序被加载成为程序以及相关数据的示意图" border="0"><br>
		图 1.1.1、程序被加载成为程序以及相关数据的示意图<br></center>

		<p>如上图所示，程序一般是放置在实体磁碟中，然后透过使用者的运行来触发。触发后会加载到内存中成为一个个体，那就是程序。
		为了操作系统可管理这个程序，因此程序有给予运行者的权限/属性等参数，并包括程序所需要的命令码与数据或文件数据等，
		最后再给予一个 PID 。系统就是透过这个 PID 来判断该 process 是否具有权限进行工作的！他是很重要的哩！</p>

		<p>举个更常见的例子，我们要操作系统的时候，通常是利用连线程序或者直接在主机前面登陆，然后取得我们的 
		shell 对吧！那么，我们的 shell  是 bash 对吧，这个 bash 在 /bin/bash 对吧，那么同时间的每个人登陆都是运行 
		/bin/bash 对吧！不过，每个人取得的权限就是不同！也就是说，我们可以这样看：</p>

		<center><img src="./鸟哥的 Linux 私房菜18 -- 程序管理与 SELinux 初探_files/program_process.gif" alt="程序与程序之间的差异" title="程序与程序之间的差异" border="0"><br>
		图 1.1.2、程序与程序之间的差异<br></center>

		<p>也就是说，当我们登陆并运行 bash 时，系统已经给我们一个 PID 了，这个 PID 就是依据登陆者的 UID/GID 
		(/etc/passwd) 来的啦～以上面的图 1.1.2 配合图 1.1.1 来做说明的话，我们知道 /bin/bash 是一个程序 (program)，当 dmtsai
		登陆后，他取得一个 PID 号码为 2234 的程序，这个程序的 User/Group 都是 dmtsai
		，而当这个程序进行其他作业时，例如上面提到的 touch 这个命令时，
		那么由这个程序<span class="text_import2">衍生出来的其他程序在一般状态下，也会沿用这个程序的相关权限</span>的！</p>

		<p>让我们将程序与程序作个总结：</p>
		<ul class="text_import2">
		<li>程序 (program)：通常为 binary program ，放置在储存媒体中 (如硬盘、光盘、软盘、磁带等)，
		为实体文件的型态存在；<br><br></li>
		<li>程序 (process)：程序被触发后，运行者的权限与属性、程序的程序码与所需数据等都会被加载内存中，
		操作系统并给予这个内存内的单元一个识别码 (PID)，可以说，程序就是一个正在运行中的程序。</li>
		</ul><br>

		<a name="parent_pid"></a>
		<hr><ul class="list1"><li class="text_import1">子程序与父程序：</li></ul>

		<p>在上面的说明里面，我们有提到所谓的『衍生出来的程序』，那是个啥咚咚？这样说好了，当我们登陆系统后，会取得一个 
		bash 的 shell ，然后，我们用这个 bash 提供的介面去运行另一个命令，例如 /usr/bin/passwd 或者是 touch 
		等等，那些另外运行的命令也会被触发成为 PID ，呵呵！那个后来运行命令才产生的 PID 就是『子程序』了，而在我们原本的 bash 
		环境下，就称为『父程序』了！借用我们在<a href="http://cn.linux.vbird.org/linux_basic/0320bash.php#export"> 十一章 Bash 谈到的 export</a>
		所用的图示好了：</p>

		<center><img src="./鸟哥的 Linux 私房菜18 -- 程序管理与 SELinux 初探_files/ppid.gif" alt="程序相关系之示意图" title="程序相关系之示意图" border="1"><br>
		图 1.1.3、程序相关系之示意图<br></center>

		<p>所以你必须要知道，程序彼此之间是有相关性的！以上面的图示来看，连续运行两个 bash 后，第二个 bash 
		的父程序就是前一个 bash。因为每个程序都有一个 PID ，那某个程序的父程序该如何判断？就透过 Parent PID (PPID) 
		来判断即可。此外，由十一章的 export 内容我们也探讨过环境变量的继承问题，子程序可以取得父程序的环境变量啦！
		让我们来进行底下的练习，以了解什么是子程序/父程序。</p>

<table border="1" cellpadding="5" cellspacing="0" width="90%"><tbody><tr><td>
例题：<div class="block2">
请在目前的 bash 环境下，再触发一次 bash ，并以『 ps -l 』这个命令观察程序相关的输出资讯。
</div>
答：<div class="block2">
直接运行 bash ，会进入到子程序的环境中，然后输入 ps -l 后，出现：
<pre style="font-size: 10pt;">F S   UID   PID  PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD
4 S     0  <u>8074</u>  8072  2  76   0 -  1287 wait   pts/1    00:00:00 bash
0 S     0  8102  <u>8074</u>  4  76   0 -  1287 wait   pts/1    00:00:00 bash
4 R     0  8118  8102  0  78   0 -  1101 -      pts/1    00:00:00 ps</pre>
有看到那个 PID 与 PPID 吗？第一个 bash 的 PID 与第二个 bash 的 PPID 都是 8074 啊，
因为第二个 bash 是来自於第一个所产生的嘛！另外，每部主机的程序启动状态都不一样，
所以在你的系统上面看到的 PID 与我这里的显示一定不同！那是正常的！详细的 <a href="http://cn.linux.vbird.org/linux_basic/0440processcontrol.php#ps">ps</a> 命令我们会在本章稍后介绍，
这里你只要知道 ps -l 可以查阅到相关的程序资讯即可。
</div>
</td></tr></tbody></table>

		<p>很多朋友常常会发现：『咦！明明我将有问题的程序关闭了，怎么过一阵子他又自动的产生？
		而且新产生的那个程序的 PID 与原先的还不一样，这是怎么回事呢？』不要怀疑，如果不是 <a href="http://cn.linux.vbird.org/linux_basic/0430cron.php">crontab 工作排程</a>的影响，肯定有一支父程序存在，所以你杀掉子程序后，
		父程序就会主动再生一支！那怎么办？正所谓这：『擒贼先擒王』，找出那支父程序，然后将他删除就对啦！<br><br></p>

		<a name="fork_and_exec"></a>
		<hr><ul class="list1"><li class="text_import1">fork and exec：程序呼叫的流程</li></ul>

		<p>其实子程序与父程序之间的关系还挺复杂的，最大的复杂点在於程序互相之间的呼叫。<span class="text_import2">在 Linux 的程序呼叫通常称为 fork-and-exec 的流程
		 (<a href="http://cn.linux.vbird.org/linux_basic/0440processcontrol.php#ps1">注1</a>)！程序都会藉由父程序以复制 (fork) 的方式产生一个一模一样的子程序，
		然后被复制出来的子程序再以 exec 的方式来运行实际要进行的程序，最终就成为一个子程序的存在</span>。
		整个流程有点像底下这张图：</p>

		<center><img src="./鸟哥的 Linux 私房菜18 -- 程序管理与 SELinux 初探_files/fork-and-exec.gif" alt="程序使用 fork and exec 呼叫的情况示意图" title="程序使用 fork and exec 呼叫的情况示意图" border="0"><br>
		图 1.1.4、程序使用 fork and exec 呼叫的情况示意图<br></center>

		<p>(1)系统先以 fork 的方式复制一个与父程序相同的缓存程序，这个程序与父程序唯一的差别就是 PID 不同！
		但是这个缓存程序还会多一个 PPID 的参数，PPID 如前所述，就是父程序的程序识别码啦！然后(2)缓存程序开始以 exec
		的方式加载实际要运行的程序，以上述图示来讲，新的程序名称为 qqq ，最终子程序的程序码就会变成 qqq 了！
		这样了解乎！<br><br></p>

		<a name="the_daemon"></a>
		<hr><ul class="list1"><li class="text_import1">系统或网络服务：常驻在内存的程序</li></ul>

		<p>如果就我们之前学到的一些命令数据来看，其实我们下达的命令都很简单，包括用 ls 显示文件啊、用 touch 
		创建文件啊、rm/mkdir/cp/mv 等命令管理文件啊、chmod/chown/passwd 等等的命令来管理权限等等的，不过，
		这些命令都是运行完就结束了。也就是说，该项命令被触发后所产生的 PID 很快就会终止呢！
		那有没有一直在运行的程序啊？当然有啊！而且多的是呢！</p>

		<p>举个简单的例子来说好了，我们知道系统每分钟都会去扫瞄 /etc/crontab 以及相关的配置档，
		来进行工作排程吧？那么那个工作排程是谁负责的？当然不是鸟哥啊！
		呵呵！是 crond 这个程序所管理的，<span class="text_import2">我们将他启动在背景当中一直持续不断的运行，
		套句以前 DOS 年代常常说的一句话，那就是『常驻在内存当中的程序』啦！</span></p>

		<p>常驻在内存当中的程序通常都是负责一些系统所提供的功能以服务使用者各项任务，因此<span class="text_import2">这些常驻程序就会被我们称为：服务 (daemon)</span>。系统的服务非常的多，
		不过主要大致分成系统本身所需要的服务，例如刚刚提到的 crond 及 
		atd ，还有 syslog 等等的。还有一些则是负责网络连线的服务，例如 Apache, named, postfix, 
		vsftpd... 等等的。这些网络服务比较有趣的地方，在於这些程序被运行后，他会启动一个可以负责网络监听的端口 
		(port) ，以提供外部用户端 (client) 的连线要求。</p>
	</div>

	<hr><a name="whatis_milti_task"></a><img src="./鸟哥的 Linux 私房菜18 -- 程序管理与 SELinux 初探_files/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">Linux 的多人多工环境</span><br>
	<div class="block2">
		<p>我们现在知道了，其实在 Linux 底下运行一个命令时，系统会将相关的权限、属性、程序码与数据等均加载内存，
		并给予这个单元一个程序识别码 (PID)，最终该命令可以进行的任务则与这个 PID 
		的权限有关。根据这个说明，我们就可以简单的了解，为什么 Linux 这么多用户，但是却每个人都可以拥有自己的环境了吧！^_^
		！底下我们来谈谈 Linux 多人多工环境的特色：<br><br></p>

		<ul class="list1"><li class="text_import2">多人环境：</li></ul>

		<p>Linux 最棒的地方就在於他的多人多工环境了！那么什么是『多人多工』？在 Linux 系统上面具有多种不同的帐号，
		每种帐号都有都有其特殊的权限，只有一个人具有至高无上的权力，那就是
		root (系统管理员)。除了 root 之外，其他人都必须要受一些限制的！而每个人进入
		Linux 的环境配置都可以随著每个人的喜好来配置 (还记得我们在<a href="http://cn.linux.vbird.org/linux_basic/0320bash.php">第十一章 BASH</a> 
		提过的 ~/.bashrc 吧？对了！就是那个光！)！现在知道为什么了吧？因为每个人登陆后取得的 shell 的 PID 
		不同嘛！<br><br></p>

		<ul class="list1"><li class="text_import2">多工行为：</li></ul>

		<p>我们在<a href="http://cn.linux.vbird.org/linux_basic/0105computers.php">第零章</a>谈到 CPU 的速度，目前的 CPU 速度可高达几个 GHz。
		这代表 CPU 每秒钟可以运行 10<sup>9</sup> 这么多次命令。我们的 Linux 可以让 CPU 在各个工作间进行切换，
		也就是说，其实每个工作都仅占去 CPU 的几个命令次数，所以 CPU 每秒就能够在各个程序之间进行切换啦！
		谁叫 CPU 可以在一秒钟进行这么多次的命令运行。</p>

		<p>CPU 切换程序的工作，与这些工作进入到 CPU 运行的排程 (CPU 排程，非 crontab 排程) 会影响到系统的整体效能！
		目前 Linux 使用的多工切换行为是非常棒的一个机制，几乎可以将 PC 的性能整个压榨出来！
		由於效能非常好，因此当多人同时登陆系统时，其实会感受到整部主机好像就为了你存在一般！
		这就是多人多工的环境啦！(<a href="http://cn.linux.vbird.org/linux_basic/0440processcontrol.php#ps2">注2</a>)<br><br></p>

		<ul class="list1"><li class="text_import2">多重登陆环境的七个基本终端窗口：</li></ul>

		<p>在 Linux 当中，默认提供了六个文字界面登陆窗口，以及一个图形界面，你可以使用
		[Alt]+[F1].....[F7] 来切换不同的终端机界面，而且每个终端机界面的登陆者还可以不同人！
		很炫吧！这个东西可就很有用啦！尤其是在某个程序死掉的时候！</p>

		<p>其实，这也是多工环境下所产生的一个情况啦！我们的 Linux 
		默认会启动六个终端机登陆环境的程序，所以我们就会有六个终端机介面。
		您也可以减少啊！就是减少启动的终端机程序就好了。详细的数据可以先查阅 /etc/inittab 
		这个文件，未来我们在<a href="http://cn.linux.vbird.org/linux_basic/0510osloader.php">启动管理流程 (第二十章)</a> 会再仔细的介绍的！<br><br></p>

		<ul class="list1"><li class="text_import2">特殊的程序管理行为：</li></ul>

		<p>以前的鸟哥笨笨的，总是以为使用 Windows 98 就可以啦！后来，因为工作的关系，需要使用 Unix 
		系统，想说我只要在工作机前面就好，才不要跑来跑去的到 Unix 工作站前面去呢！所以就使用 Windows 连到我的 
		Unix 工作站工作！好死不死，我一个程序跑下来要 2~3 天，唉～偏偏常常到了第 2.5 天的时候， Windows 98 
		就给他挂点去！当初真的是给他怕死了～</p>

		<p>后来因为换了新计算机，用了随机版的 Windows 2000 ，呵呵，这东西真不错 (指对单人而言) ，在死机的时候，
		他可以仅将错误的程序踢掉，而不干扰其他的程序进行，呵呵！
		从此以后，就不用担心会死机连连罗！不过，2000 毕竟还不够好，因为有的时候还是会死当！</p>

		<p>那么 Linux 会有这样的问题吗？老实说， Linux 几乎可以说绝对不会死机的！因为他可以在任何时候，
		将某个被困住的程序杀掉，然后再重新运行该程序而不用重新启动！够炫吧！那么如果我在
		Linux 下以文字界面登陆，在萤幕当中显示错误信息后就挂了～动都不能动，该如何是好！？
		这个时候那默认的七个窗口就帮上忙啦！你可以随意的再按
		[Alt]+[F1].....[F7] 来切换到其他的终端机界面，然后以 <a href="http://cn.linux.vbird.org/linux_basic/0440processcontrol.php#ps">ps -aux</a> 找出刚刚的错误程序，然后给他
		<a href="http://cn.linux.vbird.org/linux_basic/0440processcontrol.php#kill">kill</a> 一下，哈哈，回到刚刚的终端机界面！恩～棒！又回复正常罗！</p>

		<p>为什么可以这样做呢？我们刚刚不是提过吗？每个程序之间可能是独立的，也可能有相依性，
		只要到独立的程序当中，删除有问题的那个程序，当然他就可以被系统移除掉啦！^_^<br><br></p>

		<ul class="list1"><li class="text_import2">bash 环境下的工作管理 (job control)</li></ul>

		<p>我们在上一个小节有提到所谓的『父程序、子程序』的关系，那我们登陆 bash 之后，
		就是取得一个名为 bash 的 PID 了，而在这个环境底下所运行的其他命令，
		就几乎都是所谓的子程序了。那么，在这个单一的 bash 介面下，我可不可以进行多个工作啊？
		当然可以啦！可以『同时』进行喔！举例来说，我可以这样做：</p>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">cp file1 file2 &amp;</span>
</pre></td></tr></tbody></table>

		<p>在这一串命令中，重点在那个 &amp; 的功能，他表示将 file1 这个文件复制为 file2 ，且放置於背景中运行，
		也就是说运行这一个命令之后，在这一个终端介面仍然可以做其他的工作！而当这一个命令 (cp file1 file2)
		运行完毕之后，系统将会在你的终端介面显示完成的消息！很便利喔！<br><br></p>

		<ul class="list1"><li class="text_import2">多人多工的系统资源分配问题考虑：</li></ul>

		<p>多人多工确实有很多的好处，但其实也有管理上的困扰，因为使用者越来越多，
		将导致你管理上的困扰哩！另外，由於使用者日盛，当使用者达到一定的人数后，
		通常你的机器便需要升级了，因为 CPU 的运算与 RAM 的大小可能就会不敷使用！</p>

		<p>举个例子来说，鸟哥之前的网站管理的有点不太好，因为使用了一个很复杂的人数统计程序，
		这个程序会一直去取用 MySQL 数据库的数据，偏偏因为流量大，造成 MySQL 很忙碌。
		在这样的情况下，当鸟哥要登陆去写网页数据，或者要去使用讨论区的资源时，
		哇！慢的很！简直就是『龟速』啊！后来终於将这个程序停止不用了，
		以自己写的一个小程序来取代，呵呵！这样才让 CPU 的负载 (loading)  整个降下来～
		用起来顺畅多了！ ^_^</p>
	</div>
</div>


<hr><a name="background"></a><img src="./鸟哥的 Linux 私房菜18 -- 程序管理与 SELinux 初探_files/logo.png" alt="大标题的图示" width="35" align="middle" height="34"><span class="text_h1">工作管理 (job control)</span><br>
<div class="block1">
	<p>这个工作管理 (job control) 是用在 bash 环境下的，也就是说：『<span class="text_import2">当我们登陆系统取得 bash shell
	之后，在<u>单一终端机介面</u>下同时进行多个工作的行为管理</span> 』。举例来说，我们在登陆 bash 后，
	想要一边复制文件、一边进行数据搜寻、一边进行编译，还可以一边进行 vi 程序撰写！
	当然我们可以重复登陆那六个文字介面的终端机环境中，不过，能不能在一个 bash 内达成？
	当然可以啊！就是使用 job control 啦！ ^_^<br><br></p>

	<hr><a name="background_what"></a><img src="./鸟哥的 Linux 私房菜18 -- 程序管理与 SELinux 初探_files/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">什么是工作管理？</span><br>
	<div class="block2">
		<p>从上面的说明当中，你应该要了解的是：『<span class="text_import2">进行工作管理的行为中，
		其实每个工作都是目前 bash 的子程序，亦即彼此之间是有相关性的。
		我们无法以 job control 的方式由 tty1 的环境去管理 tty2 的 bash ！</span>』
		这个概念请你得先创建起来，后续的范例介绍之后，你就会清楚的了解罗！</p>

		<p>或许你会觉得很奇怪啊，既然我可以在六个终端介面登陆，那何必使用 job control 呢？
		真是脱裤子放屁，多此一举啊！不要忘记了呢，我们可以在 <a href="http://cn.linux.vbird.org/linux_basic/0410accountmanager.php#limits">/etc/security/limits.conf (第十四章)</a>
		里面配置使用者同时可以登陆的连线数，在这样的情况下，某些使用者可能仅能以一个连线来工作呢！
		所以罗，你就得要了解一下这种工作管理的模式了！此外，这个章节内容也会牵涉到很多的数据流重导向，所以，如果忘记的话，
		务必回到<a href="http://cn.linux.vbird.org/linux_basic/0320bash.php">第十一章 BASH Shell</a> 看一看喔！</p>

		<p>由於假设我们只有一个终端介面，因此在<span class="text_import2">可以出现提示字节让你操作的环境就称为前景 
		(foreground)，至於其他工作就可以让你放入背景 (background) 去暂停或运行。</span>要注意的是，放入背景的工作想要运行时，
		他必须不能够与使用者互动。举例来说， vim 绝对不可能在背景里面运行 (running) 的！因为你没有输入数据他就不会跑啊！
		而且<span class="text_import2">放入背景的工作是不可以使用 [ctrl]+c 来终止的</span>』！</p>

		<p>总之，要进行 bash  的 job control 必须要注意到的限制是：</p>

		<ul class="text_import2">
		<li>这些工作所触发的程序必须来自於你 shell 的子程序(只管理自己的 bash)；</li>
		<li>前景：你可以控制与下达命令的这个环境称为前景的工作 (foreground)；</li>
		<li>背景：可以自行运行的工作，你无法使用 [ctrl]+c 终止他，可使用 bg/fg 呼叫该工作；</li>
		<li>背景中『运行』的程序不能等待 terminal/shell 的输入(input)</li></ul>

		<p>接下来让我们实际来管理这些工作吧！</p>
	</div>

	<hr><a name="background_run"></a><img src="./鸟哥的 Linux 私房菜18 -- 程序管理与 SELinux 初探_files/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">job control 的管理</span><br>
	<div class="block2">
		<p>如前所述，bash 只能够管理自己的工作而不能管理其他 bash 的工作，所以即使你是 root 也不能够将别人的 bash
		底下的 job 给他拿过来运行。此外，又分前景与背景，然后在背景里面的工作状态又可以分为『暂停 (stop)』与『运行中
		(running)』。那实际进行 job 控制的命令有哪些？底下就来谈谈。<br><br></p>

		<a name="the_and"></a>
		<hr><ul class="list1"><li class="text_import1">直接将命令丢到背景中『运行』的 &amp;</li></ul>

		<p>如同前面提到的，我们在只有一个 bash 的环境下，如果想要同时进行多个工作，
		那么可以将某些工作直接丢到背景环境当中，让我们可以继续操作前景的工作！那么如何将工作丢到背景中？
		最简单的方法就是利用『 &amp; 』这个玩意儿了！举个简单的例子，我们要将 /etc/ 整个备份成为 
		/tmp/etc.tar.gz 且不想要等待，那么可以这样做：</p>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">tar -zpcf /tmp/etc.tar.gz /etc &amp;</span>
[1] 8400  <span class="term_note">&lt;== [job number] PID </span>
[root@www ~]# tar: Removing leading `/' from member names 
<span class="term_say"># 在中括号内的号码为工作号码 (job number)，该号码与 bash 的控制有关。
# 后续的 8400 则是这个工作在系统中的 PID。至於后续出现的数据是 tar 运行的数据流，
# 由於我们没有加上数据流重导向，所以会影响画面！不过不会影响前景的操作喔！</span>
</pre></td></tr></tbody></table>

		<p>仔细的瞧一瞧，我在输入一个命令后，在该命令的最后面加上一个『 &amp; 』代表将该命令丢到背景中，
		此时 bash 会给予这个命令一个『工作号码(job number)』，就是那个 [1] 啦！至於后面那个 8400 
		则是该命令所触发的『 PID 』了！而且，有趣的是，我们可以继续操作 bash 呢！很不赖吧！
		不过，那么丢到背景中的工作什么时候完成？完成的时候会显示什么？如果你输入几个命令后，突然出现这个数据：</p>

<table class="term"><tbody><tr><td class="term"><pre>[1]+  Done                    tar -zpcf /tmp/etc.tar.gz /etc
</pre></td></tr></tbody></table>

		<p>就代表 [1] 这个工作已经完成 (Done) ，该工作的命令则是接在后面那一串命令列。
		这样了解了吧！另外，这个 &amp; 代表：『将工作丢到背景中去运行』喔！
		注意到那个『运行』的字眼！此外，这样的情况最大的好处是： 
		<span class="text_import2">不怕被 [ctrl]+c 中断</span>的啦！
		此外，将工作丢到背景当中要特别注意数据的流向喔！包括上面的信息就有出现错误信息，导致我的前景被影响。
		虽然只要按下 [enter] 就会出现提示字节。但如果我将刚刚那个命令改成：</p>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">tar -zpcvf /tmp/etc.tar.gz /etc &amp;</span>
</pre></td></tr></tbody></table>

		<p>情况会怎样？在背景当中运行的命令，如果有 stdout 及 stderr 时，他的数据依旧是输出到萤幕上面的，
		所以，我们会无法看到提示字节，当然也就无法完好的掌握前景工作。同时由於是背景工作的 tar ，
		此时你怎么按下 [ctrl]+c 也无法停止萤幕被搞的花花绿绿的！所以罗，最佳的状况就是利用数据流重导向，
		将输出数据传送至某个文件中。举例来说，我可以这样做：</p>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">tar -zpcvf /tmp/etc.tar.gz /etc &gt; /tmp/log.txt 2&gt;&amp;1 &amp;</span>
[1] 8429
[root@www ~]# 
</pre></td></tr></tbody></table>

		<p>呵呵！如此一来，输出的资讯都给他传送到 /tmp/log.txt 当中，当然就不会影响到我们前景的作业了。
		这样说，您应该可以更清楚数据流重导向的重要性了吧！^_^</p>

		<div style="padding: 10pt 0pt;" align="right"><table width="90%"><tbody><tr><td><b>Tips:</b><br><span style="color: rgb(0, 144, 0);"><font size="-1">		工作号码 (job number) 只与你这个 bash 环境有关，但是他既然是个命令触发的咚咚，所以当然一定是一个程序，
		因此你会观察到有 job number 也搭配一个 PID ！
		</font></span></td><td><img src="./鸟哥的 Linux 私房菜18 -- 程序管理与 SELinux 初探_files/vbird_face.gif" alt="鸟哥的图示" title="鸟哥的图示"></td></tr></tbody></table></div>

		<a name="ctrl_z"></a>
		<hr><ul class="list1"><li class="text_import1">将『目前』的工作丢到背景中『暂停』：[ctrl]-z</li></ul>

		<p>想个情况：如果我正在使用 vi ，却发现我有个文件不知道放在哪里，需要到 bash
		环境下进行搜寻，此时是否要结束 vi 呢？呵呵！当然不需要啊！只要暂时将 vi 给他丢到背景当中等待即可。
		例如以下的案例：</p>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">vi ~/.bashrc</span>
<span class="term_say"># 在 vi 的一般模式下，按下 [ctrl]-z 这两个按键</span>
[1]+  Stopped                 vim ~/.bashrc
[root@www ~]#   <span class="term_note">&lt;==顺利取得了前景的操控权！</span>
[root@www ~]# <span class="term_command">find / -print</span>
<span class="term_say">....(输出省略)....
# 此时萤幕会非常的忙碌！因为萤幕上会显示所有的档名。请按下 [ctrl]-z 暂停</span>
[2]+  Stopped                 find / -print
</pre></td></tr></tbody></table>

		<p>在 vi 的一般模式下，按下 [ctrl] 及 z 这两个按键，萤幕上会出现 [1] ，表示这是第一个工作，
		而<span class="text_import2">那个 + 代表最近一个被丢进背景的工作，且目前在背景下默认会被取用的那个工作 
		(与 fg 这个命令有关 )！而那个 Stopped 则代表目前这个工作的状态。在默认的情况下，使用 [ctrl]-z 
		丢到背景当中的工作都是『暂停』的状态喔！</span><br><br></p>

		<a name="jobs"></a>
		<hr><ul class="list1"><li class="text_import1">观察目前的背景工作状态： jobs</li></ul>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">jobs [-lrs]</span>
<span class="term_say">选项与参数：
-l  ：除了列出 job number 与命令串之外，同时列出 PID 的号码；
-r  ：仅列出正在背景 run 的工作；
-s  ：仅列出正在背景当中暂停 (stop) 的工作。</span>

<span class="term_hd">范例一：观察目前的 bash 当中，所有的工作，与对应的 PID</span>
[root@www ~]# <span class="term_command">jobs -l</span>
[1]- 10314 Stopped                 vim ~/.bashrc
[2]+ 10833 Stopped                 find / -print
</pre></td></tr></tbody></table>

		<p>如果想要知道目前有多少的工作在背景当中，就用 jobs 这个命令吧！一般来说，直接下达 jobs 即可！
		不过，如果你还想要知道该 job number 的 PID 号码，可以加上 -l  这个参数啦！
		在输出的资讯当中，例如上表，仔细看到那个 + - 号喔！那个 + 代表默认的取用工作。
		所以说：『<span class="text_import2">目前我有两个工作在背景当中，两个工作都是暂停的，
		而如果我仅输入 fg 时，那么那个 [2] 会被拿到前景当中来处理</span>』！</p>

		<p><span class="text_import2">其实 + 代表最近被放到背景的工作号码， - 代表最近最后第二个被放置到背景中的工作号码。</span>
		而超过最后第三个以后的工作，就不会有 +/- 符号存在了！<br><br></p>

		<a name="fg"></a>
		<hr><ul class="list1"><li class="text_import1">将背景工作拿到前景来处理：fg</li></ul>

		<p>刚刚提到的都是将工作丢到背景当中去运行的，那么有没有可以将背景工作拿到前景来处理的？
		有啊！就是那个 fg (foreground) 啦！举例来说，我们想要将上头范例当中的工作拿出来处理时：</p>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">fg %jobnumber</span>
<span class="term_say">选项与参数：
%jobnumber ：jobnumber 为工作号码(数字)。注意，那个 % 是可有可无的！</span>

<span class="term_hd">范例一：先以 jobs 观察工作，再将工作取出：</span>
[root@www ~]# <span class="term_command">jobs</span>
[1]- 10314 Stopped                 vim ~/.bashrc
[2]+ 10833 Stopped                 find / -print
[root@www ~]# <span class="term_command">fg   </span>   <span class="term_note">&lt;==默认取出那个 + 的工作，亦即 [2]。立即按下[ctrl]-z</span>
[root@www ~]# <span class="term_command">fg %1</span>   <span class="term_note">&lt;==直接规定取出的那个工作号码！再按下[ctrl]-z</span>
[root@www ~]# <span class="term_command">jobs</span>
[1]<span class="term_write">+</span>  Stopped                 vim ~/.bashrc
[2]-  Stopped                 find / -print
</pre></td></tr></tbody></table>

		<p>经过 fg 命令就能够将背景工作拿到前景来处理罗！不过比较有趣的是最后一个显示的结果，我们会发现 + 出现在第一个工作后！
		怎么会这样啊？这是因为你刚刚利用 fg %1 将第一号工作捉到前景后又放回背景，此时最后一个被放入背景的将变成 vi 那个命令动作，
		所以当然 [1] 后面就会出现 + 了！了解乎！另外，如果输入『<span class="text_import2"> fg - </span>』
		则代表将 - 号的那个工作号码拿出来，上面就是 [2]- 那个工作号码啦！<br><br></p>

		<a name="bg"></a>
		<hr><ul class="list1"><li class="text_import1">让工作在背景下的状态变成运行中： bg</li></ul>

		<p>我们刚刚提到，那个 [ctrl]-z 可以将目前的工作丢到背景底下去『暂停』，
		那么如何让一个工作在背景底下『 Run 』呢？我们可以在底下这个案例当中来测试！
		注意喔！底下的测试要进行的快一点！^_^</p>

<table class="term"><tbody><tr><td class="term"><pre><span class="term_hd">范例一：一运行 find / -perm +7000 &gt; /tmp/text.txt 后，立刻丢到背景去暂停！</span>
[root@www ~]# <span class="term_command">find / -perm +7000 &gt; /tmp/text.txt</span>
<span class="term_say"># 此时，请立刻按下 [ctrl]-z 暂停！</span>
[3]+  Stopped                 find / -perm +7000 &gt; /tmp/text.txt

<span class="term_hd">范例二：让该工作在背景下进行，并且观察他！！</span>
[root@www ~]# <span class="term_command">jobs ; bg %3 ; jobs</span>
[1]-  Stopped                 vim ~/.bashrc
[2]   Stopped                 find / -print
[3]+  <span class="term_write">Stopped</span>                 find / -perm +7000 &gt; /tmp/text.txt
[3]+ find / -perm +7000 &gt; /tmp/text.txt &amp;  <span class="term_note">&lt;==用 bg%3 的情况！</span>
[1]+  Stopped                 vim ~/.bashrc
[2]   Stopped                 find / -print
[3]-  <span class="term_write">Running</span>                 find / -perm +7000 &gt; /tmp/text.txt &amp;
</pre></td></tr></tbody></table>

		<p>看到哪里有差异吗？呼呼！没错！就是那个状态列～以经由 Stopping 变成了 Running 罗！
		看到差异点，嘿嘿！命令列最后方多了一个 &amp; 的符号罗！
		代表该工作被启动在背景当中了啦！ ^_^<br><br></p>

		<a name="killjobs"></a>
		<hr><ul class="list1"><li class="text_import1">管理背景当中的工作： kill</li></ul>

		<p>刚刚我们可以让一个已经在背景当中的工作继续工作，也可以让该工作以 fg 拿到前景来，
		那么，如果想要将该工作直接移除呢？或者是将该工作重新启动呢？这个时候就得需要给予该工作一个讯号 
		(signal) ，让他知道该怎么作才好啊！此时， kill 这个命令就派上用场啦！</p>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">kill -signal %jobnumber</span>
[root@www ~]# <span class="term_command">kill -l</span>
<span class="term_say">选项与参数：
-l  ：这个是 L 的小写，列出目前 kill 能够使用的讯号 (signal) 有哪些？
signal ：代表给予后面接的那个工作什么样的指示罗！用 man 7 signal 可知：
  -1 ：重新读取一次参数的配置档 (类似 reload)；
  -2 ：代表与由键盘输入 [ctrl]-c 同样的动作；
  -9 ：立刻强制删除一个工作；
  -15：以正常的程序方式终止一项工作。与 -9 是不一样的。</span>

<span class="term_hd">范例一：找出目前的 bash 环境下的背景工作，并将该工作『强制删除』。</span>
[root@www ~]# <span class="term_command">jobs</span>
[1]+  Stopped                 vim ~/.bashrc
[2]   Stopped                 find / -print
[root@www ~]# <span class="term_command">kill -9 %2; jobs</span>
[1]+  Stopped                 vim ~/.bashrc
[2]   <span class="term_write">Killed</span>                  find / -print
<span class="term_say"># 再过几秒你再下达 jobs 一次，就会发现 2 号工作不见了！因为被移除了！</span>

<span class="term_hd">范例：找出目前的 bash 环境下的背景工作，并将该工作『正常终止』掉。</span>
[root@www ~]# <span class="term_command">jobs</span>
[1]+  Stopped                 vim ~/.bashrc
[root@www ~]# <span class="term_command">kill -SIGTERM %1</span>
<span class="term_say"># -SIGTERM 与 -15 是一样的！您可以使用 kill -l 来查阅！</span>
</pre></td></tr></tbody></table>

		<p>特别留意一下， <span class="text_import2">-9 这个 signal 通常是用在『强制删除一个不正常的工作』时所使用的，
		-15 则是以正常步骤结束一项工作(15也是默认值)</span>，两者之间并不相同呦！举上面的例子来说，
		我用 vi 的时候，不是会产生一个 .filename.swp 的文件吗？
		那么，当使用 -15 这个 signal 时， vi 会尝试以正常的步骤来结束掉该 vi 的工作，
		所以 .filename.swp 会主动的被移除。但若是使用 -9 这个 signal 时，由於该 vi 工作会被强制移除掉，因此， 
		.filename.swp 就会继续存在文件系统当中。这样您应该可以稍微分辨一下了吧？</p>

		<p>其实， kill 的妙用是很无穷的啦！他搭配 signal 所详列的资讯 (用 man 7 signal 去查阅相关数据)
		可以让您有效的管理工作与程序 (Process)，此外，那个 killall 也是同样的用法！
		至於常用的 signal 您至少需要了解 1, 9, 15 这三个 signal 的意义才好。
		此外， signal 除了以数值来表示之外，也可以使用讯号名称喔！
		举例来说，上面的范例二就是一个例子啦！至於 signal number 与名称的对应，
		呵呵，使用 kill -l 就知道啦(L的小写)！</p>

		<p>另外， kill 后面接的数字默认会是 PID ，如果想要管理 bash 的工作控制，就得要加上 %数字 了，
		这点也得特别留意才行喔！</p>
	</div>

	<hr><a name="background_term"></a><img src="./鸟哥的 Linux 私房菜18 -- 程序管理与 SELinux 初探_files/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">离线管理问题</span><br>
	<div class="block2">
		<p>要注意的是，我们在工作管理当中提到的『背景』指的是在终端机模式下可以避免 [crtl]-c 中断的一个情境，
		并不是放到系统的背景去喔！所以，<span class="text_import2">工作管理的背景依旧与终端机有关</span>啦！
		在这样的情况下，如果你是以远程连线方式连接到你的 Linux 主机，并且将工作以 &amp; 的方式放到背景去，
		请问，在工作尚未结束的情况下你离线了，该工作还会继续进行吗？答案是『否』！不会继续进行，而是会被中断掉。</p>

		<a name="nohup"></a>
		<p>那怎么办？如果我的工作需要进行一大段时间，我又不能放置在背景底下，那该如何处理呢？
		首先，你可以参考前一章的 <a href="http://cn.linux.vbird.org/linux_basic/0430cron.php#at">at</a> 来处理即可！因为 at 是将工作放置到系统背景，
		而与终端机无关。如果不想要使用 at 的话，那你也可以尝试使用 nohup 这个命令来处理喔！这个 nohup 
		可以让你在离线或注销系统后，还能够让工作继续进行。他的语法有点像这样：</p>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">nohup [命令与参数]  </span> <span class="term_note">&lt;==在终端机前景中工作</span>
[root@www ~]# <span class="term_command">nohup [命令与参数] &amp;</span> <span class="term_note">&lt;==在终端机背景中工作</span>
</pre></td></tr></tbody></table>

		<p>有够好简单的命令吧！上述命令需要注意的是， nohup 并不支持 bash 内建的命令，因此你的命令必须要是外部命令才行。
		我们来尝试玩一下底下的任务吧！</p>

<table class="term"><tbody><tr><td class="term"><pre><span class="term_hd"># 1. 先编辑一支会『睡著 500 秒』的程序：</span>
[root@www ~]# <span class="term_command">vim sleep500.sh</span>
#!/bin/bash
/bin/sleep 500s
/bin/echo "I have slept 500 seconds."

<span class="term_hd"># 2. 丢到背景中去运行，并且立刻注销系统：</span>
[root@www ~]# <span class="term_command">chmod a+x sleep500.sh</span>
[root@www ~]# <span class="term_command">nohup ./sleep500.sh &amp;</span>
[1] 5074
[root@www ~]# nohup: appending output to ‘nohup.out’ <span class="term_note">&lt;==会告知这个信息！</span>
[root@www ~]# <span class="term_command">exit</span>
</pre></td></tr></tbody></table>

		<p>如果你再次登陆的话，再使用 pstree 去查阅你的程序，会发现 sleep500.sh 还在运行中喔！并不会被中断掉！
		这样了解意思了吗？由於我们的程序最后会输出一个信息，但是 nohup 与终端机其实无关了，
		因此这个信息的输出就会被导向『 ~/nohup.out 』，所以你才会看到上述命令中，当你输入 nohup 后，
		会出现那个提示信息罗。</p>

		<p>如果你想要让在背景的工作在你注销后还能够继续的运行，那么使用 nohup 搭配 &amp; 是不错的运行情境喔！
		可以参考看看！</p>
	</div>
</div>


<hr><a name="process"></a><img src="./鸟哥的 Linux 私房菜18 -- 程序管理与 SELinux 初探_files/logo.png" alt="大标题的图示" width="35" align="middle" height="34"><span class="text_h1">程序管理</span><br>
<div class="block1">
	<p>本章一开始就提到所谓的『程序』的概念，包括程序的触发、子程序与父程序的相关性等等，
	此外，还有那个『程序的相依性』以及所谓的『僵尸程序』等等需要说明的呢！为什么程序管理这么重要呢？这是因为：</p>

	<ul>
	<li>首先，本章一开始就谈到的，我们在操作系统时的各项工作其实都是经过某个 PID 来达成的 (包括你的 bash 环境)，
	因此，能不能进行某项工作，就与该程序的权限有关了。</li>
	<li>再来，如果您的 Linux 系统是个很忙碌的系统，那么当整个系统资源快要被使用光时，
	您是否能够找出最耗系统的那个程序，然后删除该程序，让系统恢复正常呢？</li>
	<li>此外，如果由於某个程序写的不好，导致产生一个有问题的程序在内存当中，您又该如何找出他，然后将他移除呢？</li>
	<li>如果同时有五六项工作在您的系统当中运行，但其中有一项工作才是最重要的，
	该如何让那一项重要的工作被最优先运行呢？</li>
	</ul>

	<p>所以罗，一个称职的系统管理员，必须要熟悉程序的管理流程才行，否则当系统发生问题时，还真是很难解决问题呢！
	底下我们会先介绍如何观察程序与程序的状态，然后再加以程序控制罗！<br><br></p>

	<hr><a name="process_1"></a><img src="./鸟哥的 Linux 私房菜18 -- 程序管理与 SELinux 初探_files/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">程序的观察</span><br>
	<div class="block2">
		<p>既然程序这么重要，那么我们如何查阅系统上面正在运行当中的程序呢？很简单啊！
		利用静态的 ps 或者是动态的 top，还能以 pstree 来查阅程序树之间的关系喔！<br><br></p>

		<a name="ps"></a>
		<hr><ul class="list1"><li class="text_import1">ps ：将某个时间点的程序运行情况撷取下来</li></ul>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">ps aux </span> <span class="term_note">&lt;==观察系统所有的程序数据</span>
[root@www ~]# <span class="term_command">ps -lA </span> <span class="term_note">&lt;==也是能够观察所有系统的数据</span>
[root@www ~]# <span class="term_command">ps axjf</span> <span class="term_note">&lt;==连同部分程序树状态</span>
<span class="term_say">选项与参数：
-A  ：所有的 process 均显示出来，与 -e 具有同样的效用；
-a  ：不与 terminal 有关的所有 process ；
-u  ：有效使用者 (effective user) 相关的 process ；
x   ：通常与 a 这个参数一起使用，可列出较完整资讯。
输出格式规划：
l   ：较长、较详细的将该 PID 的的资讯列出；
j   ：工作的格式 (jobs format)
-f  ：做一个更为完整的输出。</span>
</pre></td></tr></tbody></table>


		<p>鸟哥个人认为 ps 这个命令的 man page 不是很好查阅，因为很多不同的 Unix 都使用这个 ps 来查阅程序状态，
		为了要符合不同版本的需求，所以这个 man page 写的非常的庞大！因此，通常鸟哥都会建议你，直接背两个比较不同的选项，
		<span class="text_import2">一个是只能查阅自己 bash 程序的『 ps -l 』一个则是可以查阅所有系统运行的程序『 
		ps aux 』</span>！注意，你没看错，是『 ps aux 』没有那个减号 (-) ！先来看看关於自己 bash 程序状态的观察：</p>

		<a name="ps_l"></a>
		<ul class="list1"><li class="text_import2">仅观察自己的 bash 相关程序： ps -l</li></ul>

<table class="term"><tbody><tr><td class="term"><pre><span class="term_hd">范例一：将目前属於您自己这次登陆的 PID 与相关资讯列示出来(只与自己的 bash 有关)</span>
[root@www ~]# <span class="term_command">ps -l</span>
<u>F S   UID   PID  PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD</u>
4 S     0 13639 13637  0  75   0 -  1287 wait   pts/1    00:00:00 bash
4 R     0 13700 13639  0  77   0 -  1101 -      pts/1    00:00:00 ps
</pre></td></tr></tbody></table>

		<p>系统整体的程序运行是非常多的，但如果使用 ps -l 则仅列出与你的操作环境 (bash) 有关的程序而已，
		亦即最上一级的父程序会是你自己的 bash 而没有延伸到 init 这支程序去！那么 ps -l 秀出来的数据有哪些呢？
		我们就来观察看看：</p>

		<ul>
		<li>F：代表这个程序旗标 (process flags)，说明这个程序的总结权限，常见号码有：<br>
			<ul>
			<li>若为 4 表示此程序的权限为 root ；</li>
			<li>若为 1 则表示此子程序仅进行<a href="http://cn.linux.vbird.org/linux_basic/0440processcontrol.php#fork_and_exec">复制(fork)而没有实际运行(exec)</a>。</li>
			</ul><br></li>
		<li>S：代表这个程序的状态 (STAT)，主要的状态有：<br>
			<ul class="text_import2">
			<li>R (Running)：该程序正在运行中；</li>
			<li>S (Sleep)：该程序目前正在睡眠状态(idle)，但可以被唤醒(signal)。</li>
			<li>D ：不可被唤醒的睡眠状态，通常这支程序可能在等待 I/O 的情况(ex&gt;列印)</li>
			<li>T ：停止状态(stop)，可能是在工作控制(背景暂停)或除错 (traced) 状态；</li>
			<li>Z (Zombie)：僵尸状态，程序已经终止但却无法被移除至内存外。</li>
			</ul><br></li>

		<li>UID/PID/PPID：代表『此程序被该 UID 所拥有/程序的 PID 号码/此程序的父程序 PID 号码』<br><br></li>

		<li>C：代表 CPU 使用率，单位为百分比；<br><br></li>

		<li>PRI/NI：Priority/Nice 的缩写，代表此程序被 CPU 所运行的优先顺序，数值越小代表该程序越快被 
			CPU 运行。详细的 PRI 与 NI 将在<a href="http://cn.linux.vbird.org/linux_basic/0440processcontrol.php#priority">下一小节</a>说明。<br><br></li>

		<li>ADDR/SZ/WCHAN：都与内存有关，ADDR 是 kernel function，指出该程序在内存的哪个部分，如果是个 running
		的程序，一般就会显示『 - 』 / SZ 代表此程序用掉多少内存 / WCHAN 表示目前程序是否运行中，同样的，
		若为 - 表示正在运行中。<br><br></li>

		<li>TTY：登陆者的终端机位置，若为远程登陆则使用动态终端介面 (pts/n)；<br><br></li>

		<li>TIME：使用掉的 CPU 时间，注意，是此程序实际花费 CPU 运行的时间，而不是系统时间；<br><br></li>

		<li>CMD：就是 command 的缩写，造成此程序的触发程序之命令为何。</li>
		</ul>

		<p>所以你看到的 ps -l 输出信息中，他说明的是：『bash 的程序属於 UID 为 0 的使用者，状态为睡眠 (sleep)，
		之所以为睡眠因为他触发了 ps (状态为 run) 之故。此程序的 PID 为 13639，优先运行顺序为 75 ，
		下达 bash 所取得的终端介面为 pts/1 ，运行状态为等待 (wait) 。』这样已经够清楚了吧？
		您自己尝试解析一下那么 ps 那一行代表的意义为何呢？ ^_^</p>

		<p>接下来让我们使用 ps 来观察一下系统内所有的程序状态吧！</p>

		<a name="ps_aux"></a>
		<ul class="list1"><li class="text_import2">观察系统所有程序： ps aux</li></ul>

<table class="term"><tbody><tr><td class="term"><pre><span class="term_hd">范例二：列出目前所有的正在内存当中的程序：</span>
[root@www ~]# <span class="term_command">ps aux</span>
<u>USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</u>
root         1  0.0  0.0   2064   616 ?        Ss   Mar11   0:01 init [5]
root         2  0.0  0.0      0     0 ?        S&lt;   Mar11   0:00 [migration/0]
root         3  0.0  0.0      0     0 ?        SN   Mar11   0:00 [ksoftirqd/0]
<span class="term_say">.....(中间省略).....</span>
<u>root     13639  0.0  0.2   5148  1508 pts/1    Ss   11:44   0:00 -bash</u>
root     14232  0.0  0.1   4452   876 pts/1    R+   15:52   0:00 ps aux
root     18593  0.0  0.0   2240   476 ?        Ss   Mar14   0:00 /usr/sbin/atd
</pre></td></tr></tbody></table>

		<p>你会发现 ps -l 与 ps aux 显示的项目并不相同！在 ps aux 显示的项目中，各栏位的意义为：</p>

		<ul style="font-family: &#39;细明体&#39;;">
		<li>USER：该 process 属於那个使用者帐号的？</li>
		<li>PID ：该 process 的程序识别码。</li>
		<li>%CPU：该 process 使用掉的 CPU 资源百分比；</li>
		<li>%MEM：该 process 所占用的实体内存百分比；</li>
		<li>VSZ ：该 process 使用掉的虚拟内存量 (Kbytes)</li>
		<li>RSS ：该 process 占用的固定的内存量 (Kbytes)</li>
		<li>TTY ：该 process 是在那个终端机上面运行，若与终端机无关则显示 ?，另外， tty1-tty6
			是本机上面的登陆者程序，若为 pts/0 等等的，则表示为由网络连接进主机的程序。</li>
		<li>STAT：该程序目前的状态，状态显示与 ps -l 的 S 旗标相同 (R/S/T/Z)</li>
		<li>START：该 process 被触发启动的时间；</li>
		<li>TIME ：该 process 实际使用 CPU 运行的时间。</li>
		<li>COMMAND：该程序的实际命令为何？</li>
		</ul>

		<p>一般来说，ps aux 会依照 PID 的顺序来排序显示，我们还是以 13639 那个 PID 那行来说明！该行的意义为『
		root 运行的 bash PID 为 13639，占用了 0.2% 的内存容量百分比，状态为休眠 (S)，该程序启动的时间为 11:44 ，
		且取得的终端机环境为 pts/1 。』与 ps aux 看到的其实是同一个程序啦！这样可以理解吗？
		让我们继续使用 ps 来观察一下其他的资讯吧！</p>

<table class="term"><tbody><tr><td class="term"><pre><span class="term_hd">范例三：以范例一的显示内容，显示出所有的程序：</span>
[root@www ~]# <span class="term_command">ps -lA</span>
F S   UID   PID  PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD
4 S     0     1     0  0  76   0 -   435 -      ?        00:00:01 init
1 S     0     2     1  0  94  19 -     0 ksofti ?        00:00:00 ksoftirqd/0
1 S     0     3     1  0  70  -5 -     0 worker ?        00:00:00 events/0
<span class="term_say">....(以下省略)....
# 你会发现每个栏位与 ps -l 的输出情况相同，但显示的程序则包括系统所有的程序。</span>

<span class="term_hd">范例四：列出类似程序树的程序显示：</span>
[root@www ~]# <span class="term_command">ps axjf</span>
 PPID   PID  PGID   SID TTY      TPGID STAT   UID   TIME COMMAND
    0     1     1     1 ?           -1 Ss       0   0:01 init [5]
<span class="term_say">.....(中间省略).....</span>
    1  4586  4586  4586 ?           -1 Ss       0   0:00 /usr/sbin/sshd
 4586 13637 13637 13637 ?           -1 Ss       0   0:00  \_ sshd: root@pts/1
13637 13639 13639 13639 pts/1    14266 Ss       0   0:00      \_ -bash
13639 14266 14266 13639 pts/1    14266 R+       0   0:00          \_ ps axjf
<span class="term_say">.....(后面省略).....</span>
</pre></td></tr></tbody></table>

		<p>看出来了吧？其实鸟哥在进行一些测试时，都是以网络连线进主机来测试的，所以罗，你会发现其实程序之间是有相关性的啦！
		不过，其实还可以使用 pstree 来达成这个程序树喔！以上面的例子来看，鸟哥是透过 sshd 提供的网络服务取得一个程序，
		该程序提供 bash 给我使用，而我透过 bash 再去运行 ps axjf ！这样可以看的懂了吗？其他各栏位的意义请 man ps 
		(虽然真的很难 man 的出来！) 罗！</p>

<table class="term"><tbody><tr><td class="term"><pre><span class="term_hd">范例五：找出与 cron 与 syslog 这两个服务有关的 PID 号码？</span>
[root@www ~]# <span class="term_command">ps aux | egrep '(cron|syslog)'</span>
root   4286  0.0  0.0  1720   572 ?      Ss  Mar11   0:00 syslogd -m 0
root   4661  0.0  0.1  5500  1192 ?      Ss  Mar11   0:00 crond
root  14286  0.0  0.0  4116   592 pts/1  R+  16:15   0:00 egrep (cron|syslog)
<span class="term_say"># 所以号码是 4286 及 4661 这两个罗！就是这样找的啦！</span>
</pre></td></tr></tbody></table>

		<a name="zombie"></a>
		<p>除此之外，我们必须要知道的是『僵尸 (zombie) 』程序是什么？
		通常，造成僵尸程序的成因是因为该程序应该已经运行完毕，或者是因故应该要终止了，
		但是该程序的父程序却无法完整的将该程序结束掉，而造成那个程序一直存在内存当中。
		如果你发现在某个程序的 CMD 后面还接上 &lt;defunct&gt; 时，就代表该程序是僵尸程序啦，例如：</p>

<table class="term"><tbody><tr><td class="term"><pre>apache  8683  0.0  0.9 83384 9992 ?   Z  14:33   0:00 /usr/sbin/httpd &lt;defunct&gt;
</pre></td></tr></tbody></table>

		<p>当系统不稳定的时候就容易造成所谓的僵尸程序，可能是因为程序写的不好啦，或者是使用者的操作习惯不良等等所造成。
		如果你发现系统中很多僵尸程序时，记得啊！要找出该程序的父程序，然后好好的做个追踪，好好的进行主机的环境最佳化啊！
		看看有什么地方需要改善的，不要只是直接将他 kill 掉而已呢！不然的话，万一他一直产生，那可就麻烦了！ @_@</p>

		<p>事实上，通常僵尸程序都已经无法控管，而直接是交给 init 这支程序来负责了，偏偏 init 是系统第一支运行的程序，
		他是所有程序的父程序！我们无法杀掉该程序的 (杀掉他，系统就死掉了！)，所以罗，如果产生僵尸程序，
		而系统过一阵子还没有办法透过核心非经常性的特殊处理来将该程序删除时，那你只好透过 reboot 
		的方式来将该程序抹去了！<br><br></p>

		<a name="top"></a>
		<hr><ul class="list1"><li class="text_import1">top：动态观察程序的变化</li></ul>

		<p>相对於 ps 是撷取一个时间点的程序状态， top 则可以持续侦测程序运行的状态！使用方式如下：</p>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">top [-d 数字] | top [-bnp]</span>
<span class="term_say">选项与参数：
-d  ：后面可以接秒数，就是整个程序画面升级的秒数。默认是 5 秒；
-b  ：以批量的方式运行 top ，还有更多的参数可以使用喔！
      通常会搭配数据流重导向来将批量的结果输出成为文件。
-n  ：与 -b 搭配，意义是，需要进行几次 top 的输出结果。
-p  ：指定某些个 PID 来进行观察监测而已。
在 top 运行过程当中可以使用的按键命令：
	? ：显示在 top 当中可以输入的按键命令；
	P ：以 CPU 的使用资源排序显示；
	M ：以 Memory 的使用资源排序显示；
	N ：以 PID 来排序喔！
	T ：由该 Process 使用的 CPU 时间累积 (TIME+) 排序。
	k ：给予某个 PID 一个讯号  (signal)
	r ：给予某个 PID 重新制订一个 nice 值。
	q ：离开 top 软件的按键。</span>
</pre></td></tr></tbody></table>

		<p>其实 top 的功能非常多！可以用的按键也非常的多！可以参考 man top 的内部说明文件！
		鸟哥这里仅是列出一些鸟哥自己常用的选项而已。接下来让我们实际观察一下如何使用 top 与 top 的画面吧！</p>

<table class="term"><tbody><tr><td class="term"><pre><span class="term_hd">范例一：每两秒钟升级一次 top ，观察整体资讯：</span>
[root@www ~]# <span class="term_command">top -d 2</span>
top - 17:03:09 up 7 days, 16:16,  1 user,  <u>load average: 0.00, 0.00, 0.00</u>
Tasks:  80 total,   1 running,  79 sleeping,   0 stopped,   <u>0 zombie</u>
Cpu(s):  0.5%us,  0.5%sy,  0.0%ni, 99.0%id,  <u>0.0%wa</u>,  0.0%hi,  0.0%si,  0.0%st
Mem:    742664k total,   681672k used,    60992k free,   125336k buffers
Swap:  1020088k total,       <u>28k used</u>,  1020060k free,   311156k cached
    <span class="term_note">&lt;==如果加入 k 或 r 时，就会有相关的字样出现在这里喔！</span>
<span style="background-color: white; color: black;">  PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND     </span>
14398 root      15   0  2188 1012  816 R  0.5  0.1   0:00.05 top
    1 root      15   0  2064  616  528 S  0.0  0.1   0:01.38 init
    2 root      RT  -5     0    0    0 S  0.0  0.0   0:00.00 migration/0
    3 root      34  19     0    0    0 S  0.0  0.0   0:00.00 ksoftirqd/0
</pre></td></tr></tbody></table>

		<p>top 也是个挺不错的程序观察工具！但不同於 ps 是静态的结果输出， top 这个程序可以持续的监测整个系统的程序工作状态。
		在默认的情况下，每次升级程序资源的时间为 5 秒，不过，可以使用 -d 来进行修改。
		top 主要分为两个画面，上面的画面为整个系统的资源使用状态，基本上总共有六行，显示的内容依序是：</p>

		<ul>
		<li>第一行(top...)：这一行显示的资讯分别为：
			<ul>
			<li>目前的时间，亦即是 17:03:09 那个项目；</li>
			<li>启动到目前为止所经过的时间，亦即是 up 7days, 16:16 那个项目；</li>
			<li>已经登陆系统的使用者人数，亦即是 1 user项目；</li>
			<li>系统在 1, 5, 15 分钟的平均工作负载。我们在<a href="http://cn.linux.vbird.org/linux_basic/0430cron.php#batch">第十六章谈到的 batch</a> 
			工作方式为负载小於 0.8 就是这个负载罗！代表的是 1, 5, 15 分钟，系统平均要负责运行几个程序(工作)的意思。
			越小代表系统越闲置，若高於 1 得要注意你的系统程序是否太过繁复了！</li>
			</ul><br></li>

		<li>第二行(Tasks...)：显示的是目前程序的总量与个别程序在什么状态(running, sleeping, stopped, zombie)。
		比较需要注意的是最后的 zombie 那个数值，如果不是 0 ！好好看看到底是那个 process 变成僵尸了吧？<br><br></li>

		<li>第三行(Cpus...)：显示的是 CPU 的整体负载，每个项目可使用 ? 查阅。需要特别注意的是 %wa ，那个项目代表的是 I/O wait，
		通常你的系统会变慢都是 I/O 产生的问题比较大！因此这里得要注意这个项目耗用 CPU 的资源喔！
		另外，如果是多核心的设备，可以按下数字键『1』来切换成不同 CPU 的负载率。<br><br></li>

		<li>第四行与第五行：表示目前的实体内存与虚拟内存 (Mem/Swap) 的使用情况。
		再次重申，要注意的是 swap 的使用量要尽量的少！如果 swap 被用的很大量，表示系统的实体内存实在不足！<br><br></li>

		<li>第六行：这个是当在 top 程序当中输入命令时，显示状态的地方。</li>
		</ul>

		<p>至於 top 下半部分的画面，则是每个 process 使用的资源情况。比较需要注意的是：</p>

		<ul style="font-family: &#39;细明体&#39;;">
		<li>PID ：每个 process 的 ID 啦！</li>
		<li>USER：该 process 所属的使用者；</li>
		<li>PR  ：Priority 的简写，程序的优先运行顺序，越小越早被运行；</li>
		<li>NI  ：Nice 的简写，与 Priority 有关，也是越小越早被运行；</li>
		<li>%CPU：CPU 的使用率；</li>
		<li>%MEM：内存的使用率；</li>
		<li>TIME+：CPU 使用时间的累加；</li>
		</ul>

		<p>top 默认使用 CPU 使用率 (%CPU) 作为排序的重点，如果你想要使用内存使用率排序，则可以按下『M』，
		若要回复则按下『P』即可。如果想要离开 top 则按下『 q 』吧！如果你想要将 top 的结果输出成为文件时，
		可以这样做：</p>

<table class="term"><tbody><tr><td class="term"><pre><span class="term_hd">范例二：将 top 的资讯进行 2 次，然后将结果输出到 /tmp/top.txt</span>
[root@www ~]# <span class="term_command">top -b -n 2 &gt; /tmp/top.txt</span>
<span class="term_say"># 这样一来，嘿嘿！就可以将 top 的资讯存到 /tmp/top.txt 文件中了。</span>
</pre></td></tr></tbody></table>

		<p>这玩意儿很有趣！可以帮助你将某个时段 top 观察到的结果存成文件，可以用在你想要在系统背景底下运行。
		由於是背景底下运行，与终端机的萤幕大小无关，因此可以得到全部的程序画面！那如果你想要观察的程序 CPU
		与内存使用率都很低，结果老是无法在第一行显示时，该怎办？我们可以仅观察单一程序喔！如下所示：</p>

<table class="term"><tbody><tr><td class="term"><pre><span class="term_hd">范例三：我们自己的 bash PID 可由 $$ 变量取得，请使用 top 持续观察该 PID</span>
[root@www ~]# <span class="term_command">echo $$</span>
13639  <span class="term_note">&lt;==就是这个数字！他是我们 bash 的 PID</span>
[root@www ~]# <span class="term_command">top -d 2 -p 13639</span>
top - 17:31:56 up 7 days, 16:45,  1 user,  load average: 0.00, 0.00, 0.00
Tasks:   1 total,   0 running,   1 sleeping,   0 stopped,   0 zombie
Cpu(s):  0.0%us,  0.0%sy,  0.0%ni,100.0%id,  0.0%wa,  0.0%hi,  0.0%si,  0.0%st
Mem:    742664k total,   682540k used,    60124k free,   126548k buffers
Swap:  1020088k total,       28k used,  1020060k free,   311276k cached

<span style="background-color: white; color: black;">  PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND</span>
<u>13639</u> root      15   0  5148 1508 1220 S  0.0  0.2   0:00.18 bash
</pre></td></tr></tbody></table>

		<p>看到没！就只会有一支程序给你看！很容易观察吧！好，那么如果我想要在 top 底下进行一些动作呢？
		比方说，修改 NI 这个数值呢？可以这样做：</p>

<table class="term"><tbody><tr><td class="term"><pre><span class="term_hd">范例四：承上题，上面的 NI 值是 0 ，想要改成 10 的话？</span>
<span class="term_say"># 在范例三的 top 画面当中直接按下 r 之后，会出现如下的图样！</span>
top - 17:34:24 up 7 days, 16:47,  1 user,  load average: 0.00, 0.00, 0.00
Tasks:   1 total,   0 running,   1 sleeping,   0 stopped,   0 zombie
Cpu(s):  0.0%us,  0.0%sy,  0.0%ni, 99.5%id,  0.0%wa,  0.0%hi,  0.5%si,  0.0%st
Mem:    742664k total,   682540k used,    60124k free,   126636k buffers
Swap:  1020088k total,       28k used,  1020060k free,   311276k cached
PID to renice: <span class="term_command">13639</span>  <span class="term_note">&lt;==按下 r 然后输入这个 PID 号码</span>
<span style="background-color: white; color: black;">  PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND</span>
<u>13639</u> root      15   0  5148 1508 1220 S  0.0  0.2   0:00.18 bash
</pre></td></tr></tbody></table>

		<p>在你完成上面的动作后，在状态列会出现如下的资讯：</p>

<table class="term"><tbody><tr><td class="term"><pre>Renice PID 13639 to value: <span class="term_command">10 </span>  <span class="term_note">&lt;==这是 nice 值</span>
<span style="background-color: white; color: black;">  PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND</span>
</pre></td></tr></tbody></table>

		<p>接下来你就会看到如下的显示画面！</p>

<table class="term"><tbody><tr><td class="term"><pre>top - 17:38:58 up 7 days, 16:52,  1 user,  load average: 0.00, 0.00, 0.00
Tasks:   1 total,   0 running,   1 sleeping,   0 stopped,   0 zombie
Cpu(s):  0.0%us,  0.0%sy,  0.0%ni,100.0%id,  0.0%wa,  0.0%hi,  0.0%si,  0.0%st
Mem:    742664k total,   682540k used,    60124k free,   126648k buffers
Swap:  1020088k total,       28k used,  1020060k free,   311276k cached

<span style="background-color: white; color: black;">  PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND</span>
13639 root      <u>26  10</u>  5148 1508 1220 S  0.0  0.2   0:00.18 bash
</pre></td></tr></tbody></table>

		<p>看到不同处了吧？底线的地方就是修改了之后所产生的效果！一般来说，如果鸟哥想要找出最损耗 CPU 
		资源的那个程序时，大多使用的就是 top 这支程序啦！然后强制以 CPU 使用资源来排序 (在 top 当中按下 P 即可)，
		就可以很快的知道啦！ ^_^。多多爱用这个好用的东西喔！<br><br></p>

		<a name="pstree"></a>
		<hr><ul class="list1"><li class="text_import1">pstree</li></ul>


<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">pstree [-A|U] [-up]</span>
<span class="term_say">选项与参数：
-A  ：各程序树之间的连接以 ASCII 字节来连接；
-U  ：各程序树之间的连接以万国码的字节来连接。在某些终端介面下可能会有错误；
-p  ：并同时列出每个 process 的 PID；
-u  ：并同时列出每个 process 的所属帐号名称。</span>

<span class="term_hd">范例一：列出目前系统上面所有的程序树的相关性：</span>
[root@www ~]# <span class="term_command">pstree -A</span>
init-+-acpid
     |-atd
     |-auditd-+-audispd---{audispd}  <span class="term_note">&lt;==这行与底下一行为 auditd 分出来的子程序</span>
     |        `-{auditd}
     |-automount---<u>4*[{automount}]</u>   <span class="term_note">&lt;==默认情况下，相似的程序会以数字显示</span>
<span class="term_say">....(中间省略)....</span>
     |-sshd---sshd---bash---pstree   <span class="term_note">&lt;==就是我们命令运行的那个相依性！</span>
<span class="term_say">....(底下省略)....</span>
<span class="term_say"># 注意一下，为了节省版面，所以鸟哥已经删去很多程序了！</span>

<span class="term_hd">范例二：承上题，同时秀出 PID 与 users </span>
[root@www ~]# <span class="term_command">pstree -Aup</span>
init(1)-+-acpid(4555)
        |-atd(18593)
        |-auditd(4256)-+-audispd(4258)---{audispd}(4261)
        |              `-{auditd}(4257)
        |-automount(4536)-+-{automount}(4537) <span class="term_note">&lt;==程序相似但 PID 不同！</span>
        |                 |-{automount}(4538)
        |                 |-{automount}(4541)
        |                 `-{automount}(4544)
<span class="term_say">....(中间省略)....</span>
        |-sshd(4586)---sshd(16903)---bash(16905)---pstree(16967)
<span class="term_say">....(中间省略)....</span>
        |-xfs(4692,<u>xfs</u>)   <span class="term_note">&lt;==因为此程序拥有者并非运行 pstree 者！所以列出帐号</span>
<span class="term_say">....(底下省略)....</span>
<span class="term_say"># 在括号 () 内的即是 PID 以及该程序的 owner 喔！不过，由於我是使用 
# root 的身份运行此一命令，所以属於 root 的程序就不会显示出来啦！</span>
</pre></td></tr></tbody></table>

		<p>如果要找程序之间的相关性，这个 pstree 真是好用到不行！直接输入 pstree 
		可以查到程序相关性，如上表所示，还会使用线段将相关性程序连结起来哩！
		一般连结符号可以使用 ASCII 码即可，但有时因为语系问题会主动的以 Unicode 的符号来连结，
		但因为可能终端机无法支持该编码，或许会造成乱码问题。因此可以加上 -A 选项来克服此类线段乱码问题。</p>

		<p>由 pstree 的输出我们也可以很清楚的知道，<span class="text_import2">所有的程序都是依附在 init 这支程序底下的！
		仔细看一下，这支程序的 PID 是一号喔！因为他是由 Linux 核心所主动呼叫的第一支程序！所以 PID 就是一号了</span>。
		这也是我们刚刚提到<a href="http://cn.linux.vbird.org/linux_basic/0440processcontrol.php#zombie">僵尸程序</a>时有提到，为啥发生僵尸程序需要重新启动？
		因为 init 要重新启动，而重新启动 init 就是 reboot 罗！</p>

		<p>如果还想要知道 PID 与所属使用者，加上 -u 及 -p 两个参数即可。我们前面不是一直提到，
		如果子程序挂点或者是老是砍不掉子程序时，该如何找到父程序吗？呵呵！用这个 pstree 就对了！ ^_^</p>
	</div>

	<hr><a name="process_2"></a><img src="./鸟哥的 Linux 私房菜18 -- 程序管理与 SELinux 初探_files/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">程序的管理</span><br>
	<div class="block2">
		<p>程序之间是可以互相控制的！举例来说，你可以关闭、重新启动服务器软件，服务器软件本身是个程序，
		你既然可以让她关闭或启动，当然就是可以控制该程序啦！<span class="text_import2">那么程序是如何互相管理的呢？其实是透过给予该程序一个讯号 (signal)
		去告知该程序你想要让她作什么！</span>因此这个讯号就很重要啦！</p>

		<a name="signal"></a>
		<p>我们也在本章之前的 <a href="http://cn.linux.vbird.org/linux_basic/0440processcontrol.php#background">bash 工作管理</a>当中提到过，
		要给予某个已经存在背景中的工作某些动作时，是直接给予一个讯号给该工作号码即可。那么到底有多少 signal 呢？
		你可以使用 kill -l (小写的 L ) 或者是 man 7 signal 都可以查询到！主要的讯号代号与名称对应及内容是：</p>

<table bgcolor="lightyellow" border="1" cellpadding="3" cellspacing="0" width="95%">
<tbody><tr align="center" bgcolor="#182448"><td width="30"><font color="#FFFFFF">代号</font></td><td width="50"><font color="#FFFFFF">名称</font></td><td><font color="#FFFFFF">内容</font></td></tr>
<tr><td align="center">1</td><td align="center">SIGHUP</td><td>启动被终止的程序，可让该 PID 重新读取自己的配置档，类似重新启动</td></tr>
<tr><td align="center">2</td><td align="center">SIGINT</td><td>相当於用键盘输入 [ctrl]-c 来中断一个程序的进行</td></tr>
<tr><td align="center">9</td><td align="center">SIGKILL</td><td>代表强制中断一个程序的进行，如果该程序进行到一半，
	那么尚未完成的部分可能会有『半产品』产生，类似 vim会有 .filename.swp 保留下来。</td></tr>
<tr><td align="center">15</td><td align="center">SIGTERM</td><td>以正常的结束程序来终止该程序。由於是正常的终止，
	所以后续的动作会将他完成。不过，如果该程序已经发生问题，就是无法使用正常的方法终止时，
	输入这个 signal 也是没有用的。</td></tr>
<tr><td align="center">17</td><td align="center">SIGSTOP</td><td>相当於用键盘输入 [ctrl]-z 来暂停一个程序的进行</td></tr>
</tbody></table>

		<p>上面仅是常见的 signal 而已，更多的讯号资讯请自行 man 7 signal 吧！一般来说，你只要记得『1, 9, 
		15』这三个号码的意义即可。那么我们如何传送一个讯号给某个程序呢？就透过 kill 或 killall 吧！底下分别来看看：
		<br><br></p>

		<a name="kill"></a>
		<hr><ul class="list1"><li class="text_import1">kill -signal PID</li></ul>

		<p>kill 可以帮我们将这个 signal 传送给某个工作 (%jobnumber) 或者是某个 PID (直接输入数字)。
		要再次强调的是： <span class="text_import2">kill 后面直接加数字与加上 %number 的情况是不同的</span>！
		这个很重要喔！因为工作控制中有 1 号工作，但是 PID 1 号则是专指『 init 』这支程序！你怎么可以将 init 关闭呢？
		关闭 init ，你的系统就当掉了啊！所以记得那个 % 是专门用在工作控制的喔！
		我们就活用一下 kill 与刚刚上面提到的 ps 来做个简单的练习吧！</p>

<table border="1" cellpadding="5" cellspacing="0" width="90%"><tbody><tr><td>
例题：<div class="block2">
以 ps 找出 syslog 这个程序的 PID 后，再使用 kill 传送信息，使得 syslog 可以重新读取配置档。
</div>
答：<div class="block2">
由於需要重新读取配置档，因此 signal 是 1 号。至於找出 syslog 的 PID 可以是这样做：
<blockquote style="font-family: &#39;细明体&#39;; font-size: 10pt; color: rgb(0, 0, 136);">ps aux | grep 'syslog' | grep -v 'grep'| awk '{print $2}'</blockquote>
接下来则是实际使用 kill -1 PID，因此，整串命令会是这样：
<blockquote style="font-family: &#39;细明体&#39;; font-size: 9pt; color: rgb(0, 0, 136);">kill -SIGHUP $(ps aux|grep 'syslog'|grep -v 'grep'|awk '{print $2}')</blockquote>
如果要确认有没有重新启动 syslog ，可以参考登录档的内容，使用如下命令查阅：
<blockquote style="font-family: &#39;细明体&#39;; font-size: 10pt; color: rgb(0, 0, 136);">tail -5 /var/log/messages</blockquote>
如果你有看到类似『Mar 19 15:08:20 www syslogd 1.4.1: restart』之类的字样，就是表示 syslogd 在 3/19 有重新启动 (restart) 过了！
</div>
</td></tr></tbody></table>

		<p>了解了这个用法以后，如果未来你想要将某个莫名其妙的登陆者的连线删除的话，就可以透过使用 pstree -p 找到相关程序，
		然后再以 kill -9 将该程序删除，该条连线就会被踢掉了！这样很简单吧！<br><br></p>

		<a name="killall"></a>
		<hr><ul class="list1"><li class="text_import1">killall -signal 命令名称</li></ul>

		<p>由於 kill 后面必须要加上 PID (或者是 job number)，所以，通常 kill 都会配合
		<a href="http://cn.linux.vbird.org/linux_basic/0440processcontrol.php#ps">ps</a>, <a href="http://cn.linux.vbird.org/linux_basic/0440processcontrol.php#pstree">pstree</a> 等命令，因为我们必须要找到相对应的那个程序的 
		ID 嘛！但是，如此一来，很麻烦～有没有可以利用『下达命令的名称』来给予讯号的？举例来说，能不能直接将 syslog 
		这个程序给予一个 SIGHUP 的讯号呢？可以的！用 killall 吧！</p>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">killall [-iIe] [command name]</span>
<span class="term_say">选项与参数：
-i  ：interactive 的意思，互动式的，若需要删除时，会出现提示字节给使用者；
-e  ：exact 的意思，表示『后面接的 command name 要一致』，但整个完整的命令
      不能超过 15 个字节。
-I  ：命令名称(可能含参数)忽略大小写。</span>

<span class="term_hd">范例一：给予 syslogd 这个命令启动的 PID 一个 SIGHUP 的讯号</span>
[root@www ~]# <span class="term_command">killall -1 syslogd</span>
<span class="term_say"># 如果用 ps aux 仔细看一下，syslogd 才是完整的命令名称。但若包含整个参数，
# 则 syslogd -m 0 才是完整的呢！</span>

<span class="term_hd">范例二：强制终止所有以 httpd 启动的程序</span>
[root@www ~]# <span class="term_command">killall -9 httpd</span>

<span class="term_hd">范例三：依次询问每个 bash 程序是否需要被终止运行！</span>
[root@www ~]# <span class="term_command">killall -i -9 bash</span>
Kill bash(16905) ? (y/N) <span class="term_command">n</span> <span class="term_note">&lt;==这个不杀！</span>
Kill bash(17351) ? (y/N) <span class="term_command">y</span> <span class="term_note">&lt;==这个杀掉！</span>
<span class="term_say"># 具有互动的功能！可以询问你是否要删除 bash 这个程序。要注意，若没有 -i 的参数，
# 所有的 bash 都会被这个 root 给杀掉！包括 root 自己的 bash 喔！ ^_^</span>
</pre></td></tr></tbody></table>

		<p>总之，要删除某个程序，我们可以使用 PID 或者是启动该程序的命令名称，
		而如果要删除某个服务呢？呵呵！最简单的方法就是利用 killall ，
		因为他可以将系统当中所有以某个命令名称启动的程序全部删除。
		举例来说，上面的范例二当中，系统内所有以 httpd 启动的程序，就会通通的被删除啦！ ^_^</p>
	</div>

	<hr><a name="priority"></a><img src="./鸟哥的 Linux 私房菜18 -- 程序管理与 SELinux 初探_files/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">关於程序的运行顺序</span><br>
	<div class="block2">
		<p>我们知道 Linux 是多人多工的环境，由 <a href="http://cn.linux.vbird.org/linux_basic/0440processcontrol.php#top">top</a> 的输出结果我们也发现，
		系统同时间有非常多的程序在运行中，只是绝大部分的程序都在休眠 (sleeping) 状态而已。
		想一想，如果所有的程序同时被唤醒，那么 CPU 应该要先处理那个程序呢？也就是说，那个程序被运行的优先序比较高？
		这就得要考虑到程序的优先运行序 (Priority) 与 CPU 排程罗！</p>

		<div style="padding: 10pt 0pt;" align="right"><table width="90%"><tbody><tr><td><b>Tips:</b><br><span style="color: rgb(0, 144, 0);"><font size="-1">		CPU 排程与前一章的例行性工作排程并不一样。 CPU 排程指的是每支程序被 CPU 运行的演算守则，
		而例行性工作排程则是将某支程序安排在某个时间再交由系统运行。 CPU 排程与操作系统较具有相关性！
		</font></span></td><td><img src="./鸟哥的 Linux 私房菜18 -- 程序管理与 SELinux 初探_files/vbird_face.gif" alt="鸟哥的图示" title="鸟哥的图示"></td></tr></tbody></table></div>
		<a name="pri"></a>
		<hr><ul class="list1"><li class="text_import1">Priority 与 Nice 值</li></ul>

		<p>我们知道 CPU 一秒钟可以运行多达数 G 的微命令次数，透过核心的 CPU 排程可以让各程序被 CPU 所切换运行，
		因此每个程序在一秒钟内或多或少都会被 CPU 运行部分的命令码。如果程序都是集中在一个伫列中等待 CPU 的运行，
		而不具有优先顺序之分，也就是像我们去游乐场玩热门游戏需要排队一样，每个人都是照顺序来！
		你玩过一遍后还想再玩 (没有运行完毕)，请到后面继续排队等待。情况有点像底下这样：</p>

		<center><img src="./鸟哥的 Linux 私房菜18 -- 程序管理与 SELinux 初探_files/pri_cpu_no.gif" alt="并没有优先顺序的程序伫列示意图" title="并没有优先顺序的程序伫列示意图" border="0"><br>
		图 3.3.1、并没有优先顺序的程序伫列示意图<br></center>

		<p>上图中假设 pro1, pro2 是紧急的程序， pro3, pro4 是一般的程序，在这样的环境中，由於不具有优先顺序，
		唉啊！pro1, pro2 还是得要继续等待而没有优待呢！如果 pro3, pro4 的工作又臭又长！那么紧急的 pro1, pro2 
		就得要等待个老半天才能够完成！真麻烦啊！所以罗，我们想要将程序分优先顺序啦！如果优先序较高则运行次数可以较多次，
		而不需要与较慢优先的程序抢位置！我们可以将程序的优先顺序与 CPU 排程进行如下图的解释：</p>

		<center><img src="./鸟哥的 Linux 私房菜18 -- 程序管理与 SELinux 初探_files/pri_cpu_yes.gif" alt="具有优先顺序的程序伫列示意图" title="具有优先顺序的程序伫列示意图" border="0"><br>
		图 3.3.2、具有优先顺序的程序伫列示意图<br></center>

		<p>如上图所示，具高优先权的 pro1, pro2 可以被取用两次，而较不重要的 pro3, pro4 则运行次数较少。
		如此一来 pro1, pro2 就可以较快被完成啦！要注意，上图仅是示意图，并非较优先者一定会被运行两次啦！
		为了要达到上述的功能，我们 Linux 给予程序一个所谓的『优先运行序 (priority, PRI)』，
		这个 <span class="text_import2">PRI 值越低代表越优先的意思。不过这个 PRI 值是由核心动态调整的，
		使用者无法直接调整 PRI 值的。</span>先来瞧瞧 PRI 曾在哪里出现？</p>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">ps -l</span>
F S   UID   PID  PPID  C <span class="term_write">PRI  NI</span> ADDR SZ WCHAN  TTY          TIME CMD
4 S     0 18625 18623  2  <span class="term_write">75   0</span> -  1514 wait   pts/1    00:00:00 bash
4 R     0 18653 18625  0  <span class="term_write">77   0</span> -  1102 -      pts/1    00:00:00 ps
</pre></td></tr></tbody></table>

		<p>由於 PRI 是核心动态调整的，我们使用者也无权去干涉 PRI ！那如果你想要调整程序的优先运行序时，就得要透过 Nice
		值了！Nice 值就是上表的 NI 啦！一般来说， PRI 与 NI 的相关性如下：</p>

		<blockquote class="text_import2">PRI(new) = PRI(old) + nice</blockquote>

		<p>不过你要特别留意到，如果原本的 PRI 是 50 ，并不是我们给予一个 nice = 5 ，就会让 PRI 变成 55  喔！
		因为 PRI 是系统『动态』决定的，所以，虽然 nice 值是可以影响 PRI ，不过，
		最终的 PRI 仍是要经过系统分析后才会决定的。另外， nice 值是有正负的喔，而既然 PRI 越小越早被运行，
		所以，<span class="text_import2">当 nice 值为负值时，那么该程序就会降低 PRI 
		值，亦即会变的较优先被处理。</span>此外，你必须要留意到：</p>

		<ul>
		<li>nice 值可调整的范围为 -20 ~ 19 ；</li>
		<li>root 可随意调整自己或他人程序的 Nice 值，且范围为 -20 ~ 19 ；</li>
		<li>一般使用者仅可调整自己程序的 Nice 值，且范围仅为 0 ~ 19 (避免一般用户抢占系统资源)；</li>
		<li>一般使用者仅可将 nice 值越调越高，例如本来 nice 为 5 ，则未来仅能调整到大於 5；</li>
		</ul>

		<p>这也就是说，要调整某个程序的优先运行序，就是『调整该程序的 nice 值』啦！那么如何给予某个程序 nice
		值呢？有两种方式，分别是：</p>

		<ul class="text_import2">
		<li>一开始运行程序就立即给予一个特定的 nice 值：用 nice 命令；</li>
		<li>调整某个已经存在的 PID 的 nice 值：用 renice 命令。</li></ul><br>

		<a name="nice"></a>
		<hr><ul class="list1"><li class="text_import1">nice ：新运行的命令即给予新的 nice 值</li></ul>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">nice [-n 数字] command</span>
<span class="term_say">选项与参数：
-n  ：后面接一个数值，数值的范围 -20 ~ 19。</span>

<span class="term_hd">范例一：用 root 给一个 nice 值为 -5 ，用於运行 vi ，并观察该程序！</span>
[root@www ~]# <span class="term_command">nice -n -5 vi &amp;</span>
[1] 18676
[root@www ~]# <span class="term_command">ps -l</span>
F S   UID   PID  PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD
4 S     0 18625 18623  0  75   0 -  1514 wait   pts/1    00:00:00 bash
4 T     0 18676 18625  0  <span class="term_write">72  -5</span> -  1242 finish pts/1    00:00:00 vi
4 R     0 18678 18625  0  77   0 -  1101 -      pts/1    00:00:00 ps
<span class="term_say"># 原本的 bash PRI 为 75  ，所以 vi 默认应为 75。不过由於给予 nice  为 -5 ，
# 因此 vi 的 PRI 降低了！但并非降低到 70 ，因为核心还会动态调整！</span>

[root@www ~]# <span class="term_command">kill -9 %1</span> <span class="term_note">&lt;==测试完毕将 vi 关闭</span>
</pre></td></tr></tbody></table>

		<p>就如同前面说的， nice 是用来调整程序的运行优先顺序！这里只是一个运行的范例罢了！
		通常什么时候要将 nice 值调大呢？举例来说，系统的背景工作中，
		某些比较不重要的程序之进行：例如备份工作！由於备份工作相当的耗系统资源，
		这个时候就可以将备份的命令之 nice 值调大一些，可以使系统的资源分配的更为公平！<br><br></p>

		<a name="renice"></a>
		<hr><ul class="list1"><li class="text_import1">renice ：已存在程序的 nice 重新调整</li></ul>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">renice [number] PID</span>
<span class="term_say">选项与参数：
PID ：某个程序的 ID 啊！</span>

<span class="term_hd">范例一：找出自己的 bash PID ，并将该 PID 的 nice 调整到 10</span>
[root@www ~]# <span class="term_command">ps -l</span>
F S   UID   PID  PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD
4 S     0 <span class="term_write">18625</span> 18623  0  <span class="term_write">75   0</span> -  1514 wait   pts/1    00:00:00 bash
4 R     0 18712 18625  0  77   0 -  1102 -      pts/1    00:00:00 ps

[root@www ~]# <span class="term_command">renice 10 18625</span>
18625: old priority 0, new priority 10

[root@www ~]# <span class="term_command">ps -l</span>
F S   UID   PID  PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD
4 S     0 18625 18623  0  <span class="term_write">85  10</span> -  1514 wait   pts/1    00:00:00 bash
4 R     0 18715 18625  0  <span class="term_write">87  10</span> -  1102 -      pts/1    00:00:00 ps
</pre></td></tr></tbody></table>

		<p>如果要调整的是已经存在的某个程序的话，那么就得要使用 renice 了。使用的方法很简单，
		renice 后面接上数值及 PID 即可。因为后面接的是 PID ，所以你务必要以 ps 
		或者其他程序观察的命令去找出 PID 才行啊！</p>

		<p>由上面这个范例当中我们也看的出来，虽然修改的是 bash 那个程序，但是该程序所触发的 ps 
		命令当中的 nice 也会继承而为 10 喔！了解了吧！整个 nice 值是可以在父程序 --&gt; 子程序之间传递的呢！
		另外，除了 renice 之外，其实那个 <a href="http://cn.linux.vbird.org/linux_basic/0440processcontrol.php#top">top</a> 同样的也是可以调整 nice 值的！</p>
	</div>

	<hr><a name="process_3"></a><img src="./鸟哥的 Linux 私房菜18 -- 程序管理与 SELinux 初探_files/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">系统资源的观察</span><br>
	<div class="block2">
		<p>除了系统的程序之外，我们还必须就系统的一些资源进行检查啊！举例来说，我们使用 top 
		可以看到很多系统的资源对吧！那么，还有没有其他的工具可以查阅的？
		当然有啊！底下这些工具命令可以玩一玩！<br><br></p>

		<a name="free"></a>
		<hr><ul class="list1"><li class="text_import1">free ：观察内存使用情况</li></ul>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">free [-b|-k|-m|-g] [-t]</span>
<span class="term_say">选项与参数：
-b  ：直接输入 free 时，显示的单位是 Kbytes，我们可以使用 b(bytes), m(Mbytes)
      k(Kbytes), 及 g(Gbytes) 来显示单位喔！
-t  ：在输出的最终结果，显示实体内存与 swap 的总量。</span>

<span class="term_hd">范例一：显示目前系统的内存容量</span>
[root@www ~]# <span class="term_command">free -m</span>
          total       used    free   shared   buffers    cached
Mem:        725        666      59        0       132       287
-/+ buffers/cache:     245     479
Swap:       996          0     996
</pre></td></tr></tbody></table>

		<p>仔细看看，我的系统当中有 725MB 左右的实体内存，我的 swap 有 1GB 左右，
		那我使用 free -m 以 MBytes 来显示时，就会出现上面的资讯。Mem 那一行显示的是实体内存的量，
		Swap 则是虚拟内存的量。 total 是总量， used 是已被使用的量， free 则是剩余可用的量。
		后面的 shared/buffers/cached 则是在已被使用的量当中，用来作为缓冲及缓存的量。</p>

		<p>仔细的看到范例一的输出喔，我们的 Linux 测试用主机是很平凡的，根本没有什么工作，
		但是，我的实体内存是几乎被用光光的情况呢！不过，至少有 132MB 用在缓冲记忆 (buffers) 工作，
		287MB 则用在缓存 (cached) 工作，也就是说，系统是『很有效率的将所有的内存用光光』，
		目的是为了让系统的存取效能加速啦！</p>

		<p>很多朋友都会问到这个问题『我的系统明明很轻松，为何内存会被用光光？』现在了了吧？
		被用光是正常的！而需要注意的反而是 swap 的量。一般来说， swap 最好不要被使用，尤其 swap 最好不要被使用超过 20% 以上，
		如果您发现 swap 的用量超过 20% ，那么，最好还是买实体内存来插吧！
		因为， Swap 的效能跟实体内存实在差很多，而系统会使用到 swap ，
		绝对是因为实体内存不足了才会这样做的！如此，了解吧！</p>

		<div style="padding: 10pt 0pt;" align="right"><table width="90%"><tbody><tr><td><b>Tips:</b><br><span style="color: rgb(0, 144, 0);"><font size="-1">		Linux 系统为了要加速系统效能，所以会将最常使用到的或者是最近使用到的文件数据缓存 (cache) 下来，
		这样未来系统要使用该文件时，就直接由内存中搜寻取出，而不需要重新读取硬盘，速度上面当然就加快了！
		因此，实体内存被用光是正常的喔！
		</font></span></td><td><img src="./鸟哥的 Linux 私房菜18 -- 程序管理与 SELinux 初探_files/vbird_face.gif" alt="鸟哥的图示" title="鸟哥的图示"></td></tr></tbody></table></div>
		<a name="uname"></a>
		<hr><ul class="list1"><li class="text_import1">uname：查阅系统与核心相关资讯</li></ul>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">uname [-asrmpi]</span>
<span class="term_say">选项与参数：
-a  ：所有系统相关的资讯，包括底下的数据都会被列出来；
-s  ：系统核心名称
-r  ：核心的版本
-m  ：本系统的硬件名称，例如 i686 或 x86_64 等；
-p  ：CPU 的类型，与 -m 类似，只是显示的是 CPU 的类型！
-i  ：硬件的平台 (ix86)</span>

<span class="term_hd">范例一：输出系统的基本资讯</span>
[root@www ~]# <span class="term_command">uname -a</span>
Linux www.vbird.tsai 2.6.18-92.el5 #1 SMP Tue Jun 10 18:49:47 EDT 2008 i686
i686 i386 GNU/Linux
</pre></td></tr></tbody></table>

		<p>这个咚咚我们前面使用过很多次了喔！uname 可以列出目前系统的核心版本、
		主要硬件平台以及 CPU 类型等等的资讯。以上面范例一的状态来说，我的 Linux 
		主机使用的核心名称为 Linux，而主机名称为 www.vbird.tsai，核心的版本为
		2.6.18-92.el5 ，该核心版本创建的日期为 2008/6/10，适用的硬件平台为 i386 以上等级的硬件平台喔。<br><br></p>

		<a name="uptime"></a>
		<hr><ul class="list1"><li class="text_import1">uptime：观察系统启动时间与工作负载</li></ul>

		<p>这个命令很单纯呢！就是显示出目前系统已经启动多久的时间，以及 1, 5, 15 
		分钟的平均负载就是了。还记得 <a href="http://cn.linux.vbird.org/linux_basic/0440processcontrol.php#top">top</a> 吧？没错啦！这个 uptime 可以显示出 top 画面的最上面一行！</p>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">uptime</span>
 15:39:13 up 8 days, 14:52,  1 user,  load average: 0.00, 0.00, 0.00
<span class="term_say"># <a href="http://cn.linux.vbird.org/linux_basic/0440processcontrol.php#top">top</a> 这个命令已经谈过相关资讯，不再聊！</span>
</pre></td></tr></tbody></table><br>


		<a name="netstat"></a>
		<hr><ul class="list1"><li class="text_import1">netstat ：追踪网络或插槽档</li></ul>

		<p>这个 netstat 也是挺好玩的，其实这个命令比较常被用在网络的监控方面，不过，在程序管理方面也是需要了解的啦！
		这个命令的运行如下所示：基本上， netstat 的输出分为两大部分，分别是网络与系统自己的程序相关性部分：</p>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">netstat -[atunlp]</span>
<span class="term_say">选项与参数：
-a  ：将目前系统上所有的连线、监听、Socket 数据都列出来
-t  ：列出 tcp 网络封包的数据
-u  ：列出 udp 网络封包的数据
-n  ：不以程序的服务名称，以埠号 (port number) 来显示；
-l  ：列出目前正在网络监听 (listen) 的服务；
-p  ：列出该网络服务的程序 PID </span>

<span class="term_hd">范例一：列出目前系统已经创建的网络连线与 unix socket 状态</span>
[root@www ~]# <span class="term_command">netstat</span>
<u>Active Internet connections (w/o servers)</u> <span class="term_note">&lt;==与网络较相关的部分</span>
Proto Recv-Q Send-Q Local Address        Foreign Address      State
tcp        0    132 192.168.201.110:ssh  192.168.:vrtl-vmf-sa ESTABLISHED
<u>Active UNIX domain sockets (w/o servers)</u>  <span class="term_note">&lt;==与本机的程序自己的相关性(非网络)</span>
Proto RefCnt Flags       Type       State         I-Node Path
unix  20     [ ]         DGRAM                    9153   /dev/log
unix  3      [ ]         STREAM     CONNECTED     13317  /tmp/.X11-unix/X0
unix  3      [ ]         STREAM     CONNECTED     13233  /tmp/.X11-unix/X0
unix  3      [ ]         STREAM     CONNECTED     13208  /tmp/.font-unix/fs7100
<span class="term_say">....(中间省略)....</span>
</pre></td></tr></tbody></table>

		<p>在上面的结果当中，显示了两个部分，分别是网络的连线以及 linux 上面的 socket 程序相关性部分。
		我们先来看看网际网络连线情况的部分：</p>

		<ul>
		<li>Proto ：网络的封包协议，主要分为 TCP 与 UDP 封包，相关数据请参考<a href="http://cn.linux.vbird.org/linux_server">服务器篇</a>；</li>
		<li>Recv-Q：非由使用者程序连结到此 socket 的复制的总 bytes 数；</li>
		<li>Send-Q：非由远程主机传送过来的 acknowledged 总 bytes 数；</li>
		<li>Local Address  ：本地端的 IP:port 情况</li>
		<li>Foreign Address：远程主机的 IP:port 情况</li>
		<li>State ：连线状态，主要有创建(ESTABLISED)及监听(LISTEN)；</li>
		</ul>

		<p>我们看上面仅有一条连线的数据，他的意义是：『透过 TCP 封包的连线，远程的 192.168.:vrtl.. 连线到本地端的
		192.168.201.110:ssh ，这条连线状态是创建 (ESTABLISHED) 的状态！』至於更多的网络环境说明，
		就得到<a href="http://cn.linux.vbird.org/linux_server">鸟哥的另一本服务器篇</a>查阅罗！</p>

		<p>除了网络上的连线之外，其实 Linux 系统上面的程序是可以接收不同程序所发送来的资讯，那就是 Linux 上头的插槽档 
		(socket file)。我们在<a href="http://cn.linux.vbird.org/linux_basic/0210filepermission.php#filepermission_type">第六章的文件种类</a>有稍微提到 socket 文件，
		但当时未谈到程序的概念，所以没有深入谈论。socket file 可以沟通两个程序之间的资讯，因此程序可以取得对方传送过来的数据。
		由於有 socket file，因此类似 X Window 这种需要透过网络连接的软件，目前新版的 distributions 就以 socket 
		来进行窗口介面的连线沟通了。上表中 socket file 的输出栏位有：</p>

		<ul>
		<li>Proto ：一般就是 unix 啦；</li>
		<li>RefCnt：连接到此 socket 的程序数量；</li>
		<li>Flags ：连线的旗标；</li>
		<li>Type  ：socket 存取的类型。主要有确认连线的 STREAM 与不需确认的 DGRAM 两种；</li>
		<li>State ：若为 CONNECTED 表示多个程序之间已经连线创建。</li>
		<li>Path  ：连接到此 socket 的相关程序的路径！或者是相关数据输出的路径。</li>
		</ul>

		<p>以上表的输出为例，最后那三行在 /tmp/.xx 底下的数据，就是 X Window 窗口介面的相关程序啦！
		而 PATH 指向的就是这些程序要交换数据的插槽文件罗！好！那么 netstat 可以帮我们进行什么任务呢？
		很多喔！我们先来看看，利用 netstat 去看看我们的哪些程序有启动哪些网络的『后门』呢？</p>

<table class="term"><tbody><tr><td class="term"><pre><span class="term_hd">范例二：找出目前系统上已在监听的网络连线及其 PID</span>
[root@www ~]# <span class="term_command">netstat -tlnp</span>
Active Internet connections (only servers)
Proto Recv-Q Send-Q Local Address    Foreign Address  State   PID/Program name
tcp        0      0 127.0.0.1:2208   0.0.0.0:*        LISTEN  4566/hpiod
tcp        0      0 0.0.0.0:111      0.0.0.0:*        LISTEN  4328/portmap
tcp        0      0 127.0.0.1:631    0.0.0.0:*        LISTEN  4597/cupsd
tcp        0      0 0.0.0.0:728      0.0.0.0:*        LISTEN  4362/rpc.statd
tcp        0      0 127.0.0.1:25     0.0.0.0:*        LISTEN  4629/sendmail: 
tcp        0      0 127.0.0.1:2207   0.0.0.0:*        LISTEN  4571/python
tcp        0      0 :::22            :::*             LISTEN  <span class="term_write">4586/sshd</span>
<span class="term_say"># 除了可以列出监听网络的介面与状态之外，最后一个栏位还能够显示此服务的
# PID 号码以及程序的命令名称喔！例如最后一行的 4586 就是该 PID</span>

<span class="term_hd">范例三：将上述的本地端 127.0.0.1:631 那个网络服务关闭的话？</span>
[root@www ~]# <span class="term_command">kill -9 4597</span>
[root@www ~]# <span class="term_command">killall -9 cupsd</span>
</pre></td></tr></tbody></table>

		<p>很多朋友常常有疑问，那就是，我的主机目前到底开了几个门(ports)！其实，不论主机提供什么样的服务，
		一定必须要有相对应的 program 在主机上面运行才行啊！举例来说，我们鸟园的 Linux 主机提供的就是 WWW 
		服务，那么我的主机当然有一个程序在提供 WWW 的服务啊！那就是 Apache 这个软件所提供的啦！ ^_^。
		所以，当我运行了这个程序之后，我的系统自然就可以提供 WWW 的服务了。那如何关闭啊？
		就关掉该程序所触发的那个程序就好了！例如上面的范例三所提供的例子啊！ ^_^<br><br></p>

		<a name="dmesg"></a>
		<hr><ul class="list1"><li class="text_import1">dmesg ：分析核心产生的信息</li></ul>

		<p>系统在启动的时候，核心会去侦测系统的硬件，你的某些硬件到底有没有被捉到，那就与这个时候的侦测有关。
		但是这些侦测的过程要不是没有显示在萤幕上，就是很飞快的在萤幕上一闪而逝！能不能把核心侦测的信息捉出来瞧瞧？
		可以的，那就使用 dmesg 吧！</p>

		<p>所有核心侦测的信息，不管是启动时候还是系统运行过程中，反正只要是核心产生的信息，都会被记录到内存中的某个保护区段。
		dmesg 这个命令就能够将该区段的信息读出来的！因为信息实在太多了，所以运行时可以加入这个管线命令『 
		| more 』来使画面暂停！</p>

<table class="term"><tbody><tr><td class="term"><pre><span class="term_hd">范例一：输出所有的核心启动时的资讯</span>
[root@www ~]# <span class="term_command">dmesg | more</span>

<span class="term_hd">范例二：搜寻启动的时候，硬盘的相关资讯为何？</span>
[root@www ~]# <span class="term_command">dmesg | grep -i hd</span>
    ide0: BM-DMA at 0xd800-0xd807, BIOS settings: hda:DMA, hdb:DMA
    ide1: BM-DMA at 0xd808-0xd80f, BIOS settings: hdc:pio, hdd:pio
hda: IC35L040AVER07-0, ATA DISK drive
hdb: ASUS DRW-2014S1, ATAPI CD/DVD-ROM drive
hda: max request size: 128KiB
<span class="term_say">....(底下省略)....</span>
</pre></td></tr></tbody></table>

		<p>由范例二就知道我这部主机的硬盘的格式是什么了吧！没错啦！还可以查阅能不能找到网络卡喔！网络卡的代号是 
		eth ，所以，直接输入 dmesg | grep -i eth 试看看呢！<br><br></p>

		<a name="vmstat"></a>
		<hr><ul class="list1"><li class="text_import1">vmstat ：侦测系统资源变化</li></ul>

		<p>如果你想要动态的了解一下系统资源的运行，那么这个 vmstat 确实可以玩一玩！vmstat 可以侦测『 CPU /
		内存 / 磁碟输入输出状态 』等等，如果你想要了解一部繁忙的系统到底是哪个环节最累人，
		可以使用 vmstat 分析看看。底下是常见的选项与参数说明：</p>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">vmstat [-a] [延迟 [总计侦测次数]]</span> <span class="term_note">&lt;==CPU/内存等资讯</span>
[root@www ~]# <span class="term_command">vmstat [-fs]                     </span> <span class="term_note">&lt;==内存相关</span>
[root@www ~]# <span class="term_command">vmstat [-S 单位]                 </span> <span class="term_note">&lt;==配置显示数据的单位</span>
[root@www ~]# <span class="term_command">vmstat [-d]                      </span> <span class="term_note">&lt;==与磁碟有关</span>
[root@www ~]# <span class="term_command">vmstat [-p 分割槽]               </span> <span class="term_note">&lt;==与磁碟有关</span>
<span class="term_say">选项与参数：
-a  ：使用 inactive/active(活跃与否) 取代 buffer/cache 的内存输出资讯；
-f  ：启动到目前为止，系统复制 (fork) 的程序数；
-s  ：将一些事件 (启动至目前为止) 导致的内存变化情况列表说明；
-S  ：后面可以接单位，让显示的数据有单位。例如 K/M 取代 bytes 的容量；
-d  ：列出磁碟的读写总量统计表
-p  ：后面列出分割槽，可显示该分割槽的读写总量统计表</span>

<span class="term_hd">范例一：统计目前主机 CPU 状态，每秒一次，共计三次！</span>
[root@www ~]# <span class="term_command">vmstat 1 3</span>
procs -----------memory---------- ---swap-- -----io---- --system-- -----cpu------
 r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st
 0  0     28  61540 137000 291960    0    0     4     5   38   55  0  0 100  0  0
 0  0     28  61540 137000 291960    0    0     0     0 1004   50  0  0 100  0  0
 0  0     28  61540 137000 291964    0    0     0     0 1022   65  0  0 100  0  0
</pre></td></tr></tbody></table>

		<p>利用 vmstat 甚至可以进行追踪喔！你可以使用类似『 vmstat 5 』代表每五秒钟升级一次，且无穷的升级！直到你按下 
		[ctrl]-c 为止。如果你想要即时的知道系统资源的运行状态，这个命令就不能不知道！那么上面的表格各项栏位的意义为何？
		基本说明如下：</p>

		<ul>
		<li>内存栏位 (procs) 的项目分别为：<br>
		r ：等待运行中的程序数量；b：不可被唤醒的程序数量。这两个项目越多，代表系统越忙碌 
		(因为系统太忙，所以很多程序就无法被运行或一直在等待而无法被唤醒之故)。<br><br></li>

		<li>内存栏位 (memory) 项目分别为：<br>
		swpd：虚拟内存被使用的容量； free：未被使用的内存容量； buff：用於缓冲内存； cache：用於高速缓存。
		这部份则与 <a href="http://cn.linux.vbird.org/linux_basic/0440processcontrol.php#free">free</a> 是相同的。<br><br></li>

		<li>内存置换空间 (swap) 的项目分别为：<br>
		si：由磁碟中将程序取出的量； so：由於内存不足而将没用到的程序写入到磁碟的 swap 的容量。
		如果 si/so 的数值太大，表示内存内的数据常常得在磁碟与主内存之间传来传去，系统效能会很差！<br><br></li>

		<li>磁碟读写 (io) 的项目分别为：<br>
		bi：由磁碟写入的区块数量； bo：写入到磁碟去的区块数量。如果这部份的值越高，代表系统的 I/O 非常忙碌！<br><br></li>

		<li>系统 (system) 的项目分别为：<br>
		in：每秒被中断的程序次数； cs：每秒钟进行的事件切换次数；这两个数值越大，代表系统与周边设备的沟通非常频繁！
		这些周边设备当然包括磁碟、网络卡、时间钟等。<br><br></li>

		<li>CPU 的项目分别为：<br>
		us：非核心层的 CPU 使用状态； sy：核心层所使用的 CPU 状态； id：闲置的状态； wa：等待 I/O 所耗费的 CPU 状态；
		st：被虚拟机器 (virtual machine) 所盗用的 CPU 使用状态 (2.6.11 以后才支持)。</li>
		</ul>

		<p>由於鸟哥的机器是测试机，所以并没有什么 I/O 或者是 CPU 忙碌的情况。如果改天你的服务器非常忙碌时，
		记得使用 vmstat 去看看，到底是哪个部分的资源被使用的最为频繁！一般来说，如果 I/O 部分很忙碌的话，你的系统会变的非常慢！
		让我们再来看看，那么磁碟的部分该如何观察：</p>

<table class="term"><tbody><tr><td class="term"><pre><span class="term_hd">范例二：系统上面所有的磁碟的读写状态</span>
[root@www ~]# <span class="term_command">vmstat -d</span>
disk- ------------reads------------ ------------writes----------- -----IO------
       total merged sectors      ms  total merged sectors      ms    cur    sec
ram0       0      0       0       0      0      0       0       0      0      0
<span class="term_say">....(中间省略)....</span>
hda   144188 182874 6667154 7916979 151341 510244 8027088 15244705      0    848
hdb        0      0       0       0      0      0       0       0      0      0
</pre></td></tr></tbody></table>

		<p>详细的各栏位就请诸位大德查阅一下 man vmstat 罗！反正与读写有关啦！这样了解乎！</p>
	</div>
</div>


<hr><a name="special"></a><img src="./鸟哥的 Linux 私房菜18 -- 程序管理与 SELinux 初探_files/logo.png" alt="大标题的图示" width="35" align="middle" height="34"><span class="text_h1">特殊文件与程序</span><br>
<div class="block1">
	<p>我们在<a href="http://cn.linux.vbird.org/linux_basic/0220filemanager.php#suid_sgid_sbit">第七章曾经谈到特殊权限的 SUID/SGID/SBIT</a>
	，虽然第七章已经将这三种特殊权限作了详细的解释，不过，我们依旧要来探讨的是，那么到底这些权限对於你的『程序』是如何影响的？
	此外，程序可能会使用到系统资源，举例来说，磁碟就是其中一项资源。哪天你在 umount 磁碟时，系统老是出现『 device is 
	busy 』的字样～到底是怎么回事啊？我们底下就来谈一谈这些和程序有关系的细节部分：<br><br></p>

	<hr><a name="suid_sgid"></a><img src="./鸟哥的 Linux 私房菜18 -- 程序管理与 SELinux 初探_files/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">具有 SUID/SGID 权限的命令运行状态</span><br>
	<div class="block2">
		<p>SUID 的权限其实与程序的相关性非常的大！为什么呢？先来看看 SUID 的程序是如何被一般使用者运行，且具有什么特色呢？</p>
		<ul class="text_import2">
		<li>SUID 权限仅对二进位程序(binary program)有效；</li>
		<li>运行者对於该程序需要具有 x 的可运行权限；</li>
		<li>本权限仅在运行该程序的过程中有效 (run-time)；</li>
		<li>运行者将具有该程序拥有者 (owner) 的权限。</li>
		</ul>

		<p>所以说，整个 SUID 的权限会生效是由於『具有该权限的程序被触发』，而我们知道一个程序被触发会变成程序，
		所以罗，运行者可以具有程序拥有者的权限就是在该程序变成程序的那个时候啦！第七章我们还没谈到程序的概念，
		所以你或许那时候会觉得很奇怪，为啥运行了 passwd 后你就具有 root 的权限呢？不都是一般使用者运行的吗？
		这是因为你在触发 passwd 后，会取得一个新的程序与 PID，该 PID 产生时透过 SUID 来给予该 PID 特殊的权限配置啦！
		我们使用 dmtsai 登陆系统且运行 passwd 后，透过<a href="http://cn.linux.vbird.org/linux_basic/0440processcontrol.php#background">工作控制</a>来理解一下！</p>

<table class="term"><tbody><tr><td class="term"><pre>[dmtsai@www ~]$ <span class="term_command">passwd</span>
Changing password for user dmtsai.
Changing password for dmtsai
(current) UNIX password: <span class="term_note">&lt;==这里按下 [ctrl]-z 并且按下 [enter]</span>
[1]+  Stopped                 passwd

[dmtsai@www ~]$ <span class="term_command">pstree -u</span>
init-+-acpid
<span class="term_say">....(中间省略)....</span>
     |-sshd---sshd---<u>sshd(dmtsai)---bash-+-more</u>
     |                                   |-<span class="term_write">passwd(root)</span>
     |                                   `-<u>pstree</u>
<span class="term_say">....(底下省略)....</span>
</pre></td></tr></tbody></table>

		<p>从上表的结果我们可以发现，底线的部分是属於 dmtsai 这个一般帐号的权限，特殊字体的则是 root 的权限！
		但你看到了， passwd 确实是由 bash 衍生出来的！不过就是权限不一样！透过这样的解析，
		你也会比较清楚为何不同程序所产生的权限不同了吧！这是由於『SUID 程序运行过程中产生的程序』的关系啦！</p>

		<p>那么既然 SUID/SGID 的权限是比较可怕的，您该如何查询整个系统的 SUID/SGID 的文件呢？
		应该是还不会忘记吧？使用 <a href="http://cn.linux.vbird.org/linux_basic/0220filemanager.php#find">find</a> 即可啊！</p>

		<blockquote class="text_import2" style="font-family: &#39;细明体&#39;;">find / -perm +6000</blockquote>
	</div>

	<hr><a name="proc"></a><img src="./鸟哥的 Linux 私房菜18 -- 程序管理与 SELinux 初探_files/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">/proc/* 代表的意义</span><br>
	<div class="block2">
		<p>其实，我们之前提到的所谓的程序都是在内存当中嘛！而内存当中的数据又都是写入到
		/proc/* 这个目录下的，所以罗，我们当然可以直接观察 /proc 这个目录当中的文件啊！
		如果你观察过 /proc 这个目录的话，应该会发现他有点像这样：</p>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">ll /proc</span>
dr-xr-xr-x  5 root      root              0 Mar 11 08:46 1
dr-xr-xr-x  5 root      root              0 Mar 11 00:46 10
dr-xr-xr-x  5 root      root              0 Mar 11 00:46 11
<span class="term_say">....(中间省略)....</span>
-r--r--r--  1 root      root              0 Mar 20 12:11 uptime
-r--r--r--  1 root      root              0 Mar 20 12:11 version
-r--r--r--  1 root      root              0 Mar 20 12:11 vmstat
-r--r--r--  1 root      root              0 Mar 20 12:11 zoneinfo
</pre></td></tr></tbody></table>

		<p>基本上，目前主机上面的各个程序的 PID 都是以目录的型态存在於 /proc 当中。
		举例来说，我们启动所运行的第一支程序 init 他的 PID 是 1 ，
		这个 PID 的所有相关资讯都写入在 /proc/1/* 当中！若我们直接观察 PID 为 1 的数据好了，他有点像这样：</p>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">ll /proc/1</span>
dr-xr-xr-x 2 root root 0 Mar 12 11:04 attr
-r-------- 1 root root 0 Mar 17 14:32 auxv
<span class="term_write">-r--r--r-- 1 root root 0 Mar 17 14:32 cmdline</span>  <span class="term_note">&lt;==就是命令串</span>
-rw-r--r-- 1 root root 0 Mar 17 14:32 coredump_filter
-r--r--r-- 1 root root 0 Mar 17 14:32 cpuset
lrwxrwxrwx 1 root root 0 Mar 17 14:32 cwd -&gt; /
<span class="term_write">-r-------- 1 root root 0 Mar 17 14:32 environ</span>  <span class="term_note">&lt;==一些环境变量</span>
lrwxrwxrwx 1 root root 0 Mar 17 14:32 exe -&gt; /sbin/init  <span class="term_note">&lt;==实际运行的命令</span>
<span class="term_say">....(以下省略)....</span>
</pre></td></tr></tbody></table>

		<p>里面的数据还挺多的，不过，比较有趣的其实是两个文件，分别是：</p>
		<ul>
		<li>cmdline：这个程序被启动的命令串；</li>
		<li>environ：这个程序的环境变量内容。</li>
		</ul>
		<p>很有趣吧！如果你查阅一下 cmdline 的话，就会发现：</p>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">cat /proc/1/cmdline</span>
init [5]
</pre></td></tr></tbody></table>

		<p>就是这个命令、选项与参数启动 init 的啦！这还是跟某个特定的 PID 有关的内容呢，如果是针对整个 
		Linux 系统相关的参数呢？那就是在 /proc 目录底下的文件啦！相关的文件与对应的内容是这样的：
		(<a href="http://cn.linux.vbird.org/linux_basic/0440processcontrol.php#ps3">注3</a>)</p>

<table bgcolor="lightyellow" border="1" cellpadding="3" cellspacing="0" width="95%">
<tbody><tr align="center" bgcolor="#182448"><td width="100"><font color="#FFFFFF">档名</font></td><td><font color="#FFFFFF">文件内容</font></td></tr>
<tr><td>/proc/cmdline</td><td>加载 kernel 时所下达的相关参数！查阅此文件，可了解系统是如何启动的！</td></tr>
<tr><td>/proc/cpuinfo</td><td>本机的 CPU 的相关资讯，包含时脉、类型与运算功能等</td></tr>
<tr><td>/proc/devices</td><td>这个文件记录了系统各个主要装置的主要装置代号，与 
	<a href="http://cn.linux.vbird.org/linux_basic/0230filesystem.php#mknod">mknod</a> 有关呢！</td></tr>
<tr><td>/proc/filesystems</td><td>目前系统已经加载的文件系统罗！</td></tr>
<tr><td>/proc/interrupts</td><td>目前系统上面的 IRQ 分配状态。</td></tr>
<tr><td>/proc/ioports</td><td>目前系统上面各个装置所配置的 I/O 位址。</td></tr>
<tr><td>/proc/kcore</td><td>这个就是内存的大小啦！好大对吧！但是不要读他啦！</td></tr>
<tr><td>/proc/loadavg</td><td>还记得 <a href="http://cn.linux.vbird.org/linux_basic/0440processcontrol.php#top">top</a> 以及 <a href="http://cn.linux.vbird.org/linux_basic/0440processcontrol.php#uptime">uptime</a>
	 吧？没错！上头的三个平均数值就是记录在此！</td></tr>
<tr><td>/proc/meminfo</td><td>使用 <a href="http://cn.linux.vbird.org/linux_basic/0440processcontrol.php#free">free</a> 列出的内存资讯，嘿嘿！在这里也能够查阅到！</td></tr>
<tr><td>/proc/modules</td><td>目前我们的 Linux 已经加载的模块列表，也可以想成是驱动程序啦！</td></tr>
<tr><td>/proc/mounts</td><td>系统已经挂载的数据，就是用 mount 这个命令呼叫出来的数据啦！</td></tr>
<tr><td>/proc/swaps</td><td>到底系统挂加载的内存在哪里？呵呵！使用掉的 partition 就记录在此啦！</td></tr>
<tr><td>/proc/partitions</td><td>使用 fdisk -l 会出现目前所有的 partition 
	吧？在这个文件当中也有纪录喔！</td></tr>
<tr><td>/proc/pci</td><td>在 PCI 汇流排上面，每个装置的详细情况！可用 lspci 来查阅！</td></tr>
<tr><td>/proc/uptime</td><td>就是用 uptime 的时候，会出现的资讯啦！</td></tr>
<tr><td>/proc/version</td><td>核心的版本，就是用 uname -a 显示的内容啦！</td></tr>
<tr><td>/proc/bus/*</td><td>一些汇流排的装置，还有 U盘 的装置也记录在此喔！</td></tr>
</tbody></table><br>

		<p>其实，上面这些文件鸟哥在此建议您可以使用 cat 去查阅看看，不必深入了解，
		不过，观看过文件内容后，毕竟会比较有感觉啦！如果未来您想要自行撰写某些工具软件，
		那么这个目录底下的相关文件可能会对您有点帮助的喔！</p>
	</div>

	<hr><a name="ofile"></a><img src="./鸟哥的 Linux 私房菜18 -- 程序管理与 SELinux 初探_files/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">查询已开启文件或已运行程序开启之文件</span><br>
	<div class="block2">
		<p>其实还有一些与程序相关的命令可以值得参考与应用的，我们来谈一谈：<br><br></p>

		<a name="fuser"></a>
		<hr><ul class="list1"><li class="text_import1">fuser：藉由文件(或文件系统)找出正在使用该文件的程序</li></ul>

		<p>有的时候我想要知道我的程序到底在这次启动过程中开启了多少文件，可以利用 fuser 来观察啦！
		举例来说，你如果卸载时发现系统通知：『 device is busy 』，那表示这个文件系统正在忙碌中，
		表示有某支程序有利用到该文件系统啦！那么你就可以利用 fuser 来追踪罗！fuser 语法有点像这样：</p>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">fuser [-umv] [-k [i] [-signal]] file/dir</span>
<span class="term_say">选项与参数：
-u  ：除了程序的 PID 之外，同时列出该程序的拥有者；
-m  ：后面接的那个档名会主动的上提到该文件系统的最顶层，对 umount 不成功很有效！
-v  ：可以列出每个文件与程序还有命令的完整相关性！
-k  ：找出使用该文件/目录的 PID ，并试图以 SIGKILL 这个讯号给予该 PID；
-i  ：必须与 -k 配合，在删除 PID 之前会先询问使用者意愿！
-signal：例如 -1 -15 等等，若不加的话，默认是 SIGKILL (-9) 罗！</span>

<span class="term_hd">范例一：找出目前所在目录的使用 PID/所属帐号/权限 为何？</span>
[root@www ~]# <span class="term_command">fuser -uv .</span>
                     USER        PID ACCESS COMMAND
.:                   root      20639 ..c.. (root)bash
</pre></td></tr></tbody></table>

		<p>看到输出的结果没？他说『.』底下有个 PID 为 20639 的程序，该程序属於 root 且命令为 bash 。
		比较有趣的是那个 ACCESS 的项目，那个项目代表的意义为：</p>
		<ul style="font-family: &#39;细明体&#39;;">
		<li>c ：此程序在当前的目录下(非次目录)；</li>
		<li>e ：可被触发为运行状态；</li>
		<li>f ：是一个被开启的文件；</li>
		<li>r ：代表顶层目录 (root directory)；</li>
		<li>F ：该文件被开启了，不过在等待回应中；</li>
		<li>m ：可能为分享的动态函式库；</li>
		</ul>

		<p>那如果你想要查阅某个文件系统底下有多少程序正在占用该文件系统时，那个 -m 的选项就很有帮助了！
		鸟哥的测试主机仅有分割出 /, /boot, /home ，所以无法进行测试。不过好在还有个 /proc 的虚拟文件系统，
		让我们来了解一下这个 /proc  的文件系统有多少程序正在利用他吧！</p>

<table class="term"><tbody><tr><td class="term"><pre><span class="term_hd">范例二：找到所有使用到 /proc 这个文件系统的程序吧！</span>
[root@www ~]# <span class="term_command">fuser -uv /proc</span>
<span class="term_say"># 不会显示任何数据，因为没有任何程序会去使用 /proc 这个目录啊！
# 会被用到的是 /proc 底下的文件啦！所以你应该要这样做：</span>

[root@www ~]# <span class="term_command">fuser -mvu /proc</span>
                     USER        PID ACCESS COMMAND
/proc:               root       4289 f.... (root)klogd
                     root       4555 f.... (root)acpid
                     haldaemon  4758 f.... (haldaemon)hald
                     root       4977 F.... (root)Xorg
<span class="term_say"># 有这几支程序在进行 /proc 文件系统的存取喔！这样清楚了吗？</span>
</pre></td></tr></tbody></table>

		<p>既然可以针对整个文件系统，那么能不能仅针对单一文件啊？当然可以罗！看一下底下的案例先：</p>

<table class="term"><tbody><tr><td class="term"><pre><span class="term_hd">范例三：找到 /var 底下属於 FIFO 类型的文件，并且找出存取该文件的程序</span>
[root@www ~]# <span class="term_command">find /var -type p</span>
/var/gdm/.gdmfifo     <span class="term_note">&lt;==我们针对这玩意即可！</span>
/var/run/autofs.fifo-misc
/var/run/autofs.fifo-net

[root@www ~]# <span class="term_command">fuser -uv /var/gdm/.gdmfifo</span>
                     USER        PID ACCESS COMMAND
/var/gdm/.gdmfifo:   root       4892 F.... (root)gdm-binary

<span class="term_hd">范例四：同范例三，但试图删除该 PID？且『不要』删除喔！</span>
[root@www ~]# <span class="term_command">fuser -ki /var/gdm/.gdmfifo</span>
/var/gdm/.gdmfifo:    4892
Kill process 4892 ? (y/N) <span class="term_command">n</span>
</pre></td></tr></tbody></table>

		<p>如何？很有趣的一个命令吧！透过这个 fuser 我们可以找出使用该文件、目录的程序，藉以观察的啦！
		他的重点与 ps, pstree 不同。 fuser 可以让我们了解到某个文件 (或文件系统) 目前正在被哪些程序所利用！<br><br></p>

		<a name="lsof"></a>
		<hr><ul class="list1"><li class="text_import1">lsof ：列出被程序所开启的文件档名</li></ul>

		<p>相对於 fuser 是由文件或者装置去找出使用该文件或装置的程序，反过来说，
		如何查出某个程序开启或者使用的文件与装置呢？呼呼！那就是使用 lsof 罗～</p>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">lsof [-aUu] [+d]</span>
<span class="term_say">选项与参数：
-a  ：多项数据需要『同时成立』才显示出结果时！
-U  ：仅列出 Unix like 系统的 socket 文件类型；
-u  ：后面接 username，列出该使用者相关程序所开启的文件；
+d  ：后面接目录，亦即找出某个目录底下已经被开启的文件！</span>

<span class="term_hd">范例一：列出目前系统上面所有已经被开启的文件与装置：</span>
[root@www ~]# <span class="term_command">lsof</span>
COMMAND PID  USER   FD  TYPE  DEVICE   SIZE     NODE NAME
init      1  root  cwd   DIR     3,2   4096        2 /
init      1  root  rtd   DIR     3,2   4096        2 /
init      1  root  txt   REG     3,2  38620  1426405 /sbin/init
<span class="term_say">....(底下省略)....</span>
<span class="term_say"># 注意到了吗？是的，在默认的情况下， lsof 会将目前系统上面已经开启的
# 文件全部列出来～所以，画面多的吓人啊！您可以注意到，第一个文件 init 运行的
# 地方就在根目录，而根目录，嘿嘿！所在的 inode 也有显示出来喔！</span>

<span class="term_hd">范例二：仅列出关於 root 的所有程序开启的 socket 文件</span>
[root@www ~]# <span class="term_command">lsof -u root -a -U</span>
COMMAND     PID USER   FD   TYPE     DEVICE SIZE   NODE NAME
udevd       400 root    3u  unix 0xedd4cd40        1445 socket
auditd     4256 root    7u  unix 0xedd4c380        9081 socket
audispd    4258 root    0u  unix 0xedd4c1e0        9080 socket
<span class="term_say"># 注意到那个 -a 吧！如果你分别输入 lsof -u root 及 lsof -U ，会有啥资讯？
# 使用 lsof -u root -U 及 lsof -u root -a -U ，呵呵！都不同啦！
# -a 的用途就是在解决同时需要两个项目都成立时啊！ ^_^</span>

<span class="term_hd">范例三：请列出目前系统上面所有的被启动的周边装置</span>
[root@www ~]# <span class="term_command">lsof +d /dev</span>
COMMAND     PID      USER   FD   TYPE     DEVICE SIZE  NODE NAME
init          1      root   10u  FIFO       0,16       1147 /dev/initctl
udevd       400      root    0u   CHR        1,3       1420 /dev/null
udevd       400      root    1u   CHR        1,3       1420 /dev/null
udevd       400      root    2u   CHR        1,3       1420 /dev/null
<span class="term_say"># 看吧！因为装置都在 /dev 里面嘛！所以罗，使用搜寻目录即可啊！</span>

<span class="term_hd">范例四：秀出属於 root 的 bash 这支程序所开启的文件</span>
[root@www ~]# <span class="term_command">lsof -u root | grep bash</span>
bash   20639 root  cwd    DIR    3,2    4096    648321 /root
bash   20639 root  rtd    DIR    3,2    4096         2 /
bash   20639 root  txt    REG    3,2  735004   1199424 /bin/bash
bash   20639 root  mem    REG    3,2   46680     64873 /lib/libnss_files-2.5.so
<span class="term_say">....(底下省略)....</span>
</pre></td></tr></tbody></table>

		<p>这个命令可以找出您想要知道的某个程序是否有激活哪些资讯？例如上头提到的范例四的运行结果呢！ ^_^<br><br></p>

		<a name="pidof"></a>
		<hr><ul class="list1"><li class="text_import1">pidof ：找出某支正在运行的程序的 PID</li></ul>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">pidof [-sx] program_name</span>
<span class="term_say">选项与参数：
-s  ：仅列出一个 PID 而不列出所有的 PID
-x  ：同时列出该 program name 可能的 PPID 那个程序的 PID</span>

<span class="term_hd">范例一：列出目前系统上面 init 以及 syslogd 这两个程序的 PID</span>
[root@www ~]# <span class="term_command">pidof init syslogd</span>
1 4286
<span class="term_say"># 理论上，应该会有两个 PID 才对。上面的显示也是出现了两个 PID 喔。
# 分别是 init 及 syslogd 这两支程序的 PID 啦。</span>
</pre></td></tr></tbody></table>

		<p>很简单的用法吧，透过这个 pidof 命令，并且配合 ps aux 与正规表示法，就可以很轻易的找到您所想要的程序内容了呢。</p>
	</div>
</div>


<hr><a name="selinux"></a><img src="./鸟哥的 Linux 私房菜18 -- 程序管理与 SELinux 初探_files/logo.png" alt="大标题的图示" width="35" align="middle" height="34"><span class="text_h1">SELinux 初探</span><br>
<div class="block1">
	<p>在进入了 CentOS 5.x 之后，SELinux 已经是个非常完备的核心模块了！CentOS 5.x 提供了很多管理 SELinux 的命令与机制，
	因此在整体架构上面比以前的版本要单纯且容易操作管理！所以，在这一版以后，我们建议大家千万不要关掉 SELinux 这玩意儿！
	让我们来仔细的玩玩这家伙吧！<br><br></p>

	<hr><a name="selinux_what"></a><img src="./鸟哥的 Linux 私房菜18 -- 程序管理与 SELinux 初探_files/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">什么是 SELinux</span><br>
	<div class="block2">
		<p>什么是 SELinux 呢？<span class="text_import2">其实他是『 Security Enhanced Linux 
		』的缩写，字面上的意义就是安全强化的 Linux 之意</span>！那么所谓的『安全强化』是强化哪个部分？
		是网络资安还是权限管理？底下就让我们来谈谈吧！<br><br></p>

		<a name="history"></a>
		<hr><ul class="list1"><li class="text_import1">当初设计的目标：避免资源的误用</li></ul>

		<p>SELinux 是由美国国家安全局 (NSA) 开发的，当初开发这玩意儿的目的是因为<span class="text_import2">很多企业界发现，
		通常系统出现问题的原因大部分都在於『内部员工的资源误用』所导致的，实际由外部发动的攻击反而没有这么严重</span>。
		那么什么是『员工资源误用』呢？举例来说，如果有个不是很懂系统的系统管理员为了自己配置的方便，将网页所在目录 
		/var/www/html/ 的权限配置为 drwxrwxrwx 时，你觉得会有什么事情发生？</p>

		<p>现在我们知道所有的系统资源都是透过程序来进行存取的，那么 /var/www/html/ 如果配置为 777 ，
		代表所有程序均可对该目录存取，万一你真的有启动 WWW 服务器软件，那么该软件所触发的程序将可以写入该目录，
		而该程序却是对整个 Internet 提供服务的！只要有心人接触到这支程序，而且该程序刚好又有提供使用者进行写入的功能，
		那么外部的人很可能就会对你的系统写入些莫名其妙的东西！那可真是不得了！一个小小的 777 问题可是大大的！</p>

		<p>为了控管这方面的权限与程序的问题，所以美国国家安全局就著手处理操作系统这方面的控管。
		由於 Linux 是自由软件，程序码都是公开的，因此她们便使用 Linux 来作为研究的目标，
		最后更将研究的结果整合到 Linux 核心里面去，那就是 SELinux 啦！所以说， SELinux 是整合到核心的一个模块喔！
		更多的 SELinux 相关说明可以参考：</p>
		<ul><li><a href="http://www.nsa.gov/research/selinux/" target="_blank">http://www.nsa.gov/research/selinux/</a></li></ul>

		<p>这也就是说：<span class="text_import2">其实 SELinux 是在进行程序、文件等细部权限配置依据的一个核心模块！
		由於启动网络服务的也是程序，因此刚好也能够控制网络服务能否存取系统资源的一道关卡！</span>
		所以，在讲到 SELinux 对系统的存取控制之前，我们得先来回顾一下之前谈到的系统文件权限与使用者之间的关系。
		因为先谈完这个你才会知道为何需要 SELinux 的啦！<br><br></p>

		<a name="dac"></a>
		<hr><ul class="list1"><li class="text_import1">传统的文件权限与帐号关系：自主式存取控制, DAC</li></ul>

		<p>我们<a href="http://cn.linux.vbird.org/linux_basic/0410accountmanager.php">第十四章</a>的内容，知道系统的帐号主要分为系统管理员 
		(root) 与一般用户，而这两种身份能否使用系统上面的文件资源则与 rwx 的权限配置有关。
		不过你要注意的是，各种权限配置对 root 是无效的。因此，当某个程序想要对文件进行存取时，
		系统就会根据该程序的拥有者/群组，并比对文件的权限，若通过权限检查，就可以存取该文件了。</p>

		<p><span class="text_import2">这种存取文件系统的方式被称为『自主式存取控制 (Discretionary Access Control, 
		DAC)』，基本上，就是依据程序的拥有者与文件资源的 rwx 权限来决定有无存取的能力。</span>
		不过这种 DAC 的存取控制有几个困扰，那就是：</p>

		<ul>
		<li><span class="text_import2">root 具有最高的权限</span>：如果不小心某支程序被有心人士取得，
		且该程序属於 root 的权限，那么这支程序就可以在系统上进行任何资源的存取！真是要命！<br><br></li>

		<li><span class="text_import2">使用者可以取得程序来变更文件资源的存取权限</span>：如果你不小心将某个目录的权限配置为 
		777 ，由於对任何人的权限会变成 rwx ，因此该目录就会被任何人所任意存取！</li>
		</ul>

		<p>这些问题是非常严重的！尤其是当你的系统是被某些漫不经心的系统管理员所掌控时！她们甚至觉得目录权限调为 777 
		也没有什么了不起的危险哩...<br><br></p>

		<a name="mac"></a>
		<hr><ul class="list1"><li class="text_import1">以政策守则订定特定程序读取特定文件：委任式存取控制, MAC</li></ul>

		<p>现在我们知道 DAC 的困扰就是当使用者取得程序后，他可以藉由这支程序与自己默认的权限来处理他自己的文件资源。
		万一这个使用者对 Linux 系统不熟，那就很可能会有资源误用的问题产生。为了避免 DAC 容易发生的问题，因此 
		SELinux 导入了委任式存取控制 (Mandatory Access Control, MAC) 的方法！</p>

		<p>委任式存取控制 (MAC) 有趣啦！他可以针对特定的程序与特定的文件资源来进行权限的控管！
		也就是说，即使你是 root ，那么在使用不同的程序时，你所能取得的权限并不一定是 root ，
		而得要看当时该程序的配置而定。如此一来，我们针对控制的『主体』变成了『程序』而不是使用者喔！
		此外，这个主体程序也不能任意使用系统文件资源，因为每个文件资源也有针对该主体程序配置可取用的权限！
		如此一来，控制项目就细的多了！但整个系统程序那么多、文件那么多，一项一项控制可就没完没了！
		所以 SELinux 也提供一些默认的政策 (Policy) ，并在该政策内提供多个守则 (rule) ，让你可以选择是否激活该控制守则！</p>

		<p>在委任式存取控制的配置下，我们的程序能够活动的空间就变小了！举例来说， WWW 服务器软件的达成程序为 httpd 这支程序，
		而默认情况下， httpd 仅能在 /var/www/ 这个目录底下存取文件，如果 httpd 这个程序想要到其他目录去存取数据时，
		除了守则配置要开放外，目标目录也得要配置成 httpd 可读取的模式 (type) 才行喔！限制非常多！
		所以，即使不小心 httpd 被 cracker 取得了控制权，他也无权浏览 /etc/shadow 等重要的配置档喔！</p>
	</div>

	<hr><a name="selinux_run"></a><img src="./鸟哥的 Linux 私房菜18 -- 程序管理与 SELinux 初探_files/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">SELinux 的运行模式</span><br>
	<div class="block2">
		<p>再次的重复说明一下，SELinux 是透过 MAC 的方式来控管程序，他控制的主体是程序，
		而目标则是该程序能否读取的『文件资源』！所以先来说明一下这些咚咚的相关性啦！(<a href="http://cn.linux.vbird.org/linux_basic/0440processcontrol.php#ps4">注4</a>)</p>

		<a name="selinux_com"></a>
		<ul>
		<li><span class="text_import1">主体 (Subject)：</span><br>
		SELinux 主要想要管理的就是程序，因此你可以将『主体』跟本章谈到的 process 划上等号；<br><br></li>

		<li><span class="text_import1">目标 (Object)：</span><br>
		主体程序能否存取的『目标资源』一般就是文件系统。因此这个目标项目可以等文件系统划上等号；<br><br></li>

		<li><span class="text_import1">政策 (Policy)：</span><br>
		由於程序与文件数量庞大，因此 SELinux 会依据某些服务来制订基本的存取安全性政策。这些政策内还会有详细的守则 (rule)
		来指定不同的服务开放某些资源的存取与否。在目前的 CentOS 5.x 里面仅有提供两个主要的政策，分别是：<br><br>
		<ul class="text_import2">
		<li>targeted：针对网络服务限制较多，针对本机限制较少，是默认的政策；</li>
		<li>strict：完整的 SELinux 限制，限制方面较为严格。</li>
		</ul><br>
		建议使用默认的 targeted 政策即可。<br><br></li>

		<li><span class="text_import1">安全性本文 (security context)：</span><br>
		我们刚刚谈到了主体、目标与政策面，但是主体能不能存取目标除了政策指定之外，<span class="text_import2">主体与目标的安全性本文必须一致才能够顺利存取。</span>
		这个安全性本文 (security context) 有点类似文件系统的 rwx 啦！安全性本文的内容与配置是非常重要的！
		如果配置错误，你的某些服务(主体程序)就无法存取文件系统(目标资源)，当然就会一直出现『权限不符』的错误信息了！</li>
		</ul>

		<center><img src="./鸟哥的 Linux 私房菜18 -- 程序管理与 SELinux 初探_files/selinux_1.gif" alt="SELinux 运行的各组件之相关性" title="SELinux 运行的各组件之相关性" border="0"><br>
		图 5.2.1、SELinux 运行的各组件之相关性(<a href="http://cn.linux.vbird.org/linux_basic/0440processcontrol.php#ps4">本图参考小州老师的上课讲义</a>)<br></center>

		<p><span class="text_import2">上图的重点在『主体』如何取得『目标』的资源存取权限！</span>
		由上图我们可以发现，主体程序必须要通过 SELinux 政策内的守则放行后，就可以与目标资源进行安全性本文的比对，
		若比对失败则无法存取目标，若比对成功则可以开始存取目标。问题是，最终能否存取目标还是与文件系统的 rwx 
		权限配置有关喔！如此一来，加入了 SELinux 之后，出现权限不符的情况时，你就得要一步一步的分析可能的问题了！
		<br><br></p>

		<a name="context"></a>
		<hr><ul class="list1"><li class="text_import1">安全性本文 (Security Context)</li></ul>

		<p>CentOS 5.x 已经帮我们制订好非常多的守则了，这部份你只要知道如何开启/关闭某项守则的放行与否即可。
		那个安全性本文比较麻烦！因为你可能需要自行配置文件的安全性本文呢！为何需要自行配置啊？
		举例来说，你不也常常进行文件的 rwx 的重新配置吗？这个<span class="text_import2">安全性本文你就将他想成 
		SELinux 内必备的 rwx 就是了</span>！这样比较好理解啦。</p>

		<p>安全性本文存在於主体程序中与目标文件资源中。程序在内存内，所以安全性本文可以存入是没问题。
		那文件的安全性本文是记录在哪里呢？事实上，<span class="text_import2">安全性本文是放置到文件的 inode
		内的</span>，因此主体程序想要读取目标文件资源时，同样需要读取 inode ，
		这 inode 内就可以比对安全性本文以及 rwx 等权限值是否正确，而给予适当的读取权限依据。</p>

		<p>那么安全性本文到底是什么样的存在呢？我们先来看看 /root 底下的文件的安全性本文好了。
		观察安全性本文可使用『 ls -Z 』去观察如下：(注意：你必须已经启动了 SELinux 
		才行！若尚未启动，这部份请稍微看过一遍即可。底下会介绍如何启动 SELinux 喔！)</p>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">ls -Z</span>
drwxr-xr-x  root root <span class="term_write">root:object_r:user_home_t</span>   Desktop
-rw-r--r--  root root <span class="term_write">root:object_r:user_home_t</span>   install.log
-rw-r--r--  root root <span class="term_write">root:object_r:user_home_t</span>   install.log.syslog
<span class="term_say"># 上述特殊字体的部分，就是安全性本文的内容！</span>
</pre></td></tr></tbody></table>

		<p>如上所示，安全性本文主要用冒号分为三个栏位，这三个栏位的意义为：</p>
<table class="term"><tbody><tr><td class="term"><pre>Identify:role:type
身份识别:角色:类型
</pre></td></tr></tbody></table>

		<p>这三个栏位的意义仔细的说明一下吧：</p>

		<ul>
		<li><span class="text_import1">身份识别 (Identify)：</span><br><br>
		相当於帐号方面的身份识别！主要的身份识别则有底下三种常见的类型：<br><br>
		<ul>
		<li><span class="text_import2">root</span>：表示 root 的帐号身份，如同上面的表格显示的是 root 家目录下的数据啊！</li>
		<li><span class="text_import2">system_u</span>：表示系统程序方面的识别，通常就是程序罗；</li>
		<li><span class="text_import2">user_u</span>：代表的是一般使用者帐号相关的身份。</li>
		</ul><br>
		你会发现身份识别中，除了 root 之外，其他的识别后面都会加上『 _u 』的字样呢！
		这个身份识别重点再让我们了解该数据为何种身份所有哩～
		而系统上面大部分的数据都会是 system_u 或 root 啦！至於如果是在 /home 底下的数据，那么大部分应该就会是 user_u 罗！
		<br><br></li>

		<li><span class="text_import1">角色 (Role)：</span><br><br>
		透过角色栏位，我们可以知道这个数据是属於程序、文件资源还是代表使用者。一般的角色有：<br><br>
		<ul>
		<li><span class="text_import2">object_r</span>：代表的是文件或目录等文件资源，这应该是最常见的罗；</li>
		<li><span class="text_import2">system_r</span>：代表的就是程序啦！不过，一般使用者也会被指定成为 system_r 喔！</li>
		</ul><br>
		你也会发现角色的栏位最后面使用『 _r 』来结尾！因为是 role 的意思嘛！<br><br></li>
		
		<li><span class="text_import1">类型 (Type) ：(最重要！)</span><br><br>
		在默认的 targeted 政策中， Identify 与 Role 栏位基本上是不重要的！重要的在於这个类型 (type) 栏位！
		基本上，一个主体程序能不能读取到这个文件资源，与类型栏位有关！而类型栏位在文件与程序的定义不太相同，分别是：<br><br>
		<ul>
		<li>type：在文件资源 (Object) 上面称为类型 (Type)；</li>
		<li>domain：在主体程序 (Subject) 则称为领域 (domain) 了！</li>
		</ul><br>
		domain 需要与 type 搭配，则该程序才能够顺利的读取文件资源啦！</li>
		</ul><br>

		<a name="domain_type"></a>
		<hr><ul class="list1"><li class="text_import1">程序与文件 SELinux type 栏位的相关性</li></ul>

		<p>那么这三个栏位如何利用呢？首先我们来瞧瞧主体程序在这三个栏位的意义为何！透过身份识别与角色栏位的定义，
		我们可以约略知道某个程序所代表的意义喔！基本上，这些对应数据在 targeted 政策下的对应如下：</p>

<table bgcolor="lightyellow" border="1" cellpadding="3" cellspacing="0" width="95%">
<tbody><tr align="center" bgcolor="#182448"><td><font color="#FFFFFF">身份识别</font></td><td><font color="#FFFFFF">角色</font></td><td><font color="#FFFFFF">该对应在 targeted 的意义</font></td></tr>
<tr><td>root</td><td>system_r</td><td>代表供 root 帐号登陆时所取得的权限</td></tr>
<tr><td>system_u</td><td>system_r</td><td>由於为系统帐号，因此是非交谈式的系统运行程序</td></tr>
<tr><td>user_u</td><td>system_r</td><td>一般可登陆使用者的程序罗！</td></tr>
</tbody></table>

		<p>但就如上所述，其实最重要的栏位是类型栏位，主体与目标之间是否具有可以读写的权限，与程序的 domain 及文件的
		type 有关！这两者的关系我们可以使用达成 WWW 服务器功能的 httpd 这支程序与 /var/www/html 这个网页放置的目录来说明。
		首先，看看这两个咚咚的安全性本文内容先：</p>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">ll -Zd /usr/sbin/httpd /var/www/html</span>
-rwxr-xr-x  root root system_u:object_r:<span class="term_write">httpd_exec_t</span>   /usr/sbin/httpd
drwxr-xr-x  root root system_u:object_r:<span class="term_write">httpd_sys_content_t</span> /var/www/html
<span class="term_say"># 两者的角色栏位都是 object_r ，代表都是文件！而 httpd 属於 httpd_exec_t 类型，
# /var/www/html 则属於 httpd_sys_content_t 这个类型！</span>
</pre></td></tr></tbody></table>

		<p>httpd 属於 httpd_exec_t 这个可以运行的类型，而 /var/www/html 则属於 httpd_sys_content_t 这个可以让
		httpd 领域 (domain) 读取的类型。文字看起来不太容易了解吧！我们使用图示来说明这两者的关系！</p>

		<center><img src="./鸟哥的 Linux 私房菜18 -- 程序管理与 SELinux 初探_files/selinux_2.gif" alt="主体程序取得的 domain 与目标文件资源的 type 相互关系" title="主体程序取得的 domain 与目标文件资源的 type 相互关系" border="0"><br>
		图 5.2.2、主体程序取得的 domain 与目标文件资源的 type 相互关系<br></center>

		<p>上图的意义我们可以这样看的：</p>

		<ol class="text_import2">
		<li>首先，我们触发一个可运行的目标文件，那就是具有 httpd_exec_t 这个类型的 /usr/sbin/httpd 文件；</li>
		<li>该文件的类型会让这个文件所造成的主体程序 (Subject) 具有 httpd 这个领域 (domain)，
		我们的政策针对这个领域已经制定了许多守则，其中包括这个领域可以读取的目标资源类型；</li>
		<li>由於 httpd domain 被配置为可以读取 httpd_sys_content_t 这个类型的目标文件 (Object)，
		因此你的网页放置到 /var/www/html/ 目录下，就能够被 httpd 那支程序所读取了；</li>
		<li>但最终能不能读到正确的数据，还得要看 rwx 是否符合 Linux 权限的规范！</li>
		</ol>

		<p>上述的流程告诉我们几个重点，第一个是政策内需要制订详细的 domain/type 相关性；第二个是若文件的 type 配置错误，
		那么即使权限配置为 rwx 全开的 777 ，该主体程序也无法读取目标文件资源的啦！不过如此一来，
		也就可以避免使用者将他的家目录配置为 777 时所造成的权限困扰。</p>
	</div>

	<hr><a name="selinux_get"></a><img src="./鸟哥的 Linux 私房菜18 -- 程序管理与 SELinux 初探_files/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">SELinux 的启动、关闭与观察</span><br>
	<div class="block2">
		<p>并非所有的 Linux distributions 都支持 SELinux 的，所以你必须要先观察一下你的系统版本为何！
		鸟哥这里介绍的 CentOS 5.x 本身就有支持 SELinux 啦！所以你不需要自行编译 SELinux 到你的 Linux 核心中！
		目前 SELinux 支持三种模式，分别如下：</p>

		<ul>
		<li><span class="text_import2">enforcing</span>：强制模式，代表 SELinux 运行中，且已经正确的开始限制 domain/type 了；</li>
		<li><span class="text_import2">permissive</span>：宽容模式：代表 SELinux 运行中，不过仅会有警告信息并不会实际限制 
		domain/type 的存取。这种模式可以运来作为 SELinux 的 debug 之用；</li>
		<li><span class="text_import2">disabled</span>：关闭，SELinux 并没有实际运行。</li>
		</ul>

		<a name="getenforce"></a>
		<p>那你怎么知道目前的 SELinux 模式呢？就透过 getenforce 吧！</p>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">getenforce</span>
Enforcing  <span class="term_note">&lt;==诺！就显示出目前的模式为 Enforcing 罗！</span>
</pre></td></tr></tbody></table>

		<a name="sestatus"></a>
		<p>另外，我们又如何知道 SELinux 的政策 (Policy) 为何呢？这时可以使用 sestatus 来观察：</p>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">sestatus [-vb]</span>
<span class="term_say">选项与参数：
-v  ：检查列於 /etc/sestatus.conf 内的文件与程序的安全性本文内容；
-b  ：将目前政策的守则布林值列出，亦即某些守则 (rule) 是否要启动 (0/1) 之意；</span>

<span class="term_hd">范例一：列出目前的 SELinux 使用哪个政策 (Policy)？</span>
[root@www ~]# <span class="term_command">sestatus</span>
SELinux status:                 enabled    <span class="term_note">&lt;==是否启动 SELinux</span>
SELinuxfs mount:                /selinux   <span class="term_note">&lt;==SELinux 的相关文件数据挂载点</span>
Current mode:                   enforcing  <span class="term_note">&lt;==目前的模式</span>
Mode from config file:          enforcing  <span class="term_note">&lt;==配置档指定的模式</span>
Policy version:                 21
Policy from config file:        targeted   <span class="term_note">&lt;==目前的政策为何？</span>
</pre></td></tr></tbody></table>

		<p>如上所示，目前是启动的，而且是 Enforcing 模式，而由配置档查询得知亦为 Enforcing 模式。
		此外，目前的默认政策为 targeted 这一个。你应该要有疑问的是， SELinux 的配置档是哪个文件啊？
		其实就是 /etc/selinux/config 这个文件喔！我们来看看内容：</p>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">vi /etc/selinux/config</span>
SELINUX=enforcing     <span class="term_note">&lt;==调整 enforcing|disabled|permissive</span>
SELINUXTYPE=targeted  <span class="term_note">&lt;==目前仅有 targeted 与 strict</span>
</pre></td></tr></tbody></table>

		<a name="on_off"></a>
		<hr><ul class="list1"><li class="text_import1">SELinux 的启动与关闭</li></ul>

		<p>上面是默认的政策与启动的模式！你要注意的是，如果改变了政策则需要重新启动；如果由 enforcing 或 permissive
		改成 disabled ，或由 disabled 改成其他两个，那也必须要重新启动。这是因为 SELinux 是整合到核心里面去的，
		你只可以在 SELinux 运行下切换成为强制 (enforcing) 或宽容 (permissive) 模式，不能够直接关闭 SELinux 的！
		同时，由 SELinux 关闭 (disable) 的状态到开启的状态也需要重新启动啦！所以，如果刚刚你发现 getenforce 出现 disabled 时，
		请到上述文件修改成为 enforcing 吧！</p>

		<p>所以，如果你要启动 SELinux 的话，请将上述的 SELINUX=enforcing 配置妥当，并且指定 SELINUXTYPE=targeted 这一个配置，
		并且到 /boot/grub/menu.lst 这个文件去，看看核心有无关闭 SELinux 了呢？</p>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">vi /boot/grub/menu.lst</span>
default=0
timeout=5
splashimage=(hd0,0)/grub/splash.xpm.gz
hiddenmenu
title CentOS (2.6.18-92.el5)
        root (hd0,0)
        <span class="term_write">kernel /vmlinuz-2.6.18-92.el5 ro root=LABEL=/1 rhgb quiet <s>selinux=0</s></span>
        initrd /initrd-2.6.18-92.el5.img
<span class="term_say"># 如果要启动 SELinux ，则不可以出现 selinux=0 的字样在 kernel 后面！</span>
</pre></td></tr></tbody></table>

		<p>请注意到上面特殊字体的那一行，确认 kernel 后面不可以接『 selinux=0 』这个项目！因为 selinux=0 指定给核心时，
		则核心会自动的忽略 /etc/selinux/config 的配置值，而直接略过 SELinux 的加载，所以你的 SELinux 模式就会变成 disabled 
		啦！因为我们要启动，所以<span class="text_import2">这里得要确认不存在 selinux=0 才行</span>！切记切记！
		如果一切配置妥当，接下来就是 reboot 重新启动吧！</p>

		<p>不过你要注意的是，如果从 disable 转到启动 SELinux 的模式时，
		由於系统必须要针对文件写入安全性本文的资讯，因此启动过程会花费不少时间在等待重新写入 SELinux 安全性本文 
		(有时也称为 SELinux Label) ，而且在写完之后还得要再次的重新启动一次喔！你必须要等待粉长一段时间！
		等到下次启动成功后，再使用 <a href="http://cn.linux.vbird.org/linux_basic/0440processcontrol.php#getenforce">getenforce</a> 或 <a href="http://cn.linux.vbird.org/linux_basic/0440processcontrol.php#sestatus">sestatus</a>
		来观察看看有否成功的启动到 Enforcing 的模式罗！</p>

		<a name="setenforce"></a>
		<p>如果你已经在 Enforcing 的模式，但是可能由於一些配置的问题导致 SELinux 让某些服务无法正常的运行，
		此时你可以将 Enforcing 的模式改为宽容 (permissive) 的模式，让 SELinux 只会警告无法顺利连线的信息，
		而不是直接抵挡主体程序的读取权限。让 SELinux 模式在 enforcing 与 permissive 之间切换的方法为：</p>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">setenforce [0|1]</span>
<span class="term_say">选项与参数：
0 ：转成 permissive 宽容模式；
1 ：转成 Enforcing 强制模式</span>

<span class="term_hd">范例一：将 SELinux 在 Enforcing 与 permissive 之间切换与观察</span>
[root@www ~]# <span class="term_command">setenforce 0</span>
[root@www ~]# <span class="term_command">getenforce</span>
Permissive
[root@www ~]# <span class="term_command">setenforce 1</span>
[root@www ~]# <span class="term_command">getenforce</span>
Enforcing
</pre></td></tr></tbody></table>

		<p>不过请注意， setenforce 无法在 Disabled 的模式底下进行模式的切换喔！</p>
	</div>

	<hr><a name="selinux_http"></a><img src="./鸟哥的 Linux 私房菜18 -- 程序管理与 SELinux 初探_files/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">SELinux 网络服务运行范例</span><br>
	<div class="block2">
		<p>由於 CentOS 5.x 默认使用 targeted 这个政策，而这个政策主要是在管理网络服务，本机端的程序则比较不受 SELinux 的管制。
		既然上头我们曾经举过 /usr/sbin/httpd 这个程序来当作范例，那么我们就使用 WWW 服务器来说明一下 SELinux 
		的运行方式吧。<br><br></p>

		<a name="selinux_http_start"></a>
		<hr><ul class="list1"><li class="text_import1">网络服务的启动与观察</li></ul>
		<p>首先，让我们启动 httpd 这支服务吧！要记得的是，一般服务启动的脚本会在 /etc/init.d/ 底下，
		所以我们可以这样启动与观察：</p>

<a name="ps_z"></a>
<table class="term"><tbody><tr><td class="term"><pre><span class="term_hd"># 1. 先启动这个网络服务吧！</span>
[root@www ~]# <span class="term_command">/etc/init.d/httpd start</span>
正在启动 httpd:          [  确定  ]

<span class="term_hd"># 2. 观察有无此程序，并且观察此程序的 SELinux 安全性本文数据</span>
[root@www ~]# <span class="term_command">pstree | grep httpd</span>
     |-httpd---8*[httpd]   <span class="term_note">&lt;==httpd 会产生很多子程序来负责网络服务喔！</span>

[root@www ~]# <span class="term_command">ps aux -Z |grep http</span>
<span style="font-size: 9pt;">root:system_r:<span class="term_write">httpd_t</span> root   24089 0.2 1.2 22896 9256 ? Ss 16:06 0:00 /usr/sbin/httpd
root:system_r:<span class="term_write">httpd_t</span> apache 24092 0.0 0.6 22896 4752 ? S  16:06 0:00 /usr/sbin/httpd
root:system_r:<span class="term_write">httpd_t</span> apache 24093 0.0 0.6 22896 4752 ? S  16:06 0:00 /usr/sbin/httpd</span>
<span class="term_say">....(后面省略)....</span>
</pre></td></tr></tbody></table>

		<p>ps -Z 这个『 -Z 』的选项可以让我们查阅程序的安全性本文！其他相关的程序说明请自行查阅本章上面各节的内容。
		我们可以发现这整个程序的 domain 是 httpd_t 这个咚咚喔！再来我们来处理一下首页的数据先。
		由於首页是放置到 /var/www/html，且档名应该要是『 index.html 』，因此我们可以这样简单的制作首页：</p>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">echo "This is my first web page." &gt; /var/www/html/index.html</span>
</pre></td></tr></tbody></table>

		<p>接下来，如果你在浏览器上面输入『 http://127.0.0.1 』应该会看到如下的画面才对！</p>

		<center><img src="./鸟哥的 Linux 私房菜18 -- 程序管理与 SELinux 初探_files/httpd_1.gif" alt="httpd 顺利运行时，能够看到的首页画面" title="httpd 顺利运行时，能够看到的首页画面" border="1"><br>
		图 5.4.1、httpd 顺利运行时，能够看到的首页画面<br></center>

		<p>此时你的浏览器会透过 httpd 这个程序拥有的 httpd_t 这个 domain 去读取 /var/www/html/index.html 这个文件的！
		先来看看这个文件的权限与 SELinux 的安全性本文数据：</p>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">ll -Z /var/www/html/index.html</span>
<span class="term_write">-rw-r--r--</span> root root root:object_r:<span class="term_write">httpd_sys_content_t</span> /var/www/html/index.html
</pre></td></tr></tbody></table>

		<p>权限是 apache 可以读取的 r 标志，而 SELinux 则是 httpd_sys_content_t 的类型 (type)，也是 httpd_t 能读取的哩！
		那么为何 httpd_t 可以读取呢？因为 targeted 政策里面有配置嘛！关於政策配置的查询我们可以在后续跟大家作介绍，
		这里先了解一下即可。<br><br></p>

		<a name="selinux_http_error"></a>
		<hr><ul class="list1"><li class="text_import1">错误的 SELinux 安全性本文</li></ul>

		<p>让我们来了解一下什么是错误的安全性本文配置好了！现在，我们将重要的网页数据在 root 的家目录底下制作！
		配置如下：</p>

<table class="term"><tbody><tr><td class="term"><pre><span class="term_hd"># 1. 先在 root 的家目录建置所需的首页：</span>
[root@www ~]# <span class="term_command">echo "My 2nd web page..." &gt; index.html</span>

<span class="term_hd"># 2. 将首页 index.html 『搬移』到 /var/www/html 目录去：</span>
[root@www ~]# <span class="term_command">rm /var/www/html/index.html</span>
[root@www ~]# <span class="term_command">mv index.html /var/www/html</span>
<span class="term_say"># 这个测试的重点在 mv 这个命令的处理上！务必使用 mv 喔！</span>
</pre></td></tr></tbody></table>

		<p>等到上述的动作都做完后，如果在浏览器输入 http://127.0.0.1/index.html ，你应该会想到画面会出现我们想要的『 My 2nd web 
		page...』才对，但是结果却变成：</p>

		<center><img src="./鸟哥的 Linux 私房菜18 -- 程序管理与 SELinux 初探_files/httpd_2.gif" alt="错误的安全性本文所造成的困扰" title="错误的安全性本文所造成的困扰" border="1"><br>
		图 5.4.2、错误的安全性本文所造成的困扰<br></center>

		<p>记得要在网址列指定 index.html 否则出现的会变成欢迎首页的画面。而萤幕上出现的错误信息是没有权限
		(You don't have permission...)。看看这个 /var/www/html/index.html 的权限吧！</p>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">ll -Z /var/www/html/index.html</span>
<span class="term_write">-rw-r--r--</span> root root root:object_r:<span class="term_write">user_home_t</span> /var/www/html/index.html
</pre></td></tr></tbody></table>

		<p>你会发现，权限是对的 (apache 使用者依旧可以读取)，但是安全性本文内容却是使用者家目录呢！
		真是要命！这个使用者家目录默认可不能给 httpd_t 这个 domain 读取的！所以就产生错误啦！那该如何处置呢？<br><br></p>

		<a name="selinux_http_resolv"></a>
		<hr><ul class="list1"><li class="text_import1">重设 SELinux 安全性本文</li></ul>

		<p>既然安全性本文是错的，那么就将他改回来即可嘛！怎么修改呢？可以透过两个命令喔！首先我们使用 chcon 来处理：</p>

<a name="chcon"></a>
<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">chcon [-R] [-t type] [-u user] [-r role] 文件</span>
[root@www ~]# <span class="term_command">chcon [-R] --reference=范例档 文件</span>
<span class="term_say">选项与参数：
-R  ：连同该目录下的次目录也同时修改；
-t  ：后面接安全性本文的类型栏位！例如 httpd_sys_content_t ；
-u  ：后面接身份识别，例如 system_u；
-r  ：后面街角色，例如 system_r；
--reference=范例档：拿某个文件当范例来修改后续接的文件的类型！</span>

<span class="term_hd">范例一：将刚刚的 index.html 类型改为 httpd_sys_content_t 的类型</span>
[root@www ~]# <span class="term_command">chcon -t httpd_sys_content_t /var/www/html/index.html</span>
[root@www ~]# <span class="term_command">ll -Z /var/www/html/index.html</span>
-rw-r--r--  root root root:object_r:<span class="term_write">httpd_sys_content_t</span> /var/www/html/index.html
<span class="term_say"># 瞧！这样就改回来啦！</span>

<span class="term_hd">范例二：以 /etc/passwd 为依据，将 index.html 修改成该类型</span>
[root@www ~]# <span class="term_command">ll -Z /etc/passwd</span>
-rw-r--r--  root root system_u:object_r:<span class="term_write">etc_t</span>          /etc/passwd

[root@www ~]# <span class="term_command">chcon --reference=/etc/passwd /var/www/html/index.html</span>
[root@www ~]# <span class="term_command">ll -Z /var/www/html/index.html</span>
-rw-r--r--  root root root:object_r:<span class="term_write">etc_t</span> /var/www/html/index.html
<span class="term_say"># 看看！是否与上面的 /etc/passwd 相同了！不过，这又是错误的安全性本文！
# 先不要急著修改！我们来进行底下的另外一个命令处置看看！</span>
</pre></td></tr></tbody></table>

		<a name="restorecon"></a>
		<p>chcon 是透过直接指定的方式来处理安全性本文的类型数据。那我们知道其实系统默认的目录都有特殊的 SELinux 安全性本文，
		举例来说， /var/www/html 原本就是 httpd 可以读取的目录嘛！既然如此，那有没有可以使用默认的安全性本文来还原的方式？
		有的，那就是 restorecon 这玩意儿：</p>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">restorecon [-Rv] 文件或目录</span>
<span class="term_say">选项与参数：
-R  ：连同次目录一起修改；
-v  ：将过程显示到萤幕上</span>

<span class="term_hd">范例一：将刚刚错误的 index.html 以默认的安全性本文改正过来</span>
[root@www ~]# <span class="term_command">restorecon -Rv /var/www/html/index.html</span>
restorecon reset /var/www/html/index.html context system_u:object_r:<span class="term_write">etc_t</span>:s0-&gt;
system_u:object_r:<span class="term_write">httpd_sys_content_t</span>:s0
<span class="term_say"># 上面这两行其实是同一行喔！表示将 index.html 由 etc_t 改为 httpd_sys_content_t</span>
</pre></td></tr></tbody></table>

		<p>然后回到刚刚图 5.4.2 给他重读一下，嘿嘿！又可以看到正确的内容啦！这个过程完全没有动到 rwx 权限，
		因为该权限本来就是对的！而错的部分是在於 SELinux 的安全性本文当中那个类型 (type) 配置错误！
		而配置错误的原因很可能是因为该文件由其他位置复制或移动过来所导致的！因此，
		你得要善用 restorecon 以及 chcon 来处理这方面的问题喔！</p>
	</div>

	<hr><a name="selinux_daemon"></a><img src="./鸟哥的 Linux 私房菜18 -- 程序管理与 SELinux 初探_files/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">SELinux 所需的服务</span><br>
	<div class="block2">
		<p>由於 SELinux 是整合到核心的一个核心功能，因此你几乎不需要启动什么额外的服务来开启 SELinux 的。
		启动完成后， SELinux 就启动了。不过，你刚刚也发现到当我们复制或移动某些数据到特定的目录时，
		可能由於没有注意到修改 SELinux 的安全性本文内容，结果导致网络服务无法顺利运行的问题！
		有没有什么方法可以记录当发生 SELinux 错误时，将那些有用的资讯记录下来，并且提供解决的方案呢？
		此时就得要底下的几个服务的辅助罗！<br><br></p>

		<a name="setroubleshoot"></a>
		<hr><ul class="list1"><li class="text_import1">setroubleshoot --&gt; 错误信息写入 /var/log/messages</li></ul>

		<p>几乎所有 SELinux 相关的程序都会以 se 为开头，这个服务也是以 se 为开头！而 troubleshoot 大家都知道是错误克服，
		因此这个 setroubleshoot 自然就得要启动他啦！这个服务会将关於 SELinux  的错误信息与克服方法记录到 /var/log/messages 
		里头，所以你一定得要启动这个服务才好。那如何在启动的时候就启动 setroubleshoot 呢？这样处理先：</p>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">chkconfig --list setroubleshoot</span>
setroubleshoot  0:off  1:off  2:off 3:on  4:on  5:on  6:off
<span class="term_say"># 我们的 Linux 运行模式是在 3 或 5 号，因此这两个要 on 即可。</span>

[root@www ~]# <span class="term_command">chkconfig setroubleshoot on</span>
<span class="term_say"># 关於 chkconfig 我们会在后面章节介绍， --list 是列出目前的运行等级是否有启动，
# 如果加上 on ，则是在启动时启动，若为 off 则启动时不启动。</span>
</pre></td></tr></tbody></table>

		<p>这支服务默认几乎都会启动啦！除非你看到 3:off 或 5:off 时，才需要以『 chkconfig setroubleshoot on 』
		去配置一下。那么如果有发生错误时，信息像什么呢？我们刚刚不是以浏览器浏览 index.html 并导致错误吗？
		那就将该错误捉来瞧瞧！</p>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">cat /var/log/messages | grep setroubleshoot</span>
Mar 23 17:18:44 www setroubleshoot: SELinux is preventing the httpd from using 
potentially mislabeled files (/var/www/html/index.html). For complete SELinux 
messages. run <span class="term_write">sealert -l 6c028f77-ddb6-4515-91f4-4e3e719994d4</span>
</pre></td></tr></tbody></table>

		<p>上面的错误信息可是同一行喔！大纲说的是『SElinux 被用来避免 httpd 读取到错误的安全性本文，
		想要查阅完整的数据，请运行 sealert -l 6c02...』没错！你注意到了！重点就是 sealert -l 啦！
		上面提供的资讯并不完整，想要更完整的说明得要靠 sealert 配合侦测到的错误代码来处理。
		实际处理后会像这样：</p>

		<a name="sealert"></a>
<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">sealert -l 6c028f77-ddb6-4515-91f4-4e3e719994d4</span>
Summary:

SELinux is preventing the httpd from using potentially mislabeled files
(/var/www/html/index.html). <span class="term_note">&lt;==就是刚刚 /var/log/messages 的信息</span>

Detailed Description:       <span class="term_note">&lt;==底下是更完整的描述！要看！</span>

SELinux has denied httpd access to potentially mislabeled file(s)
(/var/www/html/index.html). This means that SELinux will not allow httpd to use
these files. It is common for users to edit files in their home directory or tmp
directories and then move (mv) them to system directories. The problem is that
the files end up with the wrong file context which confined applications are not
allowed to access.

Allowing Access:            <span class="term_note">&lt;==若要允许存取，你需要进行的动作！</span>

If you want httpd to access this files, you need to relabel them using
<span class="term_write">restorecon -v '/var/www/html/index.html'</span>. You might want to relabel the entire
directory using <span class="term_write">restorecon -R -v '/var/www/html'</span>.
<span class="term_say">....(底下省略)....</span>
</pre></td></tr></tbody></table>

		<p>重点就是上面特殊字体显示的地方！你只要照著『Allowing Access』里面的提示去进行处理，
		就能够完成你的 SELinux 类型配置了！比对刚刚我们上个小节提到的 <a href="http://cn.linux.vbird.org/linux_basic/0440processcontrol.php#restorecon">restorecon</a>
		与 <a href="http://cn.linux.vbird.org/linux_basic/0440processcontrol.php#chcon">chcon</a> 你就能够知道， setroubleshoot 提供的信息有多有效了吧！<br><br></p>

		<a name="auditd"></a>
		<hr><ul class="list1"><li class="text_import1">auditd --&gt; 详细数据写入 /var/log/audit/audit.log</li></ul>

		<p>audit 是稽核的意思，这个 auditd 会将 SELinux 发生的错误资讯写入 /var/log/audit/audit.log 中！
		与上个服务相同的，你最好在启动时就配置这服务为启动的模式，因此可以照样造句：</p>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">chkconfig --list auditd</span>
auditd      0:off  1:off  2:on   3:on   4:on   5:on   6:off

[root@www ~]# <span class="term_command">chkconfig auditd on</span>
<span class="term_say"># 若 3:off 及 5:off 时，才需要进行！</span>
</pre></td></tr></tbody></table>

		<p>与 setroubleshoot 不同的是， auditd 会将许多的 SELinux 资讯都记录下来，不只是错误信息而已，
		因此登录档 /var/log/audit/audit.log 非常的庞大！要直接到这文件里面去搜寻数据是挺累人的～
		还好，SELinux 有提供一个 audit2why 的命令来让我们查询错误信息的回报呢！那么这个命令如何使用呢？
		可以这样用的：</p>

<a name="audit2why"></a>
<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">audit2why &lt; /var/log/audit/audit.log</span>
<span class="term_say"># 意思是，将登录档的内容读进来分析，并输出分析的结果！结果有点像这样：</span>
type=AVC msg=audit(1237799959.349:355): avc:  denied  { getattr } for  pid=24094 
comm="<span class="term_write">httpd</span>" path="<span class="term_write">/var/www/html/index.html</span>" dev=hda2 ino=654685 scontext=root:s
ystem_r:<span class="term_write">httpd_t</span>:s0 tcontext=root:object_r:<span class="term_write">user_home_t</span>:s0 tclass=file
    Was caused by:
       Missing or disabled TE allow rule.
       Allow rules may exist but be disabled by boolean settings; check boolean
settings.
       You can see the necessary allow rules by running audit2allow with this
audit message as input.
</pre></td></tr></tbody></table>

		<p>audit2why 的用法与输出结果如上，比较有趣的是那个 AVC ，AVC 是 access vector cache 的缩写，
		目的是记录所有与 SELinux 有关的存取统计数据。输出的资讯当中，会有谈到产生错误的问题为何，如上表特殊字体部分，
		你会发现错误信息主要告知 type 不符，所以导致错误的发生啊！不过，就鸟哥来看，我个人觉得 setroubleshoot 比较好用呢！
		这两个好东西都可以帮助你解决 SELinux 的错误，因此，请务必至少要学会其中一项错误分析的方法喔！</p>
	</div>

	<hr><a name="selinux_policy"></a><img src="./鸟哥的 Linux 私房菜18 -- 程序管理与 SELinux 初探_files/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">SELinux 的政策与守则管理</span><br>
	<div class="block2">
		<p>现在你应该知道，一个主体程序能否读取到目标文件资源的重点在於 SELinux 的政策以及政策内的各项守则，
		然后再透过该守则的定义去处理各目标文件的安全性本文，尤其是『类型』的部分。现在我们也知道可以透过
		<a href="http://cn.linux.vbird.org/linux_basic/0440processcontrol.php#sestatus">sestatus</a> 与 <a href="http://cn.linux.vbird.org/linux_basic/0440processcontrol.php#getenforce">getenforce</a> 去取得目前的 SELinux 状态。
		但是，能不能知道更详细的政策说明与守则项目呢？底下我们就来了解了解！<br><br></p>

		<hr><ul class="list1"><li class="text_import1">政策查阅</li></ul>

		<p>CentOS 5.x 默认使使用 targeted 政策，那么这个政策提供多少相关的守则呢？此时可以透过 seinfo 来查询喔！</p>

<a name="seinfo"></a>
<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">seinfo [-Atrub]</span>
<span class="term_say">选项与参数：
-A  ：列出 SELinux 的状态、守则布林值、身份识别、角色、类别等所有资讯
-t  ：列出 SELinux 的所有类别 (type) 种类
-r  ：列出 SELinux 的所有角色 (role) 种类
-u  ：列出 SELinux 的所有身份识别 (user) 种类
-b  ：列出所有守则的种类 (布林值)</span>

<span class="term_hd">范例一：列出 SELinux 在此政策下的统计状态</span>
[root@www ~]# <span class="term_command">seinfo</span>
Statistics for policy file: /etc/selinux/targeted/policy/policy.21
Policy Version &amp; Type: v.21 (binary, MLS) <span class="term_note">&lt;==列出政策所在档与版本</span>

   Classes:            61    Permissions:       220
   <span class="term_write">Types:            1521</span>    Attributes:        155
   Users:               3    Roles:               6
   <span class="term_write">Booleans:          213</span>    Cond. Expr.:       190
   Sensitivities:       1    Categories:       1024
   Allow:           86561    Neverallow:          0
   Auditallow:         34    Dontaudit:        5460
   Role allow:          5    Role trans:          0
<span class="term_say">....(底下省略)....
# 从上面我们可以看到这个政策是 targeted ，此政策的安全性本文类别有 1521 个；
# 而针对网络服务的守则 (Booleans) 共制订了 213 条守则！</span>

<span class="term_hd">范例二：列出与 httpd 有关的守则 (booleans) 有哪些？</span>
[root@www ~]# <span class="term_command">seinfo -b | grep httpd</span>
Rule loading disabled
   allow_httpd_mod_auth_pam
   allow_httpd_bugzilla_script_anon_write
   httpd_enable_ftp_server
<span class="term_say">....(底下省略)....
# 你可以看到，有非常多的与 httpd 有关的守则订定呢！</span>
</pre></td></tr></tbody></table>

		<p>从上面我们可以看到与 httpd 有关的布林值，同样的，如果你想要找到有 httpd 字样的安全性本文类别时，
		就可以使用『 seinfo -t | grep httpd 』来查询了！如果查询到相关的类别或者是布林值后，想要知道详细的守则时，
		就得要使用 sesearch  这个命令了！</p>

<a name="sesearch"></a>
<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">sesearch [-a] [-s 主体类别] [-t 目标类别] [-b 布林值]</span>
<span class="term_say">选项与参数：
-a  ：列出该类别或布林值的所有相关资讯
-t  ：后面还要接类别，例如 -t httpd_t
-b  ：后面还要接布林值的守则，例如 -b httpd_enable_ftp_server</span>

<span class="term_hd">范例一：找出目标文件资源类别为 httpd_sys_content_t 的有关资讯</span>
[root@www ~]# <span class="term_command">sesearch -a -t httpd_sys_content_t</span>
Found 74 av rules:
   allow readahead_t httpd_sys_content_t : file { ioctl read getattr lock };
   allow readahead_t httpd_sys_content_t : dir { ioctl read getattr lock search };
<span class="term_say">....(底下省略)....
# 『 allow  主体程序安全性本文类别  目标文件安全性本文类别 』
# 如上，说明这个类别可以被那个主题程序的类别所读取，以及目标文件资源的格式。</span>

<span class="term_hd">范例二：找出主体程序为 httpd_t 且目标文件类别为 httpd 相关的所有资讯</span>
[root@www ~]# <span class="term_command">sesearch -s httpd_t -t httpd_* -a</span>
Found 163 av rules:
<span class="term_say">....(中间省略)....</span>
   allow httpd_t httpd_sys_content_t : file { ioctl read getattr lock };
   allow httpd_t httpd_sys_content_t : dir { ioctl read getattr lock search };
   allow httpd_t httpd_sys_content_t : lnk_file { ioctl read getattr lock };
<span class="term_say">....(后面省略)....
# 从上面的数据就可以看出当程序为 httpd_t 这个类别，是可以读取 
# httpd_sys_content_t 的！</span>
</pre></td></tr></tbody></table>

		<p>你可以很轻易的查询到某个主体程序 (subject) 可以读取的目标文件资源 (Object) ，
		从我们上面的练习，我们也可以很轻松的就知道，为何 httpd_t 可以读取 httpd_sys_content_t 罗！
		那如果是布林值呢？里面又规范了什么？让我们来看看先：</p> 

<table class="term"><tbody><tr><td class="term"><pre><span class="term_hd">范例三：我知道有个布林值为 httpd_enable_homedirs ，请问该布林值规范多少守则？</span>
[root@www ~]# <span class="term_command">sesearch -b httpd_enable_homedirs -a</span>
Found 21 av rules:
   allow httpd_t user_home_dir_t : dir { getattr search };
   allow httpd_t cifs_t : file { ioctl read getattr lock };
   allow httpd_t cifs_t : dir { ioctl read getattr lock search };
<span class="term_say">....(后面省略)....</span>
</pre></td></tr></tbody></table>

		<p>从这个布林值的配置我们可以看到里面规范了非常多的主体程序与目标文件资源的放行与否！
		所以你知道了，实际规范这些守则的，就是布林值的项目啦！那也就是我们之前所说的一堆守则是也！
		你的主体程序能否对某些目标文件进行存取，与这个布林值非常有关系喔！因为布林值可以将守则配置为启动 (1) 
		或者是关闭 (0) 啦！</p>

		<p>由 seinfo 与 sesearch 的输出资讯，我们也会得到实际的政策数据都是放置到 /etc/selinux/targeted/policy/ 底下，
		事实上，所有与 targetd 相关的资讯都是放置到 /etc/selinux/targeted 里面的呢！包括安全性本文相关的资讯。
		这部分等一下谈到安全性本文的默认值修改时，我们再来讨论。<br><br></p>

		<hr><ul class="list1"><li class="text_import1">布林值的查询与修改</li></ul>

		<p>上面我们透过 sesearch 知道了，其实 Subject 与 Object 能否有存取的权限，是与布林值有关的，
		那么系统有多少布林值可以透过 seinfo -b 来查询，但，每个布林值是启动的还是关闭的呢？这就来查询看看吧：</p>

<a name="getsebool"></a>
<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">getsebool [-a] [布林值条款]</span>
<span class="term_say">选项与参数：
-a  ：列出目前系统上面的所有布林值条款配置为开启或关闭值</span>

<span class="term_hd">范例一：查询本系统内所有的布林值配置状况</span>
[root@www ~]# <span class="term_command">getsebool -a</span>
NetworkManager_disable_trans --&gt; off
allow_console_login --&gt; off
allow_cvs_read_shadow --&gt; off
allow_daemons_dump_core --&gt; on
<span class="term_say">....(底下省略)....
# 您瞧！这就告诉你目前的布林值状态罗！</span>
</pre></td></tr></tbody></table>

		<p>那么如果查询到某个布林值，并且以 sesearch 知道该布林值的用途后，想要关闭或启动他，又该如何处置？</p>

<a name="setsebool"></a>
<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">setsebool [-P] 布林值=[0|1]</span>
<span class="term_say">选项与参数：
-P  ：直接将配置值写入配置档，该配置数据未来会生效的！</span>

<span class="term_hd">范例一：查询 httpd_enable_homedirs 是否为关闭，若不为关闭，请关闭他！</span>
[root@www ~]# <span class="term_command">getsebool httpd_enable_homedirs</span>
httpd_enable_homedirs --&gt; on  <span class="term_note">&lt;==结果是 on ，依题意给他关闭！</span>

[root@www ~]# <span class="term_command">setsebool -P httpd_enable_homedirs=0</span>
[root@www ~]# <span class="term_command">getsebool httpd_enable_homedirs</span>
httpd_enable_homedirs --&gt; off
</pre></td></tr></tbody></table>

		<p>这个 setsebool 最好记得一定要加上 -P 的选项！因为这样才能将此配置写入配置档！
		这是非常棒的工具组！你一定要知道如何使用 getsebool 与 setsebool 才行！<br><br></p>


		<hr><ul class="list1"><li class="text_import1">默认目录的安全性本文查询与修改</li></ul>

		<p>还记得我们在使用 <a href="http://cn.linux.vbird.org/linux_basic/0440processcontrol.php#restorecon">restorecon</a> 时谈到每个目录或文件都会有默认的安全性本文吗？
		会制订目录的安全性本文，是因为系统的一些服务所放置文件的目录已经是确定的，当然有默认的安全性本文管理上较方便。
		那你如何查询这些目录的默认安全性本文呢？就得要使用 semanage 罗！</p>

<a name="semanage"></a>
<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">semanage {login|user|port|interface|fcontext|translation} -l</span>
[root@www ~]# <span class="term_command">semanage fcontext -{a|d|m} [-frst] file_spec</span>
<span class="term_say">选项与参数：
fcontext ：主要用在安全性本文方面的用途， -l 为查询的意思；
-a ：添加的意思，你可以添加一些目录的默认安全性本文类型配置；
-m ：修改的意思；
-d ：删除的意思。</span>

<span class="term_hd">范例一：查询一下 /var/www/html 的默认安全性本文配置为何！</span>
[root@www ~]# <span class="term_command">semanage fcontext -l</span>
SELinux fcontext    type          Context
<span class="term_say">....(前面省略)....</span>
/var/www(/.*)?      all files     system_u:object_r:httpd_sys_content_t:s0
<span class="term_say">....(后面省略)....</span>
</pre></td></tr></tbody></table>

		<p>从上面的说明，我们知道其实 semanage 可以处理非常多的任务，不过，在这个小节我们主要想了解的是每个目录的默认安全性本文。
		如上面范例一所示，我们可以查询的到每个目录的安全性本文啦！而目录的配置可以使用<a href="http://cn.linux.vbird.org/linux_basic/0330regularex.php">正规表示法</a>去指定一个范围。那么如果我们想要添加某些自订的目录的安全性本文呢？
		举例来说，我想要制订 /srv/samba 成为 public_content_t 的类型时，应该如何指定呢？</p>

<table class="term"><tbody><tr><td class="term"><pre><span class="term_hd">范例二：利用 semanage 配置 /srv/samba 目录的默认安全性本文为 public_content_t</span>
[root@www ~]# <span class="term_command">mkdir /srv/samba</span>
[root@www ~]# <span class="term_command">ll -Zd /srv/samba</span>
drwxr-xr-x  root root root:object_r:<span class="term_write">var_t</span>    /srv/samba
<span class="term_say"># 如上所示，默认的情况应该是 var_t 这个咚咚的！</span>

[root@www ~]# <span class="term_command">semanage fcontext -l | grep '/srv'</span>
/srv/.*                     all files   system_u:object_r:var_t:s0
/srv/([^/]*/)?ftp(/.*)?     all files   system_u:object_r:public_content_t:s0
/srv/([^/]*/)?www(/.*)?     all files   system_u:object_r:httpd_sys_content_t:s0
/srv/([^/]*/)?rsync(/.*)?   all files   system_u:object_r:public_content_t:s0
/srv/gallery2(/.*)?         all files   system_u:object_r:httpd_sys_content_t:s0
/srv                        directory   system_u:object_r:var_t:s0 <span class="term_note">&lt;==看这里！</span>
<span class="term_say"># 上面则是默认的 /srv 底下的安全性本文数据，不过，并没有指定到 /srv/samba 啦</span>

[root@www ~]# <span class="term_command">semanage fcontext -a -t public_content_t "/srv/samba(/.*)?"</span>
[root@www ~]# <span class="term_command">semanage fcontext -l | grep '/srv/samba'</span>
/srv/samba(/.*)?            all files   system_u:object_r:public_content_t:s0

[root@www ~]# <span class="term_command">cat /etc/selinux/targeted/contexts/files/file_contexts.local</span>
# This file is auto-generated by libsemanage
# Please use the semanage command to make changes
/srv/samba(/.*)?    system_u:object_r:public_content_t:s0
<span class="term_say"># 其实就是写入这个文件的罗！ ^_^</span>

[root@www ~]# <span class="term_command">restorecon -Rv /srv/samba*</span> <span class="term_note">&lt;==尝试恢复默认值</span>
[root@www ~]# <span class="term_command">ll -Zd /srv/samba</span>
drwxr-xr-x  root root system_u:object_r:<span class="term_write">public_content_t</span> /srv/samba/
<span class="term_say"># 有默认值，以后用 restorecon 来修改比较简单！</span>
</pre></td></tr></tbody></table>

		<p>semanage 的功能很多，不过鸟哥主要用到的仅有 fcontext 这个项目的动作而已。如上所示，
		你可以使用 semanage 来查询所有的目录默认值，也能够使用他来添加默认值的配置！如果您学会这些基础的工具，
		那么 SELinux 对你来说，也不是什么太难的咚咚罗！</p>
	</div>
</div>


<hr><a name="hint"></a><img src="./鸟哥的 Linux 私房菜18 -- 程序管理与 SELinux 初探_files/logo.png" alt="大标题的图示" width="35" align="middle" height="34"><span class="text_h1">重点回顾</span><br>
<div class="block1">
<ul class="text_import2">
	<li>程序 (program)：通常为 binary program ，放置在储存媒体中 (如硬盘、光盘、软盘、磁带等)，为实体文件的型态存在；</li>
	<li>程序 (process)：程序被触发后，运行者的权限与属性、程序的程序码与所需数据等都会被加载内存中，
		操作系统并给予这个内存内的单元一个识别码 (PID)，可以说，程序就是一个正在运行中的程序。</li>
	<li>程序彼此之间是有相关性的，故有父程序与子程序之分。而 Linux 系统所有程序的父程序就是 init 这个 PID 为 1 号的程序。</li>
	<li>在 Linux 的程序呼叫通常称为 fork-and-exec 的流程！程序都会藉由父程序以复制 (fork) 的方式产生一个一模一样的子程序，
		然后被复制出来的子程序再以 exec 的方式来运行实际要进行的程序，最终就成为一个子程序的存在。</li>
	<li>常驻在内存当中的程序通常都是负责一些系统所提供的功能以服务使用者各项任务，因此这些常驻程序就会被我们称为：服务 
		(daemon)。</li>
	<li>在工作管理 (job control) 中，可以出现提示字节让你操作的环境就称为前景 (foreground)，至於其他工作就可以让你放入背景 
		(background) 去暂停或运行。</li>
	<li>与 job control 有关的按键与关键字有： &amp;, [ctrl]-z, jobs, fg, bg, kill %n 等；</li>
	<li>程序管理的观察命令有： ps, top, pstree 等等；</li>
	<li>程序之间是可以互相控制的，传递的信息 (signal) 主要透过 kill 这个命令在处理；</li>
	<li>程序是有优先顺序的，该项目为 Priority，但 PRI 是核心动态调整的，使用者只能使用 nice 值去微调 PRI</li>
	<li>nice 的给予可以有： nice, renice, top 等命令；</li>
	<li>vmstat 为相当好用的系统资源使用情况观察命令；</li>
	<li>SELinux 当初的设计是为了避免使用者资源的误用，而 SELinux 使用的是 MAC 委任式存取配置；</li>
	<li>SELinux 的运行中，重点在於主体程序 (Subject) 能否存取目标文件资源 (Object) ，这中间牵涉到政策 (Policy) 内的守则，
		以及实际的安全性本文类别 (type)；</li>
	<li>安全性本文的一般配置为：『Identify:role:type』其中又以 type 最重要；</li>
	<li>SELinux 的模式有： enforcing, permissive, disabled 三种，而启动的政策 (Policy) 主要是 targeted </li>
	<li>SELinux 启动与关闭的配置档在： /etc/selinux/config</li>
	<li>SELinux 的启动与观察： getenforce, sestatus 等命令</li>
	<li>重设 SELinux 的安全性本文可使用 restorecon 与 chcon</li>
	<li>在 SELinux 有启动时，必备的服务至少要启动 setroubleshoot 这个！</li>
	<li>若要管理默认的 SELinux 布林值，可使用 getsebool, setsebool 来管理！</li>
</ul>
</div>


<hr><a name="ex"></a><img src="./鸟哥的 Linux 私房菜18 -- 程序管理与 SELinux 初探_files/logo.png" alt="大标题的图示" width="35" align="middle" height="34"><span class="text_h1">本章习题</span><br>
( 要看答案请将鼠标移动到『答：』底下的空白处，按下左键圈选空白处即可察看 )
<div class="block1">
<ul>
	<li>情境模拟题一：透过一个网络程序 vsftpd 的服务，来了解到程序与 SELinux 的相关限制行为：<br><br>
	<ul>
		<li>目标：了解软件、程序、程序、优先运行绪、网络程序与 SELinux 的相关性</li>
		<li>需求：已经知道如何安装软件，否则就得要连上 Internet 才能进行 vsftpd 服务的安装；</li>
	</ul><br>

	底下的流程先看看即可，很多数据如果当初忘记安装的话，可能会无法进行。没关系！后续的文章看完后，第二次读到这里后，
	你就会知道如何处理了。<br><br>

	<ol>
		<li>先察看有无安装 vsftpd 这个软件，如果有的话那就 OK ～没有的话，可能需要线上安装才行：<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">rpm -q vsftpd</span>
vsftpd-2.0.5-12.el5   <span class="term_note">&lt;==出现这个才是对的！若没有出现，就是没安装</span>

<span class="term_hd"># 如果没有安装的话，你又已经有 IP 可以上网了，那么就这样安装：</span>
[root@www ~]# <span class="term_command">yum install vsftpd </span>
</pre></td></tr></tbody></table><br></li>

		<li>启动 vsftpd 这个服务：<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">/etc/init.d/vsftpd start</span>
</pre></td></tr></tbody></table><br></li>

		<li>假设 vsftpd 这个服务并不是那么重要，因此我想要在这次启动期间，让 vsftpd 的优先运行绪较不优先 10 分，
		可以这么做：<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">pstree -p | grep vsftpd</span>
        |-vsftpd(2377)   <span class="term_note">&lt;==找到了 PID 为 2377 喔！</span>
[root@www ~]# <span class="term_command">renice 10 2377</span>
[root@www ~]# <span class="term_command">top -p grep 2377</span> <span class="term_note">&lt;==重点是在观察！</span>
</pre></td></tr></tbody></table><br></li>

		<li>vsftpd 是个网络服务，他到底是启动哪个端口？可以这样观察：<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">netstat -tlunp | grep vsftpd</span>
tcp  0 0 0.0.0.0:<span class="term_write">21</span>     0.0.0.0:*  LISTEN   2377/vsftpd
<span class="term_say"># 这样的答案够明显了吗？</span>
</pre></td></tr></tbody></table><br></li>

		<li>vsftpd 提供网络的 FTP 功能，有个使用者名为 vbird ，他却无法登陆自己的帐号！这是什么原因呢？
		由於 CentOS 的默认 vsftpd 是能够允许一般用户登陆自己家目录的，因此无法登陆的可能原因是权限还是 SELinux 呢？
		我们可以这样测试看看：<br>

<table class="term"><tbody><tr><td class="term"><pre><span class="term_hd"># 1. 先用 vbird 的身份登陆 vsftpd 看看：</span>
[root@www ~]# <span class="term_command">ftp localhost</span>
Connected to www.vbird.tsai.
Name (localhost:root): <span class="term_command">vbird</span>
331 Please specify the password.
Password: <span class="term_note">&lt;==这里输入 vbird 的口令喔！</span>
500 OOPS: cannot change directory:/home/vbird
Login failed.  <span class="term_note">&lt;==见鬼了！竟然无法登陆自己的家目录 /home/vbird 哩！</span>
ftp&gt; <span class="term_command">bye</span>

[root@www ~]# <span class="term_command">ls -ld /home/vbird</span>
drwx------ 4 vbird vbird 4096  8月 18 18:22 /home/vbird
<span class="term_say"># 权限明明是对的嘛！怎么会无法切换？</span>

<span class="term_hd"># 2. 看看登录档有没有什么重要信息的说明：</span>
[root@www ~]# <span class="term_command">tail /var/log/messages</span>
Sep 11 16:57:31 www setroubleshoot: SELinux is preventing the ftp daemon from 
reading users home directories (/). For complete SELinux messages. run 
<u>sealert -l b8bdaf2d-b083-4e28-9465-91fae8df63b1</u>

<span class="term_hd"># 3. 照著作一下：</span>
[root@www ~]# <span class="term_command">sealert -l b8bdaf2d-b083-4e28-9465-91fae8df63b1</span>
Summary:
SELinux is preventing the ftp daemon from reading users home directories (/).
<span class="term_say">....(中间省略)....</span>

The following command will allow this access:
<u>setsebool -P ftp_home_dir=1</u>
<span class="term_say">....(底下省略)....</span>
</pre></td></tr></tbody></table><br></li>

		<li>好了，现在让我们处理一下上面的 vsftpd 相关的守则吧！因为是守则挡住了用户的登陆了！：<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">setsebool -P ftp_home_dir=1</span>

[root@www ~]# <span class="term_command">ftp localhost</span>
Connected to www.vbird.tsai.
Name (localhost:root): <span class="term_command">vbird</span>
331 Please specify the password.
Password:
230 Login successful.  <span class="term_note">&lt;==看吧！顺利登陆罗！</span>
Remote system type is UNIX.
Using binary mode to transfer files.
ftp&gt; <span class="term_command">bye</span>
</pre></td></tr></tbody></table></li>

	</ol></li>

</ul>

<hr>简答题部分：
<ul>
	<li>简单说明什么是程序 (program) 而什么是程序 (process)？
	<div class="blockex">
		程序 (program) 是系统上面可以被运行的文件，由於 Linux 的完整档名 (由 / 写起) 仅能有一个，
		所以 program 的档名具有单一性。当程序被运行后，就会启动成程序 (process)，
		一个 program 可以被不同的使用者或者相同的使用者重复的运行成为多个程序，
		且该程序所造成的程序还因为不同的使用者，而有不同的权限，且每个 process 几乎都是独立的。
	</div></li>

	<li>我今天想要查询 /etc/crontab 与 crontab 这个程序的用法与写法，请问我该如何线上查询？
	<div class="blockex">
		查询 crontab 命令可以使用 man crontab 或 info
		crontab ，至於查询 /etc/crontab ，则可以使用 man 5 crontab 罗！
	</div></li>

	<li>我要如何查询 crond 这个 daemon 的 PID 与他的 PRI 值呢？
	<div class="blockex">
		ps aux | grep crond 即可查到！
	</div></li>

	<li>我要如何修改 crond 这个 PID 的优先运行序？
	<div class="blockex">
		先以 ps aux 找到 crond  的 PID 后，再以：
		renice -n number PID 来调整！
	</div></li>

	<li>我是一般身份使用者，我是否可以调整不属於我的程序的 nice 值？此外，如果我调整了我自己的程序的
	nice 值到 10 ，是否可以将他调回 5 呢？
	<div class="blockex">
		不行！一般身份使用者仅能调整属於自己的 PID 程序，并且，只能将
		nice 值一再地调高，并不能调低，所以调整为 10 之后，就不能降回 5 罗！
	</div></li>

	<li>我要怎么知道我的网络卡在启动的过程中有没有被捉到？
	<div class="blockex">
		可以使用 dmesg 来视察！
	</div></li>
</ul>
</div>


<hr><a name="reference"></a><img src="./鸟哥的 Linux 私房菜18 -- 程序管理与 SELinux 初探_files/logo.png" alt="大标题的图示" width="35" align="middle" height="34"><span class="text_h1">参考数据与延伸阅读</span><br>
<div class="block1">
<ul>
	<li><a name="ps1"></a>注1：关於 fork-and-exec 的说明可以参考如下网页与书籍：<br>
		吴贤明老师维护的网站：<a href="http://nmc.nchu.edu.tw/linux/process.htm" target="_blank">http://nmc.nchu.edu.tw/linux/process.htm</a><br>
		杨振和、操作系统导论、第三章、学贯出版社</li>
	<li><a name="ps2"></a>注2：对 Linux 核心有兴趣的话，可以先看看底下的连结：<br>
	<a href="http://www.linux.org.tw/CLDP/OLD/INFO-SHEET-2.html" target="_blank">http://www.linux.org.tw/CLDP/OLD/INFO-SHEET-2.html</a><br>
	<a href="http://oreilly.com/catalog/linuxkernel/chapter/ch10.html" target="_blank">http://oreilly.com/catalog/linuxkernel/chapter/ch10.html</a></li>
	<li><a name="ps3"></a>注3：来自 Linux Journal 的关於 /proc 的说明：<a href="http://www.linuxjournal.com/article/177" target="_blank">http://www.linuxjournal.com/article/177</a></li>
	<li><a name="ps4"></a>注4：关於 SELinux 相关的网站与文件数据：<br>
		美国国家安全局的 SELinux 简介：<a href="http://www.nsa.gov/research/selinux/" target="_blank">http://www.nsa.gov/research/selinux/</a><br>
		小州老师在 SA 的简报数据：<a href="http://kenduest.sayya.org/blog/kenduest-data/2008/10/selinux_sa.pdf" target="_blank">http://kenduest.sayya.org/blog/kenduest-data/2008/10/selinux_sa.pdf</a><br>
		小州老师上课的讲义：<a href="http://kenduest.sayya.org/blog/kenduest-data/2008/5/kenduest-UNIX-selinux-2008-05-15.pdf" target="_blank">http://kenduest.sayya.org/blog/kenduest-data/2008/5/kenduest-UNIX-selinux-2008-05-15.pdf</a><br>
		陈永升、『企业级Linux 系统管理宝典』、学贯行销股份有限公司<br>
		Fedora SELinux 说明：<a href="http://fedoraproject.org/wiki/SELinux/SecurityContext" target="_blank">http://fedoraproject.org/wiki/SELinux/SecurityContext</a><br>
		美国国家安全局对 SELinux 的白皮书：<a href="http://www.nsa.gov/research/_files/selinux/papers/module/t1.shtml" target="_blank">http://www.nsa.gov/research/_files/selinux/papers/module/t1.shtml</a><br>
		徐秉义老师的 SELinux 配置范例：<a href="http://kate.babyface.com.tw/NetAdmin/24200801SELinux/" target="_blank">http://kate.babyface.com.tw/NetAdmin/24200801SELinux/</a></li>

</ul>
</div>


<hr><span class="text_history">
2002/06/28：第一次完成<br>
2003/02/10：重新编排与加入 FAQ<br>
2005/09/07：将旧的文章移动到 <a href="http://linux.vbird.org/linux_basic/0440processcontrol/0440processcontrol.php">此处</a> 。<br>
2005/09/18：哈哈，终於将这篇写完罗。新增了一些简单的小命令啦。<br>
2009/03/15：将旧的基於 FC4 的文章移动到<a href="http://linux.vbird.org/linux_basic/0440processcontrol/0440processcontrol-fc4.php">此处</a>。<br>
2009/03/19：调整 sar 成为 <a href="http://cn.linux.vbird.org/linux_basic/0440processcontrol.php#vmstat">vmstat</a> ，因为 vmstat 是默认有安装的分析工具！<br>
2009/09/11：加入了 <a href="http://cn.linux.vbird.org/linux_basic/0440processcontrol.php#nohup">nohup</a> 的说明罗！并加入了情境模拟题<hr>
</span>
    </td>
    <td style="width: 16px; font-size: 6px;">　</td></tr>
<tr><td style="width: 16px; height: 16px;">　</td>
    <td style="width: 866px; height: 16px;">　</td>
    <td style="width: 16px; height: 16px;">　</td></tr>
</tbody></table>

<div style="padding-top: 0px; text-align: center;">
<span style="font-size: 80%;">
	<a href="http://linux.vbird.org/" target="_top" title="前往鸟哥的首页">http://linux.vbird.org</a>
	is designed by <a href="mailto:vbird@mail.vbird.idv.tw" title="联络鸟哥(我不要广告信！)">VBird</a>
		during 2001-2011. <a href="http://www.ksu.edu.tw/" target="_blank">ksu.edu</a></span>
         ﻿<div id="apDiv4">
      <p>本网页主要以Firefox配合解析度 1024x768 作为设计依据&nbsp;&nbsp;&nbsp;&nbsp; 鸟哥自由软件整合应用研究室</p></div></div>
</div>
</center>

</body></html>