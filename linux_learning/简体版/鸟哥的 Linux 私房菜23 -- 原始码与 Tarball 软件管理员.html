
<!-- saved from url=(0069)http://cn.linux.vbird.org/linux_basic/0520source_code_and_tarball.php -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
	
	<meta name="Author" content="2011/04/21,white">
	<meta name="Description" content="谈一下，在 Linux 里面的软件管理，用最原始的原始码与 tarball 来管理的。">
	<title>鸟哥的 Linux 私房菜 -- 原始码与 Tarball 软件管理员</title>
    <script src="./鸟哥的 Linux 私房菜23 -- 原始码与 Tarball 软件管理员_files/SpryMenuBar.js" type="text/javascript"></script>
	<script src="./鸟哥的 Linux 私房菜23 -- 原始码与 Tarball 软件管理员_files/index.js" type="text/javascript"></script>
	<link href="./鸟哥的 Linux 私房菜23 -- 原始码与 Tarball 软件管理员_files/SpryMenuBarHorizontal.css" rel="stylesheet" type="text/css">
    <link href="./鸟哥的 Linux 私房菜23 -- 原始码与 Tarball 软件管理员_files/main.css" rel="stylesheet" type="text/css">
    </head><body style="margin: 0pt; padding: 0pt;" class="table" onload="MM_preloadImages(&#39;image/title_19.png&#39;,&#39;image/title_26.png&#39;,&#39;image/title_27.png&#39;,&#39;image/title_28.png&#39;,&#39;image/title_06.png&#39;,&#39;image/title_08.png&#39;,&#39;image/title_10.png&#39;,&#39;image/title_12.png&#39;)">

<center>
<div id="apDiv5">
<div> <link rel="SHORTCUT ICON" href="http://cn.linux.vbird.org/linux_basic/favicon.ico">
<!-- ImageReady Slices (title3.ai) -->
<table id="___01" width="898" height="81" border="0" align="center" cellpadding="0" cellspacing="0" ;="">
	<tbody><tr>
		<td colspan="15">
			<img src="./鸟哥的 Linux 私房菜23 -- 原始码与 Tarball 软件管理员_files/title_01.png" width="900" height="1" alt=""></td>
	</tr>
	<tr>
		<td rowspan="4" bgcolor="#182448"><p><img src="./鸟哥的 Linux 私房菜23 -- 原始码与 Tarball 软件管理员_files/Count.cgi" width="93" align="left" title="計數器"></p>
	    <p><font color="#FFFFFF" size="-1">since2012/04/23</font></p></td>
		<td rowspan="4" align="left" valign="top"><a href="http://cn.linux.vbird.org/"><img src="./鸟哥的 Linux 私房菜23 -- 原始码与 Tarball 软件管理员_files/title_03.png" alt="" width="263" height="79" border="0"></a></td>
		<td colspan="13">
			<img src="./鸟哥的 Linux 私房菜23 -- 原始码与 Tarball 软件管理员_files/title_04.png" alt="" width="535" height="9" border="0"></td>
	</tr>
	<tr>
		<td rowspan="3">
			<img src="./鸟哥的 Linux 私房菜23 -- 原始码与 Tarball 软件管理员_files/title_05.png" alt="" width="53" height="70" border="0"></td>
		<td colspan="2" align="left" valign="top"><a href="http://cn.linux.vbird.org/linux_basic/0110whatislinux.php" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage(&#39;Image51&#39;,&#39;&#39;,&#39;image/title/title_06.png&#39;,1)"><img src="./鸟哥的 Linux 私房菜23 -- 原始码与 Tarball 软件管理员_files/title3_06.png" name="Image51" width="106" height="25" border="0" id="Image51" alt=""></a></td>
		<td rowspan="2">
			<img src="./鸟哥的 Linux 私房菜23 -- 原始码与 Tarball 软件管理员_files/title_07.png" alt="" width="27" height="37" border="0"></td>
		<td colspan="3" align="left" valign="top"><a href="http://cn.linux.vbird.org/linux_server/0110network_basic.php" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage(&#39;Image52&#39;,&#39;&#39;,&#39;image/title/title_08.png&#39;,1)"><img src="./鸟哥的 Linux 私房菜23 -- 原始码与 Tarball 软件管理员_files/title3_08.png" name="Image52" width="107" height="25" border="0" id="Image52" alt=""></a></td>
		<td rowspan="2">
			<img src="./鸟哥的 Linux 私房菜23 -- 原始码与 Tarball 软件管理员_files/title_09.png" alt="" width="37" height="37" border="0"></td>
		<td colspan="2" align="left" valign="top"><a href="http://cn.linux.vbird.org/about.php" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage(&#39;Image53&#39;,&#39;&#39;,&#39;image/title/title_10.png&#39;,1)"><img src="./鸟哥的 Linux 私房菜23 -- 原始码与 Tarball 软件管理员_files/title3_10.png" name="Image53" width="75" height="25" border="0" id="Image53" alt=""></a></td>
		<td rowspan="3">
			<img src="./鸟哥的 Linux 私房菜23 -- 原始码与 Tarball 软件管理员_files/title_11.png" alt="" width="35" height="70" border="0"></td>
		<td align="left" valign="top"><a href="mailto:vbird@mail.vbird.idv.tw" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage(&#39;Image54&#39;,&#39;&#39;,&#39;image/title/title_12.png&#39;,1)"><img src="./鸟哥的 Linux 私房菜23 -- 原始码与 Tarball 软件管理员_files/title3_12.png" name="Image54" width="74" height="25" border="0" id="Image54" alt=""></a></td>
		<td rowspan="3">
			<img src="./鸟哥的 Linux 私房菜23 -- 原始码与 Tarball 软件管理员_files/title_13.png" alt="" width="21" height="70" border="0"></td>
	</tr>
	<tr>
		<td colspan="2">
			<img src="./鸟哥的 Linux 私房菜23 -- 原始码与 Tarball 软件管理员_files/title_14.png" alt="" width="106" height="12" border="0"></td>
		<td colspan="3">
			<img src="./鸟哥的 Linux 私房菜23 -- 原始码与 Tarball 软件管理员_files/title_15.png" alt="" width="107" height="12" border="0"></td>
		<td colspan="2">
			<img src="./鸟哥的 Linux 私房菜23 -- 原始码与 Tarball 软件管理员_files/title_16.png" width="75" height="12" alt=""></td>
		<td rowspan="2">
			<img src="./鸟哥的 Linux 私房菜23 -- 原始码与 Tarball 软件管理员_files/title_17.png" alt="" width="74" height="45" border="0"></td>
	</tr>
	<tr>
		<td>
			<img src="./鸟哥的 Linux 私房菜23 -- 原始码与 Tarball 软件管理员_files/title_18.png" alt="" width="15" height="33" border="0"></td>
		<td colspan="3" align="left" valign="top"><ul id="MenuBar1" class="MenuBarHorizontal">
	  <li><a href="http://cn.linux.vbird.org/linux_basic/linux_basic.php" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage(&#39;Image44&#39;,&#39;&#39;,&#39;image/title/title_19.png&#39;,1)" class="MenuBarItemSubmenu"><img src="./鸟哥的 Linux 私房菜23 -- 原始码与 Tarball 软件管理员_files/title3_19.png" name="Image44" width="123" height="33" border="0" id="Image44"></a>
			    <ul>
			      <li><a href="http://cn.linux.vbird.org/linux_basic/Mandrake9.0/mandrake9.0.php" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage(&#39;Image46&#39;,&#39;&#39;,&#39;image/title/title_26.png&#39;,1)"><img src="./鸟哥的 Linux 私房菜23 -- 原始码与 Tarball 软件管理员_files/title_23.png" name="Image46" width="120" height="26" border="0" id="Image46" alt=""></a></li>
                  <li><a href="http://cn.linux.vbird.org/linux_basic/fedora_4/fc4.php" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage(&#39;Image47&#39;,&#39;&#39;,&#39;image/title/title_27.png&#39;,1)"><img src="./鸟哥的 Linux 私房菜23 -- 原始码与 Tarball 软件管理员_files/title_24.png" name="Image47" width="120" height="26" border="0" id="Image47" alt=""></a></li>
                  <li><a href="http://cn.linux.vbird.org/linux_basic/linux_basic.php" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage(&#39;Image48&#39;,&#39;&#39;,&#39;image/title/title_28.png&#39;,1)"><img src="./鸟哥的 Linux 私房菜23 -- 原始码与 Tarball 软件管理员_files/title_25.png" name="Image48" width="120" height="26" border="0" id="Image48" alt=""></a></li>
                </ul>
		      </li>
		</ul></td>
		<td>
			<img src="./鸟哥的 Linux 私房菜23 -- 原始码与 Tarball 软件管理员_files/title_20.png" alt="" width="42" height="33" border="0"></td>
		<td colspan="3" align="left" valign="top"><ul id="MenuBar2" class="MenuBarHorizontal">
	  <li><a href="http://cn.linux.vbird.org/linux_server/" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage(&#39;Image45&#39;,&#39;&#39;,&#39;image/title/title_21.png&#39;,1)" class="MenuBarItemSubmenu"><img src="./鸟哥的 Linux 私房菜23 -- 原始码与 Tarball 软件管理员_files/title3_21.png" name="Image45" width="125" height="33" border="0" id="Image45"></a>
			    <ul>
			      <li><a href="http://cn.linux.vbird.org/linux_server/linux_redhat9/redhat9.php" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage(&#39;Image43&#39;,&#39;&#39;,&#39;image/title/title_26.png&#39;,1)"><img src="./鸟哥的 Linux 私房菜23 -- 原始码与 Tarball 软件管理员_files/title_23.png" name="Image43" width="120" height="26" border="0" id="Image43" alt=""></a></li>
			      <li><a href="http://cn.linux.vbird.org/linux_server/centos4.php" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage(&#39;Image49&#39;,&#39;&#39;,&#39;image/title/title_27.png&#39;,1)"><img src="./鸟哥的 Linux 私房菜23 -- 原始码与 Tarball 软件管理员_files/title_24.png" name="Image49" width="120" height="26" border="0" id="Image49" alt=""></a></li>
			      <li><a href="http://cn.linux.vbird.org/linux_server/" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage(&#39;Image50&#39;,&#39;&#39;,&#39;image/title/title_28.png&#39;,1)"><img src="./鸟哥的 Linux 私房菜23 -- 原始码与 Tarball 软件管理员_files/title_25.png" name="Image50" width="120" height="26" border="0" id="Image50" alt=""></a></li>
		        </ul>
		      </li>
		</ul></td>
		<td>
			<img src="./鸟哥的 Linux 私房菜23 -- 原始码与 Tarball 软件管理员_files/title_22.png" alt="" width="47" height="33" border="0"></td>
	</tr>
	<tr>
		<td>
			<img src="./鸟哥的 Linux 私房菜23 -- 原始码与 Tarball 软件管理员_files/Spacer.gif" width="101" height="1" alt=""></td>
		<td>
			<img src="./鸟哥的 Linux 私房菜23 -- 原始码与 Tarball 软件管理员_files/Spacer.gif" width="263" height="1" alt=""></td>
		<td>
			<img src="./鸟哥的 Linux 私房菜23 -- 原始码与 Tarball 软件管理员_files/Spacer.gif" width="53" height="1" alt=""></td>
		<td>
			<img src="./鸟哥的 Linux 私房菜23 -- 原始码与 Tarball 软件管理员_files/Spacer.gif" width="15" height="1" alt=""></td>
		<td>
			<img src="./鸟哥的 Linux 私房菜23 -- 原始码与 Tarball 软件管理员_files/Spacer.gif" width="91" height="1" alt=""></td>
		<td>
			<img src="./鸟哥的 Linux 私房菜23 -- 原始码与 Tarball 软件管理员_files/Spacer.gif" width="27" height="1" alt=""></td>
		<td>
			<img src="./鸟哥的 Linux 私房菜23 -- 原始码与 Tarball 软件管理员_files/Spacer.gif" width="5" height="1" alt=""></td>
		<td>
			<img src="./鸟哥的 Linux 私房菜23 -- 原始码与 Tarball 软件管理员_files/Spacer.gif" width="42" height="1" alt=""></td>
		<td>
			<img src="./鸟哥的 Linux 私房菜23 -- 原始码与 Tarball 软件管理员_files/Spacer.gif" width="60" height="1" alt=""></td>
		<td>
			<img src="./鸟哥的 Linux 私房菜23 -- 原始码与 Tarball 软件管理员_files/Spacer.gif" width="37" height="1" alt=""></td>
		<td>
			<img src="./鸟哥的 Linux 私房菜23 -- 原始码与 Tarball 软件管理员_files/Spacer.gif" width="28" height="1" alt=""></td>
		<td>
			<img src="./鸟哥的 Linux 私房菜23 -- 原始码与 Tarball 软件管理员_files/Spacer.gif" width="47" height="1" alt=""></td>
		<td>
			<img src="./鸟哥的 Linux 私房菜23 -- 原始码与 Tarball 软件管理员_files/Spacer.gif" width="35" height="1" alt=""></td>
		<td>
			<img src="./鸟哥的 Linux 私房菜23 -- 原始码与 Tarball 软件管理员_files/Spacer.gif" width="74" height="1" alt=""></td>
		<td>
			<img src="./鸟哥的 Linux 私房菜23 -- 原始码与 Tarball 软件管理员_files/Spacer.gif" width="22" height="1" alt=""></td>
	</tr>
</tbody></table>
<!-- End ImageReady Slices -->
<script type="text/javascript">
<!--
var MenuBar1 = new Spry.Widget.MenuBar("MenuBar1", {imgDown:"SpryAssets/SpryMenuBarDownHover.gif", imgRight:"SpryAssets/SpryMenuBarRightHover.gif"});
var MenuBar2 = new Spry.Widget.MenuBar("MenuBar2", {imgDown:"SpryAssets/SpryMenuBarDownHover.gif", imgRight:"SpryAssets/SpryMenuBarRightHover.gif"});
//-->
</script>
</div>
<table summary="本文内容的排版" style="width: 898px;" border="0" cellpadding="0" cellspacing="0">
<tbody><tr><td style="width: 16px; height: 16px;">　</td>
    <td style="width: 866px; height: 16px;">　</td>
    <td style="width: 16px; height: 16px;">　</td></tr>
<tr><td style="width: 16px; font-size: 6px;">　</td>
    <td width="866">

<!-- 本文的档头部分 -->
<div style="text-align: center;">
    <a href="http://cn.linux.vbird.org/linux_basic/0520source_code_and_tarball.php">
    <span class="text_head0">第二十二章、软件安装：原始码与<span class="text_head_en"> Tarball </span></span></a><br>
</div>
    <div style="text-align: right;">
        <span class="text_history">最近升级日期：2009/09/15</span>
    </div>

<!-- 本文的档头部分 -->
<center><table class="head1" summary="排版：文章档头的说明"><tbody><tr><td class="head1">
	我们在<a href="http://cn.linux.vbird.org/linux_basic/0110whatislinux.php">第一章、Linux是什么</a>当中提到了 GNU 计画与 
	GPL 授权所产生的自由软件与开放源码等咚咚。不过，前面的章节都还没有提到真正的开放源码是什么的信息！在这一章当中，我们将藉由
	Linux 操作系统里面的运行档，来理解什么是可运行的程序，以及了解什么是编译器。另外，与程序息息相关的函式库 
	(library) 的资讯也需要了解一番！不过，在这个章节当中，鸟哥并不是要你成为一个开放源码的程序设计师，
	而是希望你可以了解如何将开放源码的程序设计、加入函式库的原理、透过编译而成为可以运行
	的 binary program，最后该运行档可被我们所使用的一连串过程！<br><br>

	了解上面的咚咚有什么好处呢？因为在 Linux 的世界里面，由於客制化的关系，有时候我们需要自行安装软件在自己的 
	Linux 系统上面，所以如果你有简单的程序编译概念，那么将很容易进行软件的安装。
	甚至在发生软件编译过程中的错误时，你也可以自行作一些简易的修订呢！而最传统的软件安装过程，
	自然就是由原始码编译而来的罗！所以，在这里我们将介绍最原始的软件管理方式：使用
	Tarball 来安装与升级管理我们的软件喔！
</td></tr></tbody></table></center><br>

<!-- 本文的连结区部分 -->
<div class="block1">
<span class="text_h1">
1. <a href="http://cn.linux.vbird.org/linux_basic/0520source_code_and_tarball.php#intro">开放源码的软件安装与升级简介</a><br>
	<span class="text_h2">
	　　1.1 <a href="http://cn.linux.vbird.org/linux_basic/0520source_code_and_tarball.php#intro_whatisopensource">什么是开放源码、编译器与可运行档</a><br>
	　　1.2 <a href="http://cn.linux.vbird.org/linux_basic/0520source_code_and_tarball.php#intro_library">什么是函式库</a><br>
	　　1.3 <a href="http://cn.linux.vbird.org/linux_basic/0520source_code_and_tarball.php#intro_make">什么是 make 与 configure</a><br>
	　　1.4 <a href="http://cn.linux.vbird.org/linux_basic/0520source_code_and_tarball.php#intro_tarball">什么是 Tarball 的软件</a><br>
	　　1.5 <a href="http://cn.linux.vbird.org/linux_basic/0520source_code_and_tarball.php#intro_howto">如何安装与升级软件</a><br>
	</span>
2. <a href="http://cn.linux.vbird.org/linux_basic/0520source_code_and_tarball.php#simple_ex">使用传统程序语言进行编译的简单范例</a><br>
	<span class="text_h2">
	　　2.1 <a href="http://cn.linux.vbird.org/linux_basic/0520source_code_and_tarball.php#simple_ex_hello">单一程序：印出 Hello World</a><br>
	　　2.2 <a href="http://cn.linux.vbird.org/linux_basic/0520source_code_and_tarball.php#simple_ex_function">主、副程序连结：副程序的编译</a><br>
	　　2.3 <a href="http://cn.linux.vbird.org/linux_basic/0520source_code_and_tarball.php#simple_ex_lib">呼叫外部函式库：加入连结的函式库</a><br>
	　　2.4 <a href="http://cn.linux.vbird.org/linux_basic/0520source_code_and_tarball.php#simple_ex_gcc">gcc 的简易用法 (编译、参数与链结)</a><br>
	</span>
3. <a href="http://cn.linux.vbird.org/linux_basic/0520source_code_and_tarball.php#make">用 make 进行巨集编译</a><br>
	<span class="text_h2">
	　　3.1 <a href="http://cn.linux.vbird.org/linux_basic/0520source_code_and_tarball.php#make_why">为什么要用 make</a><br>
	　　3.2 <a href="http://cn.linux.vbird.org/linux_basic/0520source_code_and_tarball.php#make_makefile">makefile 的基本语法与变量</a><br>
	</span>
4. <a href="http://cn.linux.vbird.org/linux_basic/0520source_code_and_tarball.php#tarball">Tarball 的管理与建议</a><br>
	<span class="text_h2">
	　　4.1 <a href="http://cn.linux.vbird.org/linux_basic/0520source_code_and_tarball.php#tarball_pack">使用原始码管理软件所需要的基础软件</a><br>
	　　4.2 <a href="http://cn.linux.vbird.org/linux_basic/0520source_code_and_tarball.php#tarball_step">Tarball 安装的基本步骤</a><br>
	　　4.3 <a href="http://cn.linux.vbird.org/linux_basic/0520source_code_and_tarball.php#tarball_common">一般 Tarball 软件安装的建议事项 (如何移除？升级？)</a><br>
	　　4.4 <a href="http://cn.linux.vbird.org/linux_basic/0520source_code_and_tarball.php#tarball_exntp">一个简单的范例、利用 ntp 来示范</a><br>
	　　4.5 <a href="http://cn.linux.vbird.org/linux_basic/0520source_code_and_tarball.php#tarball_patch">利用 patch 升级原始码</a><br>
	</span>
5. <a href="http://cn.linux.vbird.org/linux_basic/0520source_code_and_tarball.php#library">函式库管理</a><br>
	<span class="text_h2">
	　　5.1 <a href="http://cn.linux.vbird.org/linux_basic/0520source_code_and_tarball.php#library_dyna_sta">动态与静态函式库</a><br>
	　　5.2 <a href="http://cn.linux.vbird.org/linux_basic/0520source_code_and_tarball.php#library_ldconfig">ldconfig 与 /etc/ld.so.conf</a><br>
	　　5.3 <a href="http://cn.linux.vbird.org/linux_basic/0520source_code_and_tarball.php#ldd">程序的动态函式库解析： ldd</a><br>
	</span>
6. <a href="http://cn.linux.vbird.org/linux_basic/0520source_code_and_tarball.php#check">检验软件的正确性</a><br>
	<span class="text_h2">
	　　6.1 <a href="http://cn.linux.vbird.org/linux_basic/0520source_code_and_tarball.php#check_md5sum">md5sum / sha1sum</a><br>
	</span>
7. <a href="http://cn.linux.vbird.org/linux_basic/0520source_code_and_tarball.php#hint">重点回顾</a><br>
8. <a href="http://cn.linux.vbird.org/linux_basic/0520source_code_and_tarball.php#ex">课后练习</a><br>
9. <a href="http://cn.linux.vbird.org/linux_basic/0520source_code_and_tarball.php#reference">参考数据与延伸阅读</a><br>
<span class="text_h2">
10. <a href="http://phorum.vbird.org/viewtopic.php?t=23892" target="_blank">针对本文的建议：http://phorum.vbird.org/viewtopic.php?t=23892</a>
</span>
</span>
</div>


<!-- 本文的正式部分 -->
<hr><a name="intro"></a><img src="./鸟哥的 Linux 私房菜23 -- 原始码与 Tarball 软件管理员_files/logo.png" alt="大标题的图示" width="35" align="middle" height="34"><span class="text_h1">开放源码的软件安装与升级简介</span><br>
<div class="block1">
	<p>如果鸟哥想要在我的 Linux 服务器上面跑网页服务器 (WWW server) 这项服务，那么我应该要做些什么事呢？当然就一定需要『<span class="text_import2">安装网页服务器的软件</span>』罗！如果鸟哥的服务器上面没有这个软件的话，那当然也就无法激活 
	WWW 的服务啦！所以啦，想要在你的 Linux 上面进行一些有的没的功能，学会『<span class="text_import2">如何安装软件</span>』是很重要的一个课题！</p>

	<p>咦！安装软件有什么难的？在 W 牌的操作系统上面安装软件时，不是只要一直给他按
	『下一步』就可以安装妥当了吗？话是这样说没错啦，不过，也由於如此，所以在 Windows 
	系统上面的软件都是一模一样的，也就是说，你『<span class="text_import2">无法修改该软件的原始程序码</span>』，因此，
	万一你想要添加或者减少该软件的某些功能时，大概只能求助於当初发行该软件的厂商了！(这就是所谓的商机吗？)</p>

	<p>或许你会说：『唉呦！我不过是一般人，不会用到多余的功能，所以不太可能会更动到程序码的部分吧？』
	如果你这么想的话，很抱歉～是有问题的！怎么说呢？像目前网络上面的病毒、黑客软件、臭虫程序等等，
	都可能对你的主机上面的某些软件造成影响，导致主机的死机或者是其他数据损毁等等的伤害。
	如果你可以藉由安全资讯单位所提供的修订方式进行修改，
	那么你将可以很快速的自行修补好该软件的漏洞，而不必一定要等到软件开发商提供修补的程序包哩！要知道，<span class="text_import2">提早补洞</span>是很重要的一件事。</p>

	<div style="padding: 10pt 0pt;" align="right"><table width="90%"><tbody><tr><td><b>Tips:</b><br><span style="color: rgb(0, 144, 0);"><font size="-1">	并不是软件开发商故意要搞出一个有问题的软件，而是某些程序码当初设计时可能没有考量周全，
	或者是程序码与操作系统的权限配置并不相同，所导致的一些漏洞。当然，也有可能是 cracker 透过某些攻击程序测试到程序的不周全所致。
	无论如何，只要有网络存在的一天，可以想像的到，程序的漏洞永远补不完！但能补多少就补多少吧！
	</font></span></td><td><img src="./鸟哥的 Linux 私房菜23 -- 原始码与 Tarball 软件管理员_files/vbird_face.gif" alt="鸟哥的图示" title="鸟哥的图示"></td></tr></tbody></table></div>
	<p>这样说可以了解 Linux 的优点了吗？没错！因为 <span class="text_import2">Linux
	上面的软件几乎都是经过 GPL 的授权</span>，所以每个软件几乎均提供原始程序码，
	并且你可以自行修改该程序码，以符合你个人的需求呢！很棒吧！这就是开放源码的优点罗！不过，到底什么是开放源码？
	这些程序码是什么咚咚？又 Linux 上面可以运行的相关软件文件与开放源码之间是如何转换的？不同版本的
	Linux 之间能不能使用同一个运行档？或者是该运行档需要由原始程序码的部分重新进行转换？
	这些都是需要厘清观念的。底下我们先就原始程序码与可运行档来进行说明。<br><br></p>

	<hr><a name="intro_whatisopensource"></a><img src="./鸟哥的 Linux 私房菜23 -- 原始码与 Tarball 软件管理员_files/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">什么是开放源码、编译器与可运行档</span>
	<div class="block2">
		<p>在讨论程序码是什么之前，我们先来谈论一下什么是可运行档？我们说过，在
		Linux 系统上面，一个文件能不能被运行看的是有没有可运行的那个权限 (具有
		x permission)，不过，<span class="text_import2">Linux 系统上真正认识的可运行档其实是二进位文件 (
		binary program)</span>，例如 /usr/bin/passwd, /bin/touch 这些个文件即为二进位程序码。</p>

		<p>或许你会说 shell scripts 不是也可以运行吗？其实 shell scripts 只是利用 shell (例如 bash) 
		这支程序的功能进行一些判断式，而最终运行的除了 bash 提供的功能外，仍是呼叫一些已经编译好的二进位程序来运行的呢！
		当然啦， bash 本身也是一支二进位程序啊！那么我怎么知道一个文件是否为 binary 呢？还记得我们在<a href="http://cn.linux.vbird.org/linux_basic/0220filemanager.php#file">第七章里面提到的 file</a> 
		这个命令的功能吗？对啦！用他就是了！我们现在来测试一下：</p>

<table class="term"><tbody><tr><td class="term"><pre><span class="term_hd"># 先以系统的文件测试看看：</span>
[root@www ~]# <span class="term_command">file /bin/bash</span>
/bin/bash: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), for GNU/
Linux 2.6.9, dynamically linked (uses shared libs), for GNU/Linux 2.6.9, stripped

<span class="term_hd"># 如果是系统提供的 /etc/init.d/syslog 呢？</span>
[root@www ~]# <span class="term_command">file /etc/init.d/syslog</span>
/etc/init.d/syslog: Bourne-Again shell script text executable
</pre></td></tr></tbody></table>

		<p>看到了吧！如果是 binary 而且是可以运行的时候，他就会显示运行档类别 (ELF 32-bit LSB executable)，
		同时会说明是否使用<span class="text_import2">动态函式库 (shared libs)</span>，而如果是一般的 
		script ，那他就会显示出 text executables 之类的字样！</p>

		<div style="padding: 10pt 0pt;" align="right"><table width="90%"><tbody><tr><td><b>Tips:</b><br><span style="color: rgb(0, 144, 0);"><font size="-1">		事实上，syslog 的数据显示出 Bourne-Again ... 那一行，是因为你的 scripts 上面第一行有宣告 #!/bin/bash
		的缘故，如果你将 script 的第一行拿掉，那么不管 /etc/init.d/syslog 
		的权限为何，他其实显示的是 ASCII 文字档的资讯喔！
		</font></span></td><td><img src="./鸟哥的 Linux 私房菜23 -- 原始码与 Tarball 软件管理员_files/vbird_face.gif" alt="鸟哥的图示" title="鸟哥的图示"></td></tr></tbody></table></div>
		<p>既然 Linux 操作系统真正认识的其实是 binary program，那么我们是如何做出这样的一支
		binary 的程序呢？首先，我们必须要写程序，用什么东西写程序？就是一般的文书处理器啊！鸟哥都喜欢使用
		<a href="http://cn.linux.vbird.org/linux_basic/0310vi.php">vim</a> 来进行程序的撰写，写完的程序就是所谓的原始程序码罗！
		<span class="text_import2">这个程序码文件其实就是一般的纯文字档</span>。
		在完成这个原始码文件的编写之后，再来就是要将这个文件『<span class="text_import2">编译</span>』成为操作系统看的懂得
		binary program 罗！而要编译自然就需要『<span class="text_import2">编译器</span>』来动作，
		经过编译器的编译与连结之后，就会产生一支可以运行的 binary program 罗。</p>

		<p>举个例子来说，在 Linux 上面最标准的程序语言为 C ，所以我使用 C 的语法进行原始程序码的书写，写完之后，以
		Linux 上标准的 C 语言编译器 <span class="text_import2">gcc</span> 这支程序来编译，就可以制作一支可以运行的
		binary program 罗。整个的流程有点像这样：</p>

		<a name="fig1.1.1"></a>
		<center><img src="./鸟哥的 Linux 私房菜23 -- 原始码与 Tarball 软件管理员_files/source_to_binary.gif" alt="利用 gcc 编译器进行程序的编译流程示意图" title="利用 gcc 编译器进行程序的编译流程示意图" border="1"><br>
		图 1.1.1、利用 gcc 编译器进行程序的编译流程示意图"<br></center>

		<p>事实上，在编译的过程当中还会产生所谓的<span class="text_import2">目标档 (Object file)</span>，这些文件是以 
		*.o 的扩展名样式存在的！至於 C 语言的原始码文件通常以 *.c 作为扩展名。此外，有的时候，我们会在程序当中『引用、呼叫』
		其他的外部副程序，或者是利用其他软件提供的『函数功能』，这个时候，我们就必须要在编译的过程当中，
		将该函式库给他加进去，如此一来，编译器就可以将所有的程序码与函式库作一个连结 (Link) 以产生正确的运行档罗。</p>

		<p>总之，我们可以这么说：</p>
		<ul>
		<li>开放源码：就是程序码，写给人类看的程序语言，但机器并不认识，所以无法运行；</li>
		<li>编译器：将程序码转译成为机器看的懂得语言，就类似翻译者的角色；</li>
		<li>可运行档：经过编译器变成二进位程序后，机器看的懂所以可以运行的文件。</li>
		</ul>
	</div>

	<hr><a name="intro_library"></a><img src="./鸟哥的 Linux 私房菜23 -- 原始码与 Tarball 软件管理员_files/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">什么是函式库</span>
	<div class="block2">
		<p>在前一小节的<a href="http://cn.linux.vbird.org/linux_basic/0520source_code_and_tarball.php#fig1.1.1">图1.1.1</a>示意图中，在编译的过程里面有提到函式库这东西。
		什么是函式库呢？先举个例子来说：我们的 Linux 系统上通常已经提供一个可以进行身份验证的模块，
		就是在<a href="http://cn.linux.vbird.org/linux_basic/0410accountmanager.php#usershell">第十四章提到的 PAM 模块</a>。这个
		PAM 提供的功能可以让很多的程序在被运行的时候，除了可以验证使用者登陆的资讯外，
		还可以将身份确认的数据记录在<a href="http://cn.linux.vbird.org/linux_basic/0570syslog.php">登录文件</a>里面，以方便系统管理员的追踪！</p>

		<p>既然有这么好用的功能，那如果我要编写具有身份认证功能的程序时，直接引用该 PAM 
		的功能就好啦，如此一来，我就不需要重新设计认证机制罗！也就是说，只要在我写的程序码里面，配置去呼叫 PAM 
		的函式功能，我的程序就可以利用 Linux 原本就有的身份认证的程序咯！除此之外，其实我们的 Linux 
		核心也提供了相当多的函式库来给硬件开发者利用喔。</p>

		<p>函式库又分为动态与静态函式库，这两个咚咚的分别我们在后面的小节再加以说明。
		这里我们以一个简单的流程图，来示意一支有呼叫外部函式库的程序的运行情况。</p>

		<a name="fig1.2.1"></a>
		<center><img src="./鸟哥的 Linux 私房菜23 -- 原始码与 Tarball 软件管理员_files/library.gif" alt="程序运行时引用外部动态函式库的示意图" title="程序运行时引用外部动态函式库的示意图" border="0"><br>
		图 1.2.1、程序运行时引用外部动态函式库的示意图<br></center>

		<p>很简单的示意图啊！^_^！而如果要在程序里面加入引用的函式库，就需要如<a href="http://cn.linux.vbird.org/linux_basic/0520source_code_and_tarball.php#fig1.1.1">图 1.1.1</a> 所示，
		亦即在编译的过程当中，就需要加入函式库的相关配置罗。
		事实上， Linux 的核心提供很多的核心相关函式库与外部参数，
		这些核心功能在设计硬件的驱动程序的时候是相当有用的资讯，这些核心相关资讯大多放置在
		<span class="text_import2">/usr/include, /lib, /usr/lib</span>
		里面哩！我们在本章的后续小节再来探讨。反正我们可以简单的这么想：</p>
		<ul>
		<li>函式库：就类似副程序的角色，可以被呼叫来运行的一段功能函数。</li>
		</ul>
	</div>

	<hr><a name="intro_make"></a><img src="./鸟哥的 Linux 私房菜23 -- 原始码与 Tarball 软件管理员_files/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">什么是 make 与 configure</span>
	<div class="block2">
		<p>事实上，使用类似 gcc 的编译器来进行编译的过程并不简单，因为一套软件并不会仅有一支程序，
		而是有一堆程序码文件。所以除了每个主程序与副程序均需要写上一笔编译过程的命令外，还需要写上最终的连结程序。
		程序码小的时候还好，如果是类似 WWW 服务器软件 (例如 <a href="http://cn.linux.vbird.org/linux_server/0360apache.php">Apache</a>)
		，或者是类似核心的原始码，动则数百 MBytes 的数据量，编译命令会写到疯掉～这个时候，我们就可以使用
		make 这个命令的相关功能来进行编译过程的命令简化了！</p>

		<p>当运行 make 时，make 会在当时的目录下搜寻 <span class="text_import2">Makefile (or makefile)</span> 
		这个文字档，而 Makefile 里面则记录了原始码如何编译的详细资讯！
		make 会自动的判别原始码是否经过变动了，而自动升级运行档，是软件工程师相当好用的一个辅助工具呢！</p>

		<p>咦！make 是一支程序，会去找 Makefile ，那 Makefile 怎么写？
		通常软件开发商都会写一支侦测程序来侦测使用者的作业环境，
		以及该作业环境是否有软件开发商所需要的其他功能，该侦测程序侦测完毕后，就会主动的创建这个
		Makefile 的守则文件啦！通常这支侦测程序的档名为 configure 或者是 config 。</p>

		<p>咦！那为什么要侦测作业环境呢？在<a href="http://cn.linux.vbird.org/linux_basic/0110whatislinux.php">第一章</a>当中，
		不是曾经提过其实每个 Linux distribution 都使用同样的核心吗？但你得要注意，
		不同版本的核心所使用的系统呼叫可能不相同，而且每个软件所需要的相依的函式库也不相同，
		同时，软件开发商不会仅针对 Linux 开发，而是会针对整个 Unix-Like 做开发啊！
		所以他也必须要侦测该操作系统平台有没有提供合适的编译器才行！所以当然要侦测环境啊！
		一般来说，侦测程序会侦测的数据大约有底下这些：</p>

		<ul class="text_import2">
		<li>是否有适合的编译器可以编译本软件的程序码；</li>
		<li>是否已经存在本软件所需要的函式库，或其他需要的相依软件；</li>
		<li>操作系统平台是否适合本软件，包括 Linux 的核心版本；</li>
		<li>核心的表头定义档 (header include) 是否存在 (驱动程序必须要的侦测)。</li>
		</ul>

		<p>至於 make 与 configure 运行流程的相关性，我们可以使用底下的图示来示意一下啊！
		下图中，你要进行的任务其实只有两个，一个是运行 configure 来创建 Makefile ，
		这个步骤一定要成功！成功之后再以 make 来呼叫所需要的数据来编译即可！非常简单！</p>

		<center><img src="./鸟哥的 Linux 私房菜23 -- 原始码与 Tarball 软件管理员_files/make_configure.gif" alt="透过 configure 与 make 进行编译示意图" title="透过 configure 与 make 进行编译示意图" border="0"><br>
		图 1.3.1、透过 configure 与 make 进行编译示意图<br></center>

		<p>由於不同的 Linux distribution 的函式库文件所放置的路径，或者是函式库的档名订定，
		或者是默认安装的编译器，以及核心的版本都不相同，因此理论上，你无法在 CentOS 5.x 
		上面编译出 binary program 后，还将他拿到 SuSE 上面运行，这个动作通常是不可能成功的！
		因为呼叫的目标函式库位置可能不同 (参考<a href="http://cn.linux.vbird.org/linux_basic/0520source_code_and_tarball.php#fig1.2.1">图1.2.1</a>) ，
		核心版本更不可能相同！所以能够运行的情况是微乎其微！所以同一套软件要在不同的平台上面运行时，
		必须要重复编译！所以才需要原始码嘛！了解乎！</p>

		<p>详细的 make 用法与 Makefile 守则，在后续的小节里面再探讨罗！</p>
	</div>

	<hr><a name="intro_tarball"></a><img src="./鸟哥的 Linux 私房菜23 -- 原始码与 Tarball 软件管理员_files/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">什么是 Tarball 的软件</span>
	<div class="block2">
		<p>从前面几个小节的说明来看，我们知道所谓的原始程序码，其实就是一些写满了程序码的纯文字文件。
		那我们在<a href="http://cn.linux.vbird.org/linux_basic/0240tarcompress.php">第九章压缩命令的介绍</a>当中，
		也了解了纯文字档在网络上其实是很浪费频宽的一种文件格式！
		所以啦，如果能够将这些原始码透过文件的打包与压缩技术来将文件的数量与容量减小，
		不但让使用者容易下载，软件开发商的网站频宽也能够节省很多很多啊！这就是
		Tarball 文件的由来罗！</p>

		<div style="padding: 10pt 0pt;" align="right"><table width="90%"><tbody><tr><td><b>Tips:</b><br><span style="color: rgb(0, 144, 0);"><font size="-1">		想一想，一个核心的原始码文件大约要 300~500 MB 以上，如果每个人都去下载这样的一个核心文件，
		呵呵！那么网络频宽不被吃的死翘翘才怪呢！
		</font></span></td><td><img src="./鸟哥的 Linux 私房菜23 -- 原始码与 Tarball 软件管理员_files/vbird_face.gif" alt="鸟哥的图示" title="鸟哥的图示"></td></tr></tbody></table></div>
		<p>所谓的 Tarball 文件，其实就是将软件的所有原始码文件先以 <a href="http://cn.linux.vbird.org/linux_basic/0240tarcompress.php#tar">tar</a>
		打包，然后再以压缩技术来压缩，通常最常见的就是以 <a href="http://cn.linux.vbird.org/linux_basic/0240tarcompress.php#gzip">gzip</a>
		来压缩了。因为利用了 tar 与 gzip 的功能，所以 <span class="text_import2">tarball
		文件一般的扩展名就会写成 *.tar.gz 或者是简写为 *.tgz 罗</span>！不过，近来由於 <a href="http://cn.linux.vbird.org/linux_basic/0240tarcompress.php#bzip2">bzip2</a> 的压缩率较佳，所以 Tarball 渐渐的以 bzip2
		的压缩技术来取代 gzip 罗！因此档名也会变成 *.tar.bz2 之类的哩。所以说， Tarball 是一个软件包，
		你将他解压缩之后，里面的文件通常就会有：</p>

		<ul class="text_import2">
		<li>原始程序码文件；</li>
		<li>侦测程序文件 (可能是 configure 或 config 等档名)；</li>
		<li>本软件的简易说明与安装说明 (INSTALL 或 README)。</li></ul>

		<p>其中最重要的是那个 INSTALL 或者是 README 这两个文件，通常你只要能够参考这两个文件，
		Tarball 软件的安装是很简单的啦！我们在后面的章节会再继续介绍 Tarball 这个玩意儿。</p>
	</div>

	<hr><a name="intro_howto"></a><img src="./鸟哥的 Linux 私房菜23 -- 原始码与 Tarball 软件管理员_files/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">如何安装与升级软件</span>
	<div class="block2">
		<p>将原始码作了一个简单的介绍，也知道了系统其实认识的可运行档是
		binary program 之后，好了，得要聊一聊，那么怎么安装与升级一个 Tarball 
		的软件？为什么要安装一个新的软件呢？当然是因为我们的主机上面没有该软件罗！那么，
		为何要升级呢？原因可能有底下这些：</p>

		<ul class="text_import2">
		<li>需要新的功能，但旧有主机的旧版软件并没有，所以需要升级到新版的软件；</li>
		<li>旧版本的软件上面可能有资安上的顾虑，所以需要升级到新版的软件；</li>
		<li>旧版的软件运行效能不彰，或者运行的能力不能让管理者满足。</li></ul>

		<p>在上面的需求当中，尤其需要注意的是第二点，当一个软件有安全上的顾虑时，千万不要怀疑，
		赶紧升级软件吧！否则造成网络危机，那可不是闹著玩的！那么升级的方法有哪些呢？
		基本上升级的方法可以分为两大类，分别是：</p>

		<ul class="text_import2">
		<li>直接以原始码透过编译来安装与升级；</li>
		<li>直接以编译好的 binary program 来安装与升级。</li></ul>

		<p>上面第一点很简单，就是直接以 Tarball 在自己的机器上面进行侦测、编译、
		安装与配置等等动作来升级就是了。不过，这样的动作虽然让使用者在安装过程当中具有很高的弹性，
		但毕竟是比较麻烦一点，如果
		Linux distribution 厂商能够针对自己的作业平台先进行编译等过程，再将编译好的
		binary program 释出的话，那由於我的系统与该 Linux distribution 的环境是相同的，所以他所释出的
		binary program 就可以在我的机器上面直接安装啦！省略了侦测与编译等等繁杂的过程呢！</p>

		<p>这个预先编译好程序的机制存在於很多 distribution 喔，包括有 <span class="text_import2">Red Hat 系统
		(含 Fedora/CentOS 系列) 发展的 RPM 软件管理机制与 yum 线上升级模式； Debian
		使用的 dpkg 软件管理机制与 APT 线上升级模式等等</span>。</p>

		<p>由於 CentOS 系统是依循标准的 Linux distribution，所以可以使用 Tarball 直接进行编译的安装与升级，
		当然也可以使用 RPM 相关的机制来进行安装与升级罗！本章节主要针对 Tarball ，至於 RPM 则留待下个章节再来介绍呢！</p>

		<p>好了，那么一个软件的 Tarball 是如何安装的呢？基本流程是这样的啦：</p>

		<ol class="text_import2">
		<li>将 Tarball 由厂商的网页下载下来；</li>
		<li>将 Tarball 解开，产生很多的原始码文件；</li>
		<li>开始以 gcc 进行原始码的编译 (会产生目标档 object files)；</li>
		<li>然后以 gcc 进行函式库、主、副程序的连结，以形成主要的 binary file；</li>
		<li>将上述的 binary file 以及相关的配置档安装至自己的主机上面。</li></ol>

		<p>上面第 3, 4 步骤当中，我们可以透过 make 这个命令的功能来简化他，
		所以整个步骤其实是很简单的啦！只不过你就得需要至少有
		gcc 以及 make 这两个软件在你的 Linux 系统里面才行喔！
		详细的过程以及需要的软件我们在后面的章节继续来介绍的啦！</p>
	</div>
</div>


<hr><a name="simple_ex"></a><img src="./鸟哥的 Linux 私房菜23 -- 原始码与 Tarball 软件管理员_files/logo.png" alt="大标题的图示" width="35" align="middle" height="34"><span class="text_h1">使用传统程序语言进行编译的简单范例</span>
<div class="block1">
	<p>经过上面的介绍之后，你应该比较清楚的知道原始码、编译器、函式库与运行档之间的相关性了。
	不过，详细的流程可能还不是很清楚，所以，在这里我们以一个简单的程序范例来说明整个编译的过程喔！赶紧进入
	Linux 系统，实地的操作一下底下的范例呢！<br><br></p>

	<hr><a name="simple_ex_hello"></a><img src="./鸟哥的 Linux 私房菜23 -- 原始码与 Tarball 软件管理员_files/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">单一程序：印出 Hello World</span>
	<div class="block2">
		<p>我们以 Linux 上面最常见的 C 语言来撰写第一支程序！第一支程序最常作的就是.....
		在萤幕上面印出『<span class="text_import2">Hello World！</span>』的字样～当然，
		这里我们是以简单的 C 语言来撰写，如果你对於 C 有兴趣的话，那么请自行购买相关的书籍喔！
		^_^ 好了，不罗唆，立刻编辑第一支程序吧！</p>

		<div style="padding: 10pt 0pt;" align="right"><table width="90%"><tbody><tr><td><b>Tips:</b><br><span style="color: rgb(0, 144, 0);"><font size="-1">		请先确认你的 Linux 系统里面已经安装了 gcc 了喔！如果尚未安装 
		gcc 的话，请先参考下一节的 RPM 安装法，先安装好 gcc 之后，再回来阅读本章。
		如果你已经有网络了，那么直接使用『 yum groupinstall "Development Tools" 』
		预先安装好所需的所有软件即可。 rpm 与 yum 均会在下一章介绍。
		</font></span></td><td><img src="./鸟哥的 Linux 私房菜23 -- 原始码与 Tarball 软件管理员_files/vbird_face.gif" alt="鸟哥的图示" title="鸟哥的图示"></td></tr></tbody></table></div>
		<hr><ul class="list1"><li class="text_import1">编辑程序码，亦即原始码</li></ul>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">vim hello.c</span>   <span class="term_note">&lt;==用 C 语言写的程序扩展名建议用 .c</span>
<span class="term_write">#include &lt;stdio.h&gt;
int main(void)
{
        printf("Hello World\n");
}</span>
</pre></td></tr></tbody></table>

		<p>上面是用 C 语言的语法写成的一个程序文件。第一行的那个『 # 』并不是注解喔！如果你担心输入错误，
		请到底下的连结下载这个文件：</p>
		<ul><li><a href="http://cn.linux.vbird.org/linux_basic/0520source/hello.c">http://cn.linux.vbird.org/linux_basic/0520source/hello.c</a>
		</li></ul>

		<hr><ul class="list1"><li class="text_import1">开始编译与测试运行</li></ul>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">gcc hello.c</span>
[root@www ~]# <span class="term_command">ll hello.c a.out</span>
<span class="term_write">-rwxr-xr-x</span> 1 root root 4725 Jun  5 02:41 <span class="term_write">a.out</span>   <span class="term_note">&lt;==此时会产生这个档名</span>
-rw-r--r-- 1 root root   72 Jun  5 02:40 hello.c

[root@www ~]# <span class="term_command">./a.out</span>
Hello World  <span class="term_note">&lt;==呵呵！成果出现了！</span>
</pre></td></tr></tbody></table>

		<p>在默认的状态下，如果我们直接以 gcc 编译原始码，并且没有加上任何参数，则<span class="text_import2">运行档的档名会被自动配置为 a.out 这个文件名称</span>！
		所以你就能够直接运行 ./a.out 这个运行档啦！上面的例子很简单吧！那个 hello.c 就是原始码，而
		gcc 就是编译器，至於 a.out 就是编译成功的可运行 binary program 罗！
		咦！那如果我想要产生目标档 (object file) 来进行其他的动作，而且运行档的档名也不要用默认的
		a.out ，那该如何是好？其实你可以将上面的第 2 个步骤改成这样：</p>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">gcc -c hello.c</span>
[root@www ~]# <span class="term_command">ll hello*</span>
-rw-r--r-- 1 root root  72 Jun  5 02:40 hello.c
-rw-r--r-- 1 root root 868 Jun  5 02:44 <span class="term_write">hello.o</span>  <span class="term_note">&lt;==就是被产生的目标档</span>

[root@www ~]# <span class="term_command">gcc -o hello hello.o</span>
[root@www ~]# <span class="term_command">ll hello*</span>
<span class="term_write">-rwxr-xr-x</span> 1 root root 4725 Jun  5 02:47 <span class="term_write">hello</span>  <span class="term_note">&lt;==这就是可运行档！ -o 的结果</span>
-rw-r--r-- 1 root root   72 Jun  5 02:40 hello.c
-rw-r--r-- 1 root root  868 Jun  5 02:44 hello.o

[root@www ~]# <span class="term_command">./hello</span>
Hello World
</pre></td></tr></tbody></table>

		<p>这个步骤主要是利用 hello.o 这个目标档制作出一个名为 hello 的运行档，详细的 gcc 
		语法我们会在后续章节中继续介绍！透过这个动作后，我们可以得到 hello 及 hello.o 两个文件，
		真正可以运行的是 hello 这个 binary program 喔！
		或许你会觉得，咦！只要一个动作作出 a.out 就好了，干嘛还要先制作目标档再做成运行档呢？
		呵呵！透过下个范例，你就可以知道为什么啦！</p>
	</div>

	<hr><a name="simple_ex_function"></a><img src="./鸟哥的 Linux 私房菜23 -- 原始码与 Tarball 软件管理员_files/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">主、副程序连结：副程序的编译</span>
	<div class="block2">
		<p>如果我们在一个主程序里面又呼叫了另一个副程序呢？这是很常见的一个程序写法，
		因为可以简化整个程序的易读性！在底下的例子当中，我们以
		thanks.c 这个主程序去呼叫 thanks_2.c 这个副程序，写法很简单：<br><br></p>

		<hr><ul class="list1"><li class="text_import1">撰写所需要的主、副程序</li></ul>

<table class="term"><tbody><tr><td class="term"><pre><span class="term_hd"># 1. 编辑主程序：</span>
[root@www ~]# <span class="term_command">vim thanks.c</span>
<span class="term_write">#include &lt;stdio.h&gt;
int main(void)
{
        printf("Hello World\n");
        thanks_2();
}</span>
<span class="term_say"># 上面的 thanks_2(); 那一行就是呼叫副程序啦！</span>

[root@www ~]# <span class="term_command">vim thanks_2.c</span>
<span class="term_write">#include &lt;stdio.h&gt;
void thanks_2(void)
{
        printf("Thank you!\n");
}</span>
</pre></td></tr></tbody></table>

		<p>上面这两个文件你可以到底下下载：</p>
		<ul>
		<li><a href="http://cn.linux.vbird.org/linux_basic/0520source/thanks.c">http://cn.linux.vbird.org/linux_basic/0520source/thanks.c</a></li>
		<li><a href="http://cn.linux.vbird.org/linux_basic/0520source/thanks_2.c">http://cn.linux.vbird.org/linux_basic/0520source/thanks_2.c</a></li>
		</ul>

		<hr><ul class="list1"><li class="text_import1">进行程序的编译与连结 (Link)</li></ul>

<table class="term"><tbody><tr><td class="term"><pre><span class="term_hd"># 2. 开始将原始码编译成为可运行的 binary file ：</span>
[root@www ~]# <span class="term_command">gcc -c thanks.c thanks_2.c</span>
[root@www ~]# <span class="term_command">ll thanks*</span>
-rw-r--r-- 1 root root  76 Jun  5 16:13 thanks_2.c
<span class="term_write">-rw-r--r-- 1 root root 856 Jun  5 16:13 thanks_2.o</span>  <span class="term_note">&lt;==编译产生的！</span>
-rw-r--r-- 1 root root  92 Jun  5 16:11 thanks.c
<span class="term_write">-rw-r--r-- 1 root root 908 Jun  5 16:13 thanks.o</span>    <span class="term_note">&lt;==编译产生的！</span>
[root@www ~]# <span class="term_command">gcc -o thanks thanks.o thanks_2.o</span>
[root@www ~]# <span class="term_command">ll thanks*</span>
-rwxr-xr-x 1 root root 4870 Jun  5 16:17 thanks     <span class="term_note">&lt;==最终结果会产生这玩意儿</span>

<span class="term_hd"># 3. 运行一下这个文件：</span>
[root@www ~]# <span class="term_command">./thanks</span>
Hello World
Thank you!
</pre></td></tr></tbody></table>

		<p>知道为什么要制作出目标档了吗？由於我们的原始码文件有时并非仅只有一个文件，所以我们无法直接进行编译。
		这个时候就需要先产生目标档，然后再以连结制作成为 binary 可运行档。另外，<span class="text_import2">如果有一天，你升级了 thanks_2.c 这个文件的内容，则你只要重新编译 thanks_2.c 来产生新的 thanks_2.o
		，然后再以连结制作出新的 binary 可运行档即可！而不必重新编译其他没有更动过的原始码文件</span>。
		这对於软件开发者来说，是一个很重要的功能，因为有时候要将偌大的原始码全部编译完成，会花很长的一段时间呢！</p>

		<p>此外，如果你想要让程序在运行的时候具有比较好的效能，或者是其他的除错功能时，
		可以在编译的过程里面加入适当的参数，例如底下的例子：</p>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">gcc -O -c thanks.c thanks_2.c</span>  <span class="term_note">&lt;== -O 为产生最佳化的参数</span>

[root@www ~]# <span class="term_command">gcc -Wall -c thanks.c thanks_2.c</span>
thanks.c: In function 'main':
thanks.c:5: warning: implicit declaration of function 'thanks_2'
thanks.c:6: warning: control reaches end of non-void function
<span class="term_say"># -Wall 为产生更详细的编译过程资讯。上面的信息为警告信息 (warning)
# 所以不用理会也没有关系！</span>
</pre></td></tr></tbody></table>

		<p>至於更多的 gcc 额外参数功能，就得要 man gcc 罗～呵呵！可多的跟天书一样～</p>
	</div>

	<hr><a name="simple_ex_lib"></a><img src="./鸟哥的 Linux 私房菜23 -- 原始码与 Tarball 软件管理员_files/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">呼叫外部函式库：加入连结的函式库</span>
	<div class="block2">
		<p>刚刚我们都仅只是在萤幕上面印出一些字眼而已，如果说要计算数学公式呢？例如我们想要计算出三角函数里面的
		sin (90度角)。要注意的是，大多数的程序语言都是使用径度而不是一般我们在计算的『角度』，
		180 度角约等於 3.14 径度！嗯！那我们就来写一下这个程序吧！</p>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">vim sin.c</span>
<span class="term_write">#include &lt;stdio.h&gt;
int main(void)
{
        float value;
        value = sin ( 3.14 / 2 );
        printf("%f\n",value);
}</span>
</pre></td></tr></tbody></table>

		<p>上面这个文件的内容可以在底下取得！</p>
		<ul><li><a href="http://cn.linux.vbird.org/linux_basic/0520source/sin.c">http://cn.linux.vbird.org/linux_basic/0520source/sin.c</a></li></ul>

		<p>那要如何编译这支程序呢？我们先直接编译看看：</p>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">gcc sin.c</span>
sin.c: In function 'main':
sin.c:5: warning: incompatible implicit declaration of built-in function 'sin'
/tmp/ccsfvijY.o: In function `main':
sin.c:(.text+0x1b): <u>undefined reference to `sin'</u>
collect2: ld returned 1 exit status
<span class="term_say"># 注意看到上面最后一行，会有个错误信息，代表没有成功！</span>
</pre></td></tr></tbody></table>

		<p>特别注意上面的错误信息，唉啊！怎么没有编译成功？它说的是『<span class="text_import2">undefined
		reference to sin</span>』，说的是『<span class="text_import2">没有 sin 
		的相关定义参考值！</span>』，为什么会这样呢？这是因为 C 语言里面的 sin 函示是写在 libm.so 
		这个函式库中，而我们并没有在原始码里面将这个函式库功能加进去，
		所以当然就需要在编译与连结的时候将这个函式库给他连结进运行档里面啊！我们可以这样做：<br><br></p>

		<hr><ul class="list1"><li class="text_import1">编译时加入额外函式库连结的方式：</li></ul>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">gcc sin.c -lm -L/lib -L/usr/lib</span>  <span class="term_note">&lt;==重点在 -lm </span>
[root@www ~]# <span class="term_command">./a.out                        </span>  <span class="term_note">&lt;==尝试运行新文件！</span>
1.000000
</pre></td></tr></tbody></table>

		<p>特别注意，使用 gcc 编译时所加入的那个 -lm 是有意义的，他可以拆开成两部份来看：</p>
		<ul class="text_import2" style="font-family: &#39;细明体&#39;;">
		<li>-l ：是『加入某个函式库(library)』的意思，</li>
		<li>&nbsp;m ：则是 libm.so 这个函式库，其中， lib 与扩展名(.a 或 .so)不需要写</li></ul>

		<p>所以 -lm 表示使用 libm.so (或 libm.a) 这个函式库的意思～至於那个 -L 后面接的路径呢？这表示：
		『<span class="text_import2">我要的函式库 libm.so 请到 /lib 或 /usr/lib 里面搜寻</span>！』</p>

		<p>上面的说明很清楚了吧！不过，要注意的是，由於 Linux 默认是将函式库放置在 /lib 与 /usr/lib 
		当中，所以你没有写 -L/lib 与 -L/usr/lib 也没有关系的！不过，万一哪天你使用的函式库并非放置在这两个目录下，那么
		-L/path 就很重要了！否则会找不到函式库喔！</p>

		<p>除了连结的函式库之外，你或许已经发现一个奇怪的地方，那就是在我们的
		sin.c 当中第一行『<span class="text_import2" style="font-family: &#39;细明体&#39;;"> #include
		&lt;stdio.h&gt;</span>』，这行说的是要将一些定义数据由 stdio.h 这个文件读入，这包括 printf 
		的相关配置。这个文件其实是放置在 /usr/include/stdio.h
		的！那么万一这个文件并非放置在这里呢？那么我们就可以使用底下的方式来定义出要读取的
		include 文件放置的目录：</p>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">gcc sin.c -lm -I/usr/include</span>
</pre></td></tr></tbody></table>

		<p>-I/path 后面接的路径( Path )就是配置要去搜寻相关的
		include 文件的目录啦！不过，同样的，默认值是放置在 /usr/include 底下，除非你的
		include 文件放置在其他路径，否则也可以略过这个项目！</p>

		<p>透过上面的几个小范例，你应该对於 gcc 以及原始码有一定程度的认识了，再接下来，我们来稍微整理一下
		gcc 的简易使用方法吧！</p>
	</div>

	<hr><a name="simple_ex_gcc"></a><img src="./鸟哥的 Linux 私房菜23 -- 原始码与 Tarball 软件管理员_files/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">gcc 的简易用法 (编译、参数与链结)</span>
	<div class="block2">
		<p>前面说过， gcc 为 Linux 上面最标准的编译器，这个 gcc 是由 <a href="http://www.gnu.org/" target="_blank">GNU 计画</a>所维护的，有兴趣的朋友请自行前往参考。既然 gcc 对於 Linux 上的 Open source
		是这么样的重要，所以底下我们就列举几个 gcc 常见的参数，如此一来大家应该更容易了解原始码的各项功能吧！</p>

<table class="term"><tbody><tr><td class="term"><pre><span class="term_hd"># 仅将原始码编译成为目标档，并不制作连结等功能：</span>
[root@www ~]# <span class="term_command">gcc -c hello.c</span>
<span class="term_say"># 会自动的产生 hello.o 这个文件，但是并不会产生 binary 运行档。</span>

<span class="term_hd"># 在编译的时候，依据作业环境给予最佳化运行速度</span>
[root@www ~]# <span class="term_command">gcc -O hello.c -c</span>
<span class="term_say"># 会自动的产生 hello.o 这个文件，并且进行最佳化喔！</span>

<span class="term_hd"># 在进行 binary file 制作时，将连结的函式库与相关的路径填入</span>
[root@www ~]# <span class="term_command">gcc sin.c -lm -L/usr/lib -I/usr/include</span>
<span class="term_say"># 这个命令较常下达在最终连结成 binary file 的时候，
# -lm 指的是 libm.so 或 libm.a 这个函式库文件；
# -L 后面接的路径是刚刚上面那个函式库的搜寻目录；
# -I 后面接的是原始码内的 include 文件之所在目录。</span>

<span class="term_hd"># 将编译的结果输出成某个特定档名</span>
[root@www ~]# <span class="term_command">gcc -o hello hello.c</span>
<span class="term_say"># -o 后面接的是要输出的 binary file 档名</span>

<span class="term_hd"># 在编译的时候，输出较多的信息说明</span>
[root@www ~]# <span class="term_command">gcc -o hello hello.c -Wall</span>
<span class="term_say"># 加入 -Wall 之后，程序的编译会变的较为严谨一点，
# 所以警告信息也会显示出来！</span>
</pre></td></tr></tbody></table>

		<p>比较重要的大概就是这一些。<span class="text_import2">另外，我们通常称
		-Wall 或者 -O 这些非必要的参数为旗标 (FLAGS)，因为我们使用的是 C 程序语言，所以有时候也会简称这些旗标为
		CFLAGS ，</span>这些变量偶尔会被使用的喔！尤其是在后头会介绍的 make 相关的用法时，更是重要的很呐！ ^_^</p>
	</div>
</div>


<hr><a name="make"></a><img src="./鸟哥的 Linux 私房菜23 -- 原始码与 Tarball 软件管理员_files/logo.png" alt="大标题的图示" width="35" align="middle" height="34"><span class="text_h1">用 make 进行巨集编译</span>
<div class="block1">
	<p>在本章一开始我们提到过 make 的功能是可以简化编译过程里面所下达的命令，同时还具有很多很方便的功能！那么底下咱们就来试看看使用
	make 简化下达编译命令的流程吧！<br><br></p>

	<hr><a name="make_why"></a><img src="./鸟哥的 Linux 私房菜23 -- 原始码与 Tarball 软件管理员_files/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">为什么要用 make</span>
	<div class="block2">
		<p>先来想像一个案例，假设我的运行档里面包含了四个原始码文件，分别是 main.c haha.c sin_value.c cos_value.c 
		这四个文件，这四个文件的目的是：</p>

		<ul style="font-family: &#39;细明体&#39;;">
		<li>main.c ：主要的目的是让使用者输入角度数据与呼叫其他三支副程序；</li>
		<li>haha.c ：输出一堆有的没有的信息而已；</li>
		<li>sin_value.c ：计算使用者输入的角度(360) sin 数值；</li>
		<li>cos_value.c ：计算使用者输入的角度(360) cos 数值。</li>
		</ul>

		<p>这四个文件你可以到 <a href="http://cn.linux.vbird.org/linux_basic/0520source/main.tgz">http://cn.linux.vbird.org/linux_basic/0520source/main.tgz</a>
		来下载。由於这四个文件里面包含了相关性，并且还用到数学函式在里面，所以如果你想要让这个程序可以跑，
		那么就需要这样编译：</p>

<table class="term"><tbody><tr><td class="term"><pre><span class="term_hd"># 1. 先进行目标档的编译，最终会有四个 *.o 的档名出现：</span>
[root@www ~]# <span class="term_command">gcc -c main.c</span>
[root@www ~]# <span class="term_command">gcc -c haha.c</span>
[root@www ~]# <span class="term_command">gcc -c sin_value.c</span>
[root@www ~]# <span class="term_command">gcc -c cos_value.c</span>

<span class="term_hd"># 2. 再进行连结成为运行档，并加入 libm 的数学函式，以产生 main 运行档：</span>
[root@www ~]# <span class="term_command">gcc -o main main.o haha.o sin_value.o cos_value.o \</span>
&gt; <span class="term_command">-lm -L/usr/lib -L/lib</span>

<span class="term_hd"># 3. 本程序的运行结果，必须输入姓名、360 度角的角度值来计算：</span>
[root@www ~]# <span class="term_command">./main </span>
Please input your name: <span class="term_command">VBird</span>  <span class="term_note">&lt;==这里先输入名字</span>
Please enter the degree angle (ex&gt; 90): <span class="term_command">30</span>   <span class="term_note">&lt;==输入以 360 度角为主的角度</span>
Hi, Dear VBird, nice to meet you.    <span class="term_note">&lt;==这三行为输出的结果喔！</span>
The Sin is:  0.50
The Cos is:  0.87
</pre></td></tr></tbody></table>

		<p>编译的过程需要进行好多动作啊！而且如果要重新编译，则上述的流程得要重新来一遍，光是找出这些命令就够烦人的了！
		如果可以的话，能不能一个步骤就给他完成上面所有的动作呢？那就利用 make 这个工具吧！
		先试看看在这个目录下创建一个名为 makefile 的文件，内容如下：</p>

<table class="term"><tbody><tr><td class="term"><pre><span class="term_hd"># 1. 先编辑 makefile 这个守则档，内容只要作出 main 这个运行档</span>
[root@www ~]# <span class="term_command">vim makefile</span>
<span class="term_write">main: main.o haha.o sin_value.o cos_value.o
	gcc -o main main.o haha.o sin_value.o cos_value.o -lm</span>
<span class="term_say"># 注意：第二行的 gcc 之前是 &lt;tab&gt; 按键产生的空格喔！</span>

<span class="term_hd"># 2. 尝试使用 makefile 制订的守则进行编译的行为：</span>
[root@www ~]# <span class="term_command">rm -f main *.o   <span class="term_note">&lt;==先将之前的目标档去除</span></span>
[root@www ~]# <span class="term_command">make</span>
cc    -c -o main.o main.c
cc    -c -o haha.o haha.c
cc    -c -o sin_value.o sin_value.c
cc    -c -o cos_value.o cos_value.c
gcc -o main main.o haha.o sin_value.o cos_value.o -lm
<span class="term_say"># 此时 make 会去读取 makefile 的内容，并根据内容直接去给他编译相关的文件罗！</span>

<span class="term_hd"># 3. 在不删除任何文件的情况下，重新运行一次编译的动作：</span>
[root@www ~]# <span class="term_command">make</span>
make: `main' is up to date.
<span class="term_say"># 看到了吧！是否很方便呢！只会进行升级 (update) 的动作而已。</span>
</pre></td></tr></tbody></table>

		<p>或许你会说：『如果我创建一个 shell script 来将上面的所有动作都集结在一起，不是具有同样的效果吗？』呵呵！
		效果当然不一样，以上面的测试为例，我们仅写出 main 需要的目标档，结果 make 
		会主动的去判断每个目标档相关的原始码文件，并直接予以编译，最后再直接进行连结的动作！
		真的是很方便啊！此外，如果我们更动过某些原始码文件，则 make 也可以主动的判断哪一个原始码与相关的目标档文件有升级过，
		并仅升级该文件，如此一来，将可大大的节省很多编译的时间呢！要知道，某些程序在进行编译的行为时，会消耗很多的
		CPU 资源呢！所以说， make 有这些好处：</p>

		<ul class="text_import2">
		<li>简化编译时所需要下达的命令；</li>
		<li>若在编译完成之后，修改了某个原始码文件，则 make 仅会针对被修改了的文件进行编译，其他的
			object file 不会被更动；</li>
		<li>最后可以依照相依性来升级 (update) 运行档。</li></ul>

		<p>既然 make 有这么多的优点，那么我们当然就得好好的了解一下 make 这个令人关心的家伙啦！而 make 
		里面最需要注意的大概就是那个守则文件，也就是 makefile 这个文件的语法啦！所以底下我们就针对 makefile 
		的语法来加以介绍罗。</p>
	</div>

	<hr><a name="make_makefile"></a><img src="./鸟哥的 Linux 私房菜23 -- 原始码与 Tarball 软件管理员_files/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">makefile 的基本语法与变量</span>
	<div class="block2">
		<a name="20080110"></a><p>make 的语法可是相当的多而复杂的，有兴趣的话可以到 <a href="http://www.gnu.org/software/make/manual/make.html" target="_blank">GNU</a> (<a href="http://cn.linux.vbird.org/linux_basic/0520source_code_and_tarball.php#ps1">注1</a>)
		去查阅相关的说明，鸟哥这里仅列出一些基本的守则，重点在於让读者们未来在接触原始码时，不会太紧张啊！
		好了，基本的 makefile 守则是这样的：</p>

<table class="term"><tbody><tr><td class="term"><pre><span class="term_write">标的(target): 目标档1 目标档2
&lt;tab&gt;   gcc -o 欲创建的运行档 目标档1 目标档2</span>
</pre></td></tr></tbody></table>

		<p>那个标的 (target) 就是我们想要创建的资讯，而目标档就是具有相关性的 object files ，那创建运行档的语法就是以 
		&lt;tab&gt; 按键开头的那一行！特别给他留意喔，『<span class="text_import2">命令列必须要以 tab 
		按键作为开头</span>』才行！他的守则基本上是这样的：</p>

		<ul class="text_import2">
		<li>在 makefile 当中的 # 代表注解；</li>
		<li>&lt;tab&gt; 需要在命令行 (例如 gcc 这个编译器命令) 的第一个字节；</li>
		<li>标的 (target) 与相依文件(就是目标档)之间需以『:』隔开。</li>
		</ul>

		<p>同样的，我们以刚刚上一个小节的范例进一步说明，如果我想要有两个以上的运行动作时，
		例如下达一个命令就直接清除掉所有的目标档与运行档，该如何制作呢？</p>

<table class="term"><tbody><tr><td class="term"><pre><span class="term_hd"># 1. 先编辑 makefile 来创建新的守则，此守则的标的名称为 clean ：</span>
[root@www ~]# <span class="term_command">vi makefile</span>
main: main.o haha.o sin_value.o cos_value.o
	gcc -o main main.o haha.o sin_value.o cos_value.o -lm
<span class="term_write">clean:
	rm -f main main.o haha.o sin_value.o cos_value.o</span>

<span class="term_hd"># 2. 以新的标的 (clean) 测试看看运行 make 的结果：</span>
[root@www ~]# <span class="term_command">make clean</span>  <span class="term_note">&lt;==就是这里！透过 make 以 clean 为标的</span>
rm -rf main main.o haha.o sin_value.o cos_value.o
</pre></td></tr></tbody></table>

		<p>如此一来，我们的 makefile 里面就具有至少两个标的，分别是 main 与 clean ，如果我们想要创建 main 
		的话，输入『<span class="text_import2">make main</span>』，如果想要清除有的没的，输入『<span class="text_import2">make
		clean</span>』即可啊！而如果想要先清除目标档再编译 main 这个程序的话，就可以这样输入：『make 
		clean main』，如下所示：</p>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">make clean main</span>
rm -rf main main.o haha.o sin_value.o cos_value.o
cc    -c -o main.o main.c
cc    -c -o haha.o haha.c
cc    -c -o sin_value.o sin_value.c
cc    -c -o cos_value.o cos_value.c
gcc -o main main.o haha.o sin_value.o cos_value.o -lm
</pre></td></tr></tbody></table>

		<p>这样就很清楚了吧！但是，你是否会觉得，咦！ makefile 里面怎么重复的数据这么多啊！没错！所以我们可以再藉由 shell
		script 那时学到的『变量』来更简化 makefile 喔：</p>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">vi makefile</span>
<span class="term_write">LIBS = -lm
OBJS = main.o haha.o sin_value.o cos_value.o
main: ${OBJS}
        gcc -o main ${OBJS} ${LIBS}
clean:
        rm -f main ${OBJS}</span>
</pre></td></tr></tbody></table>

		<p>与 <a href="http://cn.linux.vbird.org/linux_basic/0340bashshell-scripts.php">bash shell script</a> 的语法有点不太相同，变量的基本语法为：</p>

		<ol class="text_import2">
		<li>变量与变量内容以『=』隔开，同时两边可以具有空格；</li>
		<li>变量左边不可以有 &lt;tab&gt; ，例如上面范例的第一行 LIBS 左边不可以是 &lt;tab&gt;；</li>
		<li>变量与变量内容在『=』两边不能具有『:』；</li>
		<li>在习惯上，变量最好是以『大写字母』为主；</li>
		<li>运用变量时，以 ${变量} 或 $(变量) 使用；</li>
		<li>在该 shell 的环境变量是可以被套用的，例如提到的 CFLAGS 这个变量！</li>
		<li>在命令列模式也可以给予变量。</li></ol>

		<p>由於 <span class="text_import2">gcc 在进行编译的行为时，会主动的去读取 CFLAGS
		这个环境变量</span>，所以，你可以直接在 shell 定义出这个环境变量，也可以在
		makefile 文件里面去定义，更可以在命令列当中给予这个咚咚呢！例如：</p>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">CFLAGS="-Wall" make clean main</span>
<span class="term_say"># 这个动作在上 make 进行编译时，会去取用 CFLAGS 的变量内容！</span>
</pre></td></tr></tbody></table>

		<p>也可以这样：</p>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">vi makefile</span>
LIBS = -lm
OBJS = main.o haha.o sin_value.o cos_value.o
<span class="term_write">CFLAGS = -Wall</span>
main: ${OBJS}
	gcc -o main ${OBJS} ${LIBS}
clean:
	rm -f main ${OBJS}
</pre></td></tr></tbody></table>

		<p>咦！我可以利用命令列进行环境变量的输入，也可以在文件内直接指定环境变量，那万一这个
		CFLAGS 的内容在命令列与 makefile 里面并不相同时，以那个方式输入的为主？呵呵！问了个好问题啊！
		环境变量取用的守则是这样的：</p>

		<ol class="text_import2">
		<li>make 命令列后面加上的环境变量为优先；</li>
		<li>makefile 里面指定的环境变量第二；</li>
		<li>shell 原本具有的环境变量第三。</li></ol>

		<p>此外，还有一些特殊的变量需要了解的喔：</p>

		<ul class="text_import2">
		<li>$@：代表目前的标的(target)</li></ul>

		<p>所以我也可以将 makefile 改成：</p>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">vi makefile</span>
LIBS = -lm
OBJS = main.o haha.o sin_value.o cos_value.o
CFLAGS = -Wall
main: ${OBJS}
	<span class="term_write">gcc -o $@ ${OBJS} ${LIBS}</span>   <span class="term_note">&lt;==那个 $@ 就是 main ！</span>
clean:
	rm -f main ${OBJS}
</pre></td></tr></tbody></table>

		<p>这样是否稍微了解了 makefile (也可能是 Makefile) 
		的基本语法？这对於你未来自行修改原始码的编译守则时，是很有帮助的喔！^_^！</p>
	</div>
</div>


<hr><a name="tarball"></a><img src="./鸟哥的 Linux 私房菜23 -- 原始码与 Tarball 软件管理员_files/logo.png" alt="大标题的图示" width="35" align="middle" height="34"><span class="text_h1">Tarball 的管理与建议</span>
<div class="block1">
	<p>在我们知道了原始码的相关资讯之后，再来要了解的自然就是如何使用具有原始码的
	Tarball 来创建一个属於自己的软件罗！从前面几个小节的说明当中，我们晓得<span class="text_import2">其实
	Tarball 的安装是可以跨平台的，因为 C 语言的程序码在各个平台上面是可以共通的</span>，
	只是需要的编译器可能并不相同而已。例如
	Linux 上面用 gcc 而 Windows 上面也有相关的 C 编译器啊～所以呢，同样的一组原始码，既可以在
	CentOS Linux 上面编译，也可以在 SuSE Linux 上面编译，当然，也可以在大部分的 Unix 平台上面编译成功的！</p>

	<p>如果万一没有编译成功怎么办？很简单啊，透过修改小部分的程序码 (通常是因为很小部分的异动而已) 
	就可以进行跨平台的移植了！也就是说，刚刚我们在 Linux 底下写的程序『<span class="text_import2">理论上，是可以在
	Windows 上面编译的</span>！』这就是原始码的好处啦！所以说，如果朋友们想要学习程序语言的话，
	鸟哥个人是比较建议学习『<span class="text_import2">具有跨平台能力的程序语言</span>』，例如
	C 就是很不错的一个！</p>

	<p>唉啊！又扯远了～赶紧拉回来继续说明我们的 Tarball 啦！<br><br></p>

	<hr><a name="tarball_pack"></a><img src="./鸟哥的 Linux 私房菜23 -- 原始码与 Tarball 软件管理员_files/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">使用原始码管理软件所需要的基础软件</span>
	<div class="block2">
		<p>从原始码的说明我们晓得要制作一个 binary program 需要很多咚咚的呢！这包括底下这些基础的软件：</p>

		<ul>
		<li><span class="text_import1">gcc 或 cc 等 C 语言编译器 (compiler)：</span><br><br>
		没有编译器怎么进行编译的动作？所以 C compiler 是一定要有的。不过 Linux 上面有众多的编译器，其中当然以 GNU
		的 gcc 是首选的自由软件编译器罗！事实上很多在 Linux 平台上面发展的软件的原始码，原本就是以
		gcc 为底来设计的呢。<br><br></li>

		<li><span class="text_import1">make 及 autoconfig 等软件：</span><br><br>
		一般来说，以 Tarball 方式释出的软件当中，为了简化编译的流程，通常都是配合前几个小节提到的
		make 这个命令来依据目标文件的相依性而进行编译。但是我们也知道说 make 需要
		makefile 这个文件的守则，那由於不同的系统里面可能具有的基础软件环境并不相同，
		所以就需要侦测使用者的作业环境，好自行创建一个 makefile 文件。这个自行侦测的小程序也必须要藉由 autoconfig 
		这个相关的软件来辅助才行。<br><br></li>

		<li><span class="text_import1">需要 Kernel 提供的 Library 以及相关的 Include 文件：</span><br><br>
		从前面的原始码编译过程，我们晓得函式库 (library) 的重要性，同时也晓得有 include 
		文件的存在。很多的软件在发展的时候都是直接取用系统核心提供的函式库与 include 
		文件的，这样才可以与这个操作系统兼容啊！尤其是在『<span class="text_import2">驱动程序方面的模块</span> 』，例如网络卡、声卡、U盘
		等驱动程序在安装的时候，常常是需要核心提供的相关资讯的。在 Red Hat  的系统当中 (包含 Fedora/CentOS 等系列)
		，这个核心相关的功能通常都是被包含在 <span class="text_import2">kernel-source</span>
		或 <span class="text_import2">kernel-header</span> 这些软件名称当中，所以记得要安装这些软件喔！
		</li></ul>

		<p>虽然 Tarball 的安装上面相当的简单，如同我们前面几个小节的例子，只要顺著开发商提供的
		README 与 INSTALL 文件所载明的步骤来进行，安装是很容易的。但是我们却还是常常会在
		BBS 或者是新闻群组当中发现这些留言：『我在运行某个程序的侦测文件时，他都会告诉我没有
		gcc 这个软件，这是怎么回事？』还有：『我没有办法使用 make 耶！这是什么问题？』呵呵！
		这就是没有安装上面提到的那些基础软件啦！</p>

		<p>咦！为什么使用者不安装这些软件啊？这是因为目前的 Linux distribution
		大多已经偏向於桌上型计算机的使用 (非服务器端)，他们希望使用者能够按照厂商自己的希望来安装相关的软件即可，
		所以通常『默认』是没有安装 gcc 或者是 make 等软件的。所以啦，<span class="text_import2">如果你希望未来可以自行安装一些以
		Tarball 方式释出的软件时，记得请自行挑选想要安装的软件名称喔</span>！例如在
		CentOS 或者是 Red Hat 当中记得选择 <span class="text_import2">Development Tools</span>
		以及 <span class="text_import2">Kernel Source Development</span> 等相关字眼的软件群集呢。</p>

		<p><span class="text_import2">那万一我已经安装好一部 Linux 主机，但是使用的是默认值所安装的软件，所以没有
		make, gcc 等咚咚，该如何是好</span>？呵呵！问题其实不大啦，目前使用最广泛的 CentOS/Fedora
		或者是 Red Hat 大多是以 RPM (下一章会介绍) 来安装软件的，所以，你只要拿出当初安装
		Linux 时的原版光盘，然后以下一章介绍的 RPM 来一个一个的加入到你的 Linux	主机里面就好啦！很简单的啦！
		尤其现在又有 yum 这玩意儿，更方便呐！</p>

		<p>在 CentOS 当中，如果你已经有网络可以连上 Internet 的话，那么就可以使用下一章会谈到的 yum 罗！
		透过 yum 的软件群组安装功能，你可以这样做：</p>

		<ul>
		<li>如果是要安装 gcc 等软件发展工具，请使用『 yum groupinstall "Development Tools" 』</li>
		<li>若待安装的软件需要图形介面支持，一般还需要『 yum groupinstall "X Software Development" 』</li>
		<li>若安装的软件较旧，可能需要『 yum groupinstall "Legacy Software Development" 』</li>
		</ul>

		<p>大概就是这样，更多的资讯请参考下一章的介绍喔。</p>
	</div>

	<hr><a name="tarball_step"></a><img src="./鸟哥的 Linux 私房菜23 -- 原始码与 Tarball 软件管理员_files/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">Tarball 安装的基本步骤</span>
	<div class="block2">
		<p>我们提过以 Tarball 方式释出的软件是需要重新编译可运行的
		binary program 的。而 Tarball 是以 tar 这个命令来打包与压缩的文件，所以啦，当然就需要先将
		Tarball 解压缩，然后到原始码所在的目录下进行 makefile 的创建，再以 make
		来进行编译与安装的动作啊！所以整个安装的基础动作大多是这样的：</p>

		<ol class="text_import2">
		<li>取得原始档：将 tarball 文件在 /usr/local/src 目录下解压缩；</li>
		<li>取得步骤流程：进入新创建的目录底下，去查阅 INSTALL 与 README 等相关文件内容 (很重要的步骤！)；</li>
		<li>相依属性软件安装：根据 INSTALL/README 的内容察看并安装好一些相依的软件 (非必要)；</li>
		<li>创建 makefile：以自动侦测程序 (configure 或 config) 侦测作业环境，并创建 Makefile 这个文件；</li>
		<li>编译：以 make 这个程序并使用该目录下的 Makefile 做为他的参数配置档，来进行 make (编译或其他) 的动作；</li>
		<li>安装：以 make 这个程序，并以 Makefile 这个参数配置档，依据
			install 这个标的 (target) 的指定来安装到正确的路径！</li></ol>

		<p>注意到上面的第二个步骤，通常在每个软件在释出的时候，都会附上 INSTALL 或者是 README 
		这种档名的说明档，这些说明档请『<span class="text_import2">确实详细的</span>』
		阅读过一遍，通常这些文件会记录这个软件的安装要求、软件的工作项目、
		与软件的安装参数配置及技巧等，只要仔细的读完这些文件，基本上，要安装好
		tarball 的文件，都不会有什么大问题罗。</p>

		<p>至於 makefile 在制作出来之后，里头会有相当多的标的 (target)，最常见的就是 install 与 clean 
		罗！通常『make clean』代表著将目标档 (object file) 清除掉，『make』则是将原始码进行编译而已。
		注意喔！编译完成的可运行档与相关的配置档还在原始码所在的目录当中喔！因此，最后要进行『make
		install』来将编译完成的所有咚咚都给他安装到正确的路径去，这样就可以使用该软件啦！</p>

		<p>OK！我们底下约略提一下大部分的 tarball 软件之安装的命令下达方式：</p>

		<ol>
		<li><span class="text_import1">./configure</span><br>
		这个步骤就是在<span class="text_import2">创建 Makefile 这个文件</span>罗！通常程序开发者会写一支
		scripts 来检查你的 Linux 系统、相关的软件属性等等，这个步骤相当的重要，
		因为未来你的安装资讯都是这一步骤内完成的！另外，这个步骤的相关资讯应该要参考一下该目录下的
		README 或 INSTALL 相关的文件！<br><br></li>

		<li><span class="text_import1">make clean</span><br>
		make 会读取 Makefile 中关於 clean 的工作。这个步骤不一定会有，但是希望运行一下，因为他<span class="text_import2">可以去除目标文件</span>！因为谁也不确定原始码里面到底有没有包含上次编译过的目标文件 
		(*.o) 存在，所以当然还是清除一下比较妥当的。
		至少等一下新编译出来的运行档我们可以确定是使用自己的机器所编译完成的嘛！<br><br></li>

		<li><span class="text_import1">make</span><br>
		make 会依据 Makefile 当中的默认工作进行编译的行为！编译的工作主要是进行
		gcc 来将原始码编译成为可以被运行的 object files ，但是这些 object files
		通常还需要一些函式库之类的 link 后，才能产生一个完整的运行档！使用 make
		就是要将原始码编译成为可以被运行的可运行档，而这个可运行档会放置在目前所在的目录之下，
		尚未被安装到预定安装的目录中；<br><br></li>

		<li><span class="text_import1">make install</span><br>
		通常这就是最后的安装步骤了，make 会依据 Makefile 这个文件里面关於 install 
		的项目，将上一个步骤所编译完成的数据给他安装到预定的目录中，就完成安装啦！</li>
		</ol>

		<p>请注意，上面的步骤是一步一步来进行的，而<span class="text_import2">其中只要一个步骤无法成功，那么后续的步骤就完全没有办法进行的！</span>
		因此，要确定每一的步骤都是成功的才可以！举个例子来说，万一今天你在 ./configure 就不成功了，那么就表示 Makefile
		无法被创建起来，要知道，后面的步骤都是根据 Makefile 来进行的，既然无法创建 Makefile，后续的步骤当然无法成功罗！</p>

		<p>另外，如果在 make 无法成功的话，那就表示原始文件无法被编译成可运行档，那么 make install
		主要是将编译完成的文件给他放置到文件系统中的，既然都没有可用的运行档了，怎么进行安装？
		所以罗，要每一个步骤都正确无误才能往下继续做！此外，如果安装成功，
		并且是安装在独立的一个目录中，例如 /usr/local/packages 这个目录中好了，那么你就必需手动的将这个软件的
		man page 给他写入 /etc/man.config 里面去。</p>
	</div>

	<hr><a name="tarball_common"></a><img src="./鸟哥的 Linux 私房菜23 -- 原始码与 Tarball 软件管理员_files/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">一般
	Tarball 软件安装的建议事项 (如何移除？升级？)</span>
	<div class="block2">
		<p>或许你已经发现了也说不定，那就是<span class="text_import2">为什么前一个小节里面，
		Tarball 要在 /usr/local/src 里面解压缩呢</span>？基本上，在默认的情况下，原本的
		Linux distribution 释出安装的软件大多是在 /usr 里面的，而使用者自行安装的软件则建议放置在
		/usr/local 里面。这是考量到管理使用者所安装软件的便利性。</p>

		<p>怎么说呢？我们晓得几乎每个软件都会提供线上说明的服务，那就是
		info 与 man 的功能。在默认的情况下， man 会去搜寻 /usr/local/man 里面的说明文件，
		因此，如果我们将软件安装在 /usr/local 底下的话，那么自然安装完成之后，
		该软件的说明文件就可以被找到了。此外，如果你所管理的主机其实是由多人共同管理的，
		或者是如同学校里面，一部主机是由学生管理的，但是学生总会毕业吧？
		所以需要进行交接，如果大家都将软件安装在
		/usr/local 底下，那么管理上不就显的特别的容易吗！</p>

		<p>所以罗，通常我们会建议大家将自己安装的软件放置在 /usr/local 下，至於原始码
		(Tarball)则建议放置在 /usr/local/src (src 为 source 的缩写)底下啊。</p>

		<p>再来，让我们先来看一看 Linux distribution 默认的安装软件的路径会用到哪些？我们以
		apache 这个软件来说明的话 (apache 是 WWW 服务器软件，详细的数据请参考<a href="http://cn.linux.vbird.org/linux_server/0360apache.php">服务器架设篇</a>。你的系统不见得有装这个软件)：</p>

		<ul class="text_import2" style="font-family: &#39;细明体&#39;;">
		<li>/etc/httpd</li>
		<li>/usr/lib</li>
		<li>/usr/bin</li>
		<li>/usr/share/man</li></ul>

		<p>我们会发现软件的内容大致上是摆在<span class="text_import2"> etc, lib, bin, man</span>
		等目录当中，分别代表『<span class="text_import2">配置档、函式库、运行档、线上说明档』。</span>
		好了，那么你是以 tarball 来安装时呢？如果是放在默认的 /usr/local 里面，由於 
		/usr/local 原本就默认这几个目录了，所以你的数据就会被放在：</p>

		<ul class="text_import2" style="font-family: &#39;细明体&#39;;">
		<li>/usr/local/etc</li>
		<li>/usr/local/bin</li>
		<li>/usr/local/lib</li>
		<li>/usr/local/man</li></ul>

		<p>但是如果你每个软件都选择在这个默认的路径下安装的话，
		那么所有的软件的文件都将放置在这四个目录当中，因此，如果你都安装在这个目录下的话，
		那么未来再想要升级或移除的时候，就会比较难以追查文件的来源罗！
		而如果你在安装的时候选择的是单独的目录，例如我将
		apache 安装在 /usr/local/apache 当中，那么你的文件目录就会变成：</p>

		<ul class="text_import2" style="font-family: &#39;细明体&#39;;">
		<li>/usr/local/apache/etc</li>
		<li>/usr/local/apache/bin</li>
		<li>/usr/local/apache/lib</li>
		<li>/usr/local/apache/man</li></ul>

		<p>呵呵！单一软件的文件都在同一个目录之下，那么要移除该软件就简单的多了！
		<span class="text_import2">只要将该目录移除即可视为该软件已经被移除罗</span>！以上面为例，我想要移除
		apache 只要下达『<span class="text_import2">rm -rf /usr/local/apache</span>』
		就算移除这个软件啦！当然罗，实际安装的时候还是得视该软件的
		Makefile 里头的 install 资讯才能知道到底他的安装情况为何的。因为例如 sendmail
		的安装就很麻烦......</p>

		<p>这个方式虽然有利於软件的移除，但不晓得你有没有发现，我们在运行某些命令的时候，与该命令是否在
		PATH 这个环境变量所记录的路径有关，以上面为例，我的 /usr/local/apache/bin
		肯定是不在 PATH 里面的，所以运行 apache 的命令就得要利用绝对路径了，否则就得将这个
		/usr/local/apache/bin 加入 PATH 里面。另外，那个 /usr/local/apache/man
		也需要加入 man page 搜寻的路径当中啊！</p>

		<p>除此之外， Tarball 在升级的时候也是挺困扰的，怎么说呢？我们还是以 apache
		来说明好了。WWW 服务器为了考虑互动性，所以通常会将 PHP+MySQL+Apache 一起安装起来 (详细的资讯请参考服务器架设篇)
		，果真如此的话，那么每个软件在安装的时候『<span class="text_import2">都有一定的顺序与程序</span>！』
		因为他们三者之间具有相关性，所以安装时必需要三者同时考虑到他们的函式库与相关的编译参数。</p>

		<p>假设今天我只要升级 PHP 呢？有的时候因为只有涉及动态函式库的升级，那么我只要升级 PHP 
		即可！其他的部分或许影响不大。但是如果今天 PHP 需要重新编译的模块比较多，那么可能会连带的，连 Apache 
		这个程序也需要重新编译过才行！真是有点给他头痛的！没办法啦！使用
		tarball 确实有他的优点啦，但是在这方面，确实也有他一定的伤脑筋程度。</p>

		<p>由於 Tarball 在升级与安装上面具有这些特色，亦即 Tarball 在反安装上面具有比较高的难度 
		(如果你没有好好规划的话～)，所以，为了方便 Tarball 的管理，通常鸟哥会这样建议使用者：</p>

		<ol>
		<li><span class="text_import2">最好将 tarball 的原始数据解压缩到 /usr/local/src 当中；</span><br><br></li>
		<li><span class="text_import2">安装时，最好安装到 /usr/local 这个默认路径下；</span><br><br></li>
		<li><span class="text_import2">考虑未来的反安装步骤，最好可以将每个软件单独的安装在 /usr/local 底下；</span><br><br></li>
		<li><span class="text_import2">为安装到单独目录的软件之 man page 加入 man path 搜寻：</span><br>
		如果你安装的软件放置到 /usr/local/software/ ，那么 man page 搜寻的配置中，可能就得要在 /etc/man.config 内的 
		40~50 行左右处，写入如下的一行：
			<blockquote class="text_import2">MANPATH /usr/local/software/man</blockquote>
		这样才可以使用 man 来查询该软件的线上文件罗！</li></ol>
	</div>

	<hr><a name="tarball_exntp"></a><img src="./鸟哥的 Linux 私房菜23 -- 原始码与 Tarball 软件管理员_files/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">一个简单的范例、利用
	ntp 来示范</span>
	<div class="block2">
		<p>读万卷书不如行万里路啊！所以当然我们就来给他测试看看，看你是否真的了解了如何利用
		Tarball 来安装软件呢？我们利用时间服务器 (network time protocol) ntp 这个软件来测试安装看看。先请到
		<a href="http://www.ntp.org/downloads.html" target="_blank">http://www.ntp.org/downloads.html</a>
		这个目录去下载文件，请下载最新版本的文件即可。或者直接到鸟哥的网站下载 2009/05 公告释出的稳定版本：</p>

		<blockquote>
		<a href="http://cn.linux.vbird.org/linux_basic/0520source/ntp-4.2.4p7.tar.gz">http://cn.linux.vbird.org/linux_basic/0520source/ntp-4.2.4p7.tar.gz</a></blockquote>

		<p>假设我对这个软件的要求是这样的：</p>
		<ul>
		<li>假设 ntp-4.2.4p7.tar.gz 这个文件放置在 /root 这个目录下；</li>
		<li>原始码请解开在 /usr/local/src 底下；</li>
		<li>我要安装到 /usr/local/ntp 这个目录中；</li></ul>

		<p>那么你可以依照底下的步骤来安装测试看看 (如果可以的话，请你不要参考底下的文件数据，
		先自行安装过一遍这个软件，然后再来对照一下鸟哥的步骤喔！)。<br><br></p>

		<hr><ul class="list1"><li class="text_import1">解压缩下载的 tarball ，并参阅 README/INSTALL 文件</li></ul>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">cd /usr/local/src</span>   <span class="term_note">&lt;==切换目录</span>
[root@www src]# <span class="term_command">tar -zxvf /root/ntp-4.2.4p7.tar.gz</span>  <span class="term_note">&lt;==解压缩到此目录</span>
ntp-4.2.4p7/         <span class="term_note">&lt;==会创建这个目录喔！</span>
ntp-4.2.4p7/libopts/
<span class="term_say">....(底下省略)....</span>
[root@www src]# <span class="term_command">cd ntp-4.2.4p7/</span>
[root@www ntp-4.2.4p7]# <span class="term_command">vi INSTALL</span>  <span class="term_note">&lt;==记得 README 也要看一下！</span>
<span class="term_say"># 特别看一下 28 行到 54 行之间的安装简介！可以了解如何安装的流程喔！</span>
</pre></td></tr></tbody></table>

		<hr><ul class="list1"><li class="text_import1">检查 configure 支持参数，并实际建置 makefile 守则档</li></ul>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ntp*]# <span class="term_command">./configure --help | more</span>  <span class="term_note">&lt;==查询可用的参数有哪些</span>
  --prefix=PREFIX         install architecture-independent files in PREFIX
  --enable-all-clocks     + include all suitable non-PARSE clocks:
  --enable-parse-clocks   - include all suitable PARSE clocks:
<span class="term_say"># 上面列出的是比较重要的，或者是你可能需要的参数功能！</span>

[root@www ntp*]# <span class="term_command">./configure --prefix=/usr/local/ntp \</span>
&gt; <span class="term_command"> --enable-all-clocks --enable-parse-clocks</span>  <span class="term_note">&lt;==开始创建makefile</span>
checking for a BSD-compatible install... /usr/bin/install -c
checking whether build environment is sane... yes
<span class="term_say">....(中间省略)....</span>
checking for gcc... gcc           <span class="term_note">&lt;==也有找到 gcc 编译器了！</span>
<span class="term_say">....(中间省略)....</span>
config.status: creating Makefile  <span class="term_note">&lt;==现在知道这个重要性了吧？</span>
config.status: creating config.h
config.status: executing depfiles commands
</pre></td></tr></tbody></table>

		<p>一般来说 configure 配置参数较重要的就是那个 --prefix=/path 了，--prefix 
		后面接的路径就是『<span class="text_import2">这个软件未来要安装到那个目录去</span>？』如果你没有指定 
		--prefix=/path 这个参数，通常默认参数就是 /usr/local 至於其他的参数意义就得要参考 ./configure --help 了！
		这个动作完成之后会产生 makefile 或 Makefile 这个文件。当然啦，这个侦测检查的过程会显示在萤幕上，
		<span class="text_import2">特别留意关於 gcc 的检查</span>，还有最重要的是<span class="text_import2">最后需要成功的创建起 Makefile 才行</span>！</p>

		<hr><ul class="list1"><li class="text_import1">最后开始编译与安装噜！</li></ul>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ntp*]# <span class="term_command">make clean; make</span>
[root@www ntp*]# <span class="term_command">make check</span>
[root@www ntp*]# <span class="term_command">make install</span>
<span class="term_say"># 将数据给他安装在 /usr/local/ntp 底下</span>
</pre></td></tr></tbody></table>

		<p>整个动作就这么简单，你完成了吗？完成之后到 /usr/local/ntp 你发现了什么？</p>
	</div>

	<hr><a name="tarball_patch"></a><img src="./鸟哥的 Linux 私房菜23 -- 原始码与 Tarball 软件管理员_files/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">利用 patch 升级原始码</span>
	<div class="block2">
		<p>我们在本章一开始介绍了<a href="http://cn.linux.vbird.org/linux_basic/0520source_code_and_tarball.php#intro_howto">为何需要进行软件的升级</a>，这是很重要的喔！那假如我是以
		Tarball 来进行某个软件的安装，那么是否当我要升级这个软件时，就得要下载这个软件的完整全新的
		Tarball 呢？举个例子来说，鸟哥帮昆山资传系架了个讨论区在 <a href="http://www.dic.ksu.edu.tw/phpbb3" target="_blank">http://www.dic.ksu.edu.tw/phpbb3</a>
		这个网址，这个讨论区是以 <a href="http://www.phpbb.com/" target="_blank">phpBB</a> 
		这个软件来架设的，而鸟哥的讨论区版本为 phpbb3.0.4.tar.gz
		，目前 (2009/06) 最新释出的版本则是 phpbb3.0.5.tar.gz 。那我是否需要下载全新的
		phpbb3.0.5.tar.gz 这个文件来升级原本的旧程序呢？</p>

		<p>事实上，当我们发现一些软件的漏洞，通常是某一段程序码写的不好所致。因此，
		所谓的『升级原始码』常常是只有更改部分文件的小部分内容而已。既然如此的话，
		那么我们是否可以就那些被更动的文件来进行修改就可以咯？也就是说，
		旧版本到新版本间没有更动过的文件就不要理他，仅将有修订过的文件部分来处理即可。</p>

		<p>这有什么好处呢？首先，没有更动过的文件的目标档 (object file) 根本就不需要重新编译，而且有更动过的文件又可以利用 
		make 来自动 update (升级)，如此一来，我们原先的配置 (makefile 文件里面的守则) 
		将不需要重新改写或侦测！可以节省很多宝贵的时间呢 (例如后续章节会提到的核心的编译！)</p>

		<p>从上面的说明当中，我们可以发现，如果可以将旧版的原始码数据改写成新版的版本，	那么就能直接编译了，而不需要将全部的新版
		Tarball 重新下载一次呢！可以节省频宽与时间说！那么如何改写原始码？
		难道要我们一个文件一个文件去参考然后修订吗？当然没有这么没人性！</p>

		<p>我们在<a href="http://cn.linux.vbird.org/linux_basic/0330regularex.php">第十二章、正规表示法</a>的时候有提到一个比对文件的命令，那就是
		<a href="http://cn.linux.vbird.org/linux_basic/0330regularex.php#diff">diff</a>，这个命令可以将『<span class="text_import2">两个文件之间的差异性列出来</span>』呢！那我们也知道新旧版本的文件之间，
		其实只有修改一些程序码而已，那么我们可以透过 diff 比对出新旧版本之间的文字差异，然后再以相关的命令来将旧版的文件升级吗？
		呵呵！当然可以啦！那就是 <a href="http://cn.linux.vbird.org/linux_basic/0330regularex.php#patch">patch</a> 
		这个命令啦！很多的软件开发商在升级了原始码之后，几乎都会释出所谓的 patch file，也就是直接将原始码 update 
		而已的一个方式喔！我们底下以一个简单的范例来说明给你了解喔！</p>

		<p>关於 diff 与 patch 的基本用法我们在第十二章都谈过了，所以这里不再就这两个命令的语法进行介绍，
		请回去参阅第十二章的内容。这里我们来举个案例解释一下好了。假设我们刚刚计算三角函数的程序 (main) 历经多次改版，
		0.1 版仅会简单的输出， 0.2 版的输出就会含有角度值，因此这两个版本的内容不相同。如下所示，两个文件的意义为：</p>

		<ul>
		<li><a href="http://cn.linux.vbird.org/linux_basic/0520source/main-0.1.tgz">http://cn.linux.vbird.org/linux_basic/0520source/main-0.1.tgz</a>
		：main 的 0.1 版；</li>
		<li><a href="http://cn.linux.vbird.org/linux_basic/0520source/main_0.1_to_0.2.patch">http://cn.linux.vbird.org/linux_basic/0520source/main_0.1_to_0.2.patch</a>
		：main 由 0.1 升级到 0.2 的 patch file；</li>
		</ul>

		<p>请您先下载这两个文件，并且解压缩到你的 /root 底下。你会发现系统产生一个名为 main-0.1 的目录。
		该目录内含有五个文件，就是刚刚的程序加上一个 Makefile 的守则文件。你可以到该目录下去看看 Makefile 的内容，
		在这一版当中含有 main 与 clean 两个标的功能而已。至於 0.2 版则加入了 install 与 uninstall 的守则配置。
		接下来，请看一下我们的作法罗：<br><br></p>

		<hr><ul class="list1"><li class="text_import1">测试旧版程序的功能</li></ul>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">tar -zxvf main-0.1.tgz</span>
[root@www ~]# <span class="term_command">cd main-0.1</span>
[root@www main-0.1]# <span class="term_command">make clean main</span>
[root@www main-0.1]# <span class="term_command">./main</span>
version <u>0.1</u>
Please input your name: <span class="term_command">VBird</span>
Please enter the degree angle (ex&gt; 90): <span class="term_command">45</span>
Hi, Dear VBird, nice to meet you.
The <u>Sin</u> is:  0.71
The <u>Cos</u> is:  0.71
</pre></td></tr></tbody></table>

		<p>与之前的结果非常类似，只是鸟哥将 Makefile 直接给您了！但如果你下达 make install 时，系统会告知没有 install 的 target 
		啊！而且版本是 0.1 也告知了。那么如何升级到 0.2 版呢？透过这个 patch 文件吧！这个文件的内容有点像这样：<br><br></p>

		<hr><ul class="list1"><li class="text_import1">查阅 patch file 内容</li></ul>

<table class="term"><tbody><tr><td class="term"><pre>[root@www main-0.1]# <span class="term_command">vim ~/main_0.1_to_0.2.patch</span>
diff -Naur <u>main-0.1/cos_value.c main-0.2/cos_value.c</u>
--- main-0.1/cos_value.c        2009-06-09 22:52:33.000000000 +0800
+++ main-0.2/cos_value.c        2009-06-12 00:45:10.000000000 +0800
@@ -6,5 +6,5 @@
 {
        float value;
<span class="term_say">....(底下省略)....</span>
</pre></td></tr></tbody></table>

		<p>上面表格内有个底线的部分，那代表使用 diff 去比较时，被比较的两个文件所在路径，这个路径非常的重要喔！
		因为 patch 的基本语法如下：</p>

		<blockquote class="text_import2" style="font-family: &#39;细明体&#39;;">patch -p数字 &lt; patch_file</blockquote>

		<p>特别留意那个『 -p数字』，那是与 patch_file 里面列出的档名有关的资讯。假如在
		patch_file 第一行写的是这样：</p>

		<blockquote class="text_import2" style="font-family: &#39;细明体&#39;;">*** /home/guest/example/expatch.old</blockquote>

		<p>那么当我下达『 patch -p0 &lt; patch_file 』时，则升级的文件是『 /home/guest/example/expatch.old
		』，如果『 patch -p1 &lt; patch_file』，则升级的文件为『home/guest/example/expatch.old』，如果『patch
		-p4 &lt; patch_file』则升级『expatch.old』，也就是说， 
		<span class="text_import2">-pxx 那个 xx 代表『拿掉几个斜线(/)』的意思！</span>这样可以理解了吗？
		好了，根据刚刚上头的数据，我们可以发现比较的文件是在 main-0.1/xxx 与 main-0.2/xxx ，
		所以说，如果你是在 main-0.1 底下，并且想要处理升级时，就得要拿掉一个目录 (因为并没有 main-0.2 的目录存在，
		我们是在当前的目录进行升级的！)，因此使用的是 -p1 才对喔！所以：<br><br></p>

		<hr><ul class="list1"><li class="text_import1">升级原始码，并且重新编译程序！</li></ul>
<table class="term"><tbody><tr><td class="term"><pre>[root@www main-0.1]# <span class="term_command">patch -p1 &lt; ../main_0.1_to_0.2.patch</span>
patching file cos_value.c
patching file main.c
patching file Makefile
patching file sin_value.c
<span class="term_say"># 请注意，鸟哥目前所在目录是在 main-0.1 底下喔！注意与 patch 文件的<u>相对路径</u>！
# 虽然有五个文件，但其实只有四个文件有修改过喔！上面显示有改过的文件！</span>

[root@www main-0.1]# <span class="term_command">make clean main</span>
[root@www main-0.1]# <span class="term_command">./main</span>
version <u>0.2</u>
Please input your name: <span class="term_command">VBird</span>
Please enter the degree angle (ex&gt; 90): <span class="term_command">45</span>
Hi, Dear VBird, nice to meet you.
The <u>sin(45.000000)</u> is:  0.71
The <u>cos(45.000000)</u> is:  0.71
<span class="term_say"># 你可以发现，输出的结果中版本变了，输出资讯多了括号 () 喔！</span>

[root@www main-0.1]# <span class="term_command">make install  </span> <span class="term_note">&lt;==将他安装到 /usr/local/bin 给大家用</span>
cp -a main /usr/local/bin
[root@www main-0.1]# <span class="term_command">main          </span> <span class="term_note">&lt;==直接输入命令可运行！</span>
[root@www main-0.1]# <span class="term_command">make uninstall</span> <span class="term_note">&lt;==移除此软件！</span>
rm -f /usr/local/bin/main
</pre></td></tr></tbody></table>

		<p>很有趣的练习吧！所以你只要下载 patch file 就能够对你的软件原始码升级了！<span class="text_import2">只不过升级了原始码并非软件就升级！你还是得要将该软件进行编译后，才会是最终正确的软件喔！
		因为 patch 的功能主要仅只是升级原始码文件而已！切记切记</span>！此外，如果你 patch 错误呢？没关系的！我们的 patch 
		是可以还原的啊！透过『 patch -R  &lt; ../main_0.1_to_0.2.patch 』就可以还原啦！很有趣吧！</p>

<table border="1" cellpadding="5" cellspacing="0" width="90%"><tbody><tr><td>
例题：<div class="block2">
如果我有一个很旧版的软件，这个软件已经升级到很新的版本，例如核心，那么我可以使用 patch file 来升级吗？
</div>
答：<div class="block2">
这个问题挺有趣的，首先，你必须要确定旧版本与新版本之间『确实有释出 patch file 』才行，以 kernel 2.2.xx 及 2.4.xx 
来说，这两者基本上的架构已经不同了，所以两者间是无法以 patch file 来升级的。不过， 2.4.xx 与 2.4.yy 就可以升级了。不过，因为 kernel
每次推出的 patch 文件都仅针对前一个版本而已，所以假设要由 kernel 2.4.20 升级到 2.4.26 ，就必须要使用 patch 2.4.21, 
2.4.22, 2.4.23, 2.4.24, 2.4.25, 2.4.26 六个文件来『<b>依序升级</b>』才行喔！当然，如果有朋友帮你比对过
2.4.20 与 2.4.26 ，那你自然就可以使用该 patch file 来直接一次升级罗！
</div>
</td></tr></tbody></table><br>
	</div>
</div>


<hr><a name="library"></a><img src="./鸟哥的 Linux 私房菜23 -- 原始码与 Tarball 软件管理员_files/logo.png" alt="大标题的图示" width="35" align="middle" height="34"><span class="text_h1">函式库管理</span>
<div class="block1">
	<p>在我们的 Linux 操作系统当中，函式库是很重要的一个项目。
	因为<span class="text_import2">很多的软件之间都会互相取用彼此提供的函式库来进行特殊功能的运行</span>，
	例如很多需要验证身份的程序都习惯利用 PAM 这个模块提供的验证机制来实作，而很多网络连线机制则习惯利用 SSL
	函式库来进行连线加密的机制。所以说，函式库的利用是很重要的。不过，
	函式库又依照是否被编译到程序内部而分为动态与静态函式库，这两者之间有何差异？哪一种函式库比较好？
	底下我们就来谈一谈先！<br><br></p>

	<hr><a name="library_dyna_sta"></a><img src="./鸟哥的 Linux 私房菜23 -- 原始码与 Tarball 软件管理员_files/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">动态与静态函式库</span>
	<div class="block2">
		<p>首先我们要知道的是，函式库的类型有哪些？依据函式库被使用的类型而分为两大类，分别是静态 
		(Static) 与动态 (Dynamic) 函式库两类。底下我们来谈一谈这两种类行的函式库吧！<br><br></p>

		<hr><ul class="list1"><li class="text_import1">静态函式库的特色：</li></ul>
		<ul>
		<li><b>扩展名</b>：(扩展名为 .a)<br>
		这类的函式库通常扩展名为 <span class="text_import2">libxxx.a</span> 的类型；<br><br></li>
		<li><b>编译行为</b>：<br>
		这类函式库在编译的时候会直接整合到运行程序当中，所以<span class="text_import2">利用静态函式库编译成的文件会比较大一些喔</span>；<br><br></li>

		<li><b>独立运行的状态</b>：<br>这类函式库最大的优点，就是编译成功的可运行档<span class="text_import2">可以独立运行</span>，而不需要再向外部要求读取函式库的内容 
		(请参照动态函式库的说明)。<br><br></li>

		<li><b>升级难易度</b>：<br>虽然运行档可以独立运行，但因为函式库是直接整合到运行档中，
		因此若函式库升级时，整个运行档必须要重新编译才能将新版的函式库整合到程序当中。
		也就是说，在升级方面，只要函式库升级了，所有将此函式库纳入的程序都需要重新编译！</li></ul><br>

		<hr><ul class="list1"><li class="text_import1">动态函式库的特色：</li></ul>
		<ul>
		<li><b>扩展名</b>：(扩展名为 .so)<br>这类函式库通常扩展名为 <span class="text_import2">libxxx.so</span>
		的类型；<br><br></li>

		<li><b>编译行为</b>：<br>动态函式库与静态函式库的编译行为差异挺大的。
		与静态函式库被整个捉到程序中不同的，动态函式库在编译的时候，在程序里面只有一个『<span class="text_import2">指向
		(Pointer)</span>』的位置而已。也就是说，动态函式库的内容并没有被整合到运行档当中，而是当运行档要使用到函式库的机制时，
		程序才会去读取函式库来使用。由於运行档当中仅具有指向动态函式库所在的指标而已，
		并不包含函式库的内容，所以<span class="text_import2">他的文件会比较小一点</span>。<br><br></li>

		<li><b>独立运行的状态</b>：<br>这类型的函式库所编译出来的程序<span class="text_import2">不能被独立运行</span>，
		因为当我们使用到函式库的机制时，程序才会去读取函式库，所以函式库文件『<span class="text_import2">必须要存在</span>』才行，而且，函式库的『<span class="text_import2">所在目录也不能改变</span>』，因为我们的可运行档里面仅有『指标』亦即当要取用该动态函式库时，
		程序会主动去某个路径下读取，呵呵！所以动态函式库可不能随意移动或删除，会影响很多相依的程序软件喔！<br><br></li>

		<li><b>升级难易度</b>：<br>虽然这类型的运行档无法独立运行，然而由於是具有指向的功能，
		所以，当函式库升级后，运行档根本不需要进行重新编译的行为，因为运行档会直接指向新的函式库文件
		(前提是函式库新旧版本的档名相同喔！)。</li></ul>

		<p>目前的 Linux distribution 比较倾向於使用动态函式库，因为如同上面提到的最重要的一点，
		就是函式库的升级方便！由於 Linux 系统里面的软件相依性太复杂了，如果使用太多的静态函式库，那么升级某一个函式库时，
		都会对整个系统造成很大的冲击！因为其他相依的运行档也要同时重新编译啊！
		这个时候动态函式库可就有用多了，因为只要动态函式库升级就好，其他的软件根本无须变动。</p>

		<p>那么这些函式库放置在哪里呢？绝大多数的函式库都放置在：/usr/lib, /lib 目录下！
		此外，Linux 系统里面很多的函式库其实 kernel 就提供了，那么 kernel 
		的函式库放在哪里？呵呵！就是在<span class="text_import2">
		/lib/modules</span> 里面啦！里面的数据可多著呢！不过要注意的是，
		<span class="text_import2">不同版本的核心提供的函式库差异性是挺大的，所以
		kernel 2.4.xx 版本的系统不要想将核心换成 2.6.xx 喔！
		很容易由於函式库的不同而导致很多原本可以运行的软件无法顺利运行呢</span>！</p>
	</div>
　
	<hr><a name="library_ldconfig"></a><img src="./鸟哥的 Linux 私房菜23 -- 原始码与 Tarball 软件管理员_files/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">ldconfig
	与 /etc/ld.so.conf</span>
	<div class="block2">
		<p>在了解了动态与静态函式库，也知道我们目前的 Linux 
		大多是将函式库做成动态函式库之后，再来要知道的就是，那有没有办法添加函式库的读取效能？
		我们知道内存的存取速度是硬盘的好几倍，所以，<span class="text_import2">如果我们将常用到的动态函式库先加载内存当中 (缓存, 
		cache)，如此一来，当软件要取用动态函式库时，就不需要从头由硬盘里面读出罗！
		这样不就可以增进动态函式库的读取速度</span>？没错，是这样的！这个时候就需要
		ldconfig 与 /etc/ld.so.conf 的协助了。</p>

		<p>如何将动态函式库加载高速缓存当中呢？</p>
		<ol>
		<li>首先，我们必须要在 /etc/ld.so.conf 里面写下『
		<span class="text_import2">想要读入高速缓存当中的动态函式库所在的目录</span>』，注意喔，
		<span class="text_import2">是目录而不是文件；</span></li>
		<li>接下来则是利用 ldconfig 这个运行档将 /etc/ld.so.conf 的数据读入缓存当中；</li>
		<li>同时也将数据记录一份在 /etc/ld.so.cache 这个文件当中呐！</li>
		</ol>

		<center><img src="./鸟哥的 Linux 私房菜23 -- 原始码与 Tarball 软件管理员_files/ldconfig.gif" alt="使用 ldconfig 预加载动态函式库到内存中" title="使用 ldconfig 预加载动态函式库到内存中" border="0"><br>
		图 5.2.1、使用 ldconfig 预加载动态函式库到内存中<br></center>

		<p>事实上， ldconfig 还可以用来判断动态函式库的连结资讯呢！赶紧利用 CentOS
		来测试看看。假设你想要将目前你系统下的 MySQL 函式库加入到缓存当中时，可以这样做：</p>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">ldconfig [-f conf] [ -C cache]</span>
[root@www ~]# <span class="term_command">ldconfig [-p]</span>
<span class="term_say">选项与参数：
-f conf ：那个 conf 指的是某个文件名称，也就是说，使用 conf 作为 libarary 
	  函式库的取得路径，而不以 /etc/ld.so.conf 为默认值
-C cache：那个 cache 指的是某个文件名称，也就是说，使用 cache 作为缓存缓存
	  的函式库数据，而不以 /etc/ld.so.cache 为默认值
-p	：列出目前有的所有函式库数据内容 (在 /etc/ld.so.cache 内的数据！)</span>

<span class="term_hd">范例一：假设我的 MySQL 数据库函式库在 /usr/lib/mysql 当中，如何读进 cache ？</span>
[root@www ~]# <span class="term_command">vi /etc/ld.so.conf</span>
include ld.so.conf.d/*.conf
<span class="term_write">/usr/lib/mysql</span>   <span class="term_note">&lt;==这一行新增的啦！</span>

[root@www ~]# <span class="term_command">ldconfig</span>  <span class="term_note">&lt;==画面上不会显示任何的资讯，不要太紧张！正常的！</span>

[root@www ~]# <span class="term_command">ldconfig -p</span>
530 libs found in cache `/etc/ld.so.cache'
        libz.so.1 (libc6) =&gt; /usr/lib/libz.so.1
        libxslt.so.1 (libc6) =&gt; /usr/lib/libxslt.so.1
<span class="term_say">....(底下省略)....</span>
<span class="term_say">#       函式库名称 =&gt; 该函式库实际路径</span>
</pre></td></tr></tbody></table>

		<p>透过上面的动作，我们可以将 MySQL 的相关函式库给他读入缓存当中，这样可以加快函式库读取的效率呢！
		在某些时候，你可能会自行加入某些 Tarball 安装的动态函式库，而你想要让这些动态函式库的相关连结可以被读入到缓存当中，
		这个时候你可以将动态函式库所在的目录名称写入 /etc/ld.so.conf 当中，然后运行 ldconfig 就可以啦！</p>
	</div>

	<hr><a name="ldd"></a><img src="./鸟哥的 Linux 私房菜23 -- 原始码与 Tarball 软件管理员_files/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">程序的动态函式库解析： ldd</span>
	<div class="block2">
		<p>说了这么多，那么我如何判断某个可运行的 binary 文件含有什么动态函式库呢？很简单，利用
		ldd 就可以晓得了！例如我想要知道 /usr/bin/passwd 这个程序含有的动态函式库有哪些，可以这样做：</p>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">ldd [-vdr] [filename]</span>
<span class="term_say">选项与参数：
-v ：列出所有内容资讯；
-d ：重新将数据有遗失的 link 点秀出来！
-r ：将 ELF 有关的错误内容秀出来！</span>

<span class="term_hd">范例一：找出 /usr/bin/passwd 这个文件的函式库数据</span>
[root@www ~]# <span class="term_command">ldd /usr/bin/passwd</span>
<span class="term_say">....(前面省略)....</span>
        libaudit.so.0 =&gt; /lib/libaudit.so.0 (0x00494000)     <span class="term_note">&lt;==SELinux</span>
        libselinux.so.1 =&gt; /lib/libselinux.so.1 (0x00101000) <span class="term_note">&lt;==SELinux</span>
        libc.so.6 =&gt; /lib/libc.so.6 (0x00b99000)
        libpam.so.0 =&gt; /lib/libpam.so.0 (0x004ab000)         <span class="term_note">&lt;==PAM 模块</span>
<span class="term_say">....(底下省略)....</span>
<span class="term_say"># 我们前言的部分不是一直提到 passwd 有使用到 pam 的模块吗！怎么知道？
# 利用 ldd 察看一下这个文件，看到 libpam.so 了吧？这就是 pam 提供的函式库</span>

<span class="term_hd">范例二：找出 /lib/libc.so.6 这个函式的相关其他函式库！</span>
[root@www ~]# <span class="term_command">ldd -v /lib/libc.so.6</span>
        /lib/ld-linux.so.2 (0x00ab3000)
        linux-gate.so.1 =&gt;  (0x00636000)

        Version information:  <span class="term_note">&lt;==使用 -v 选项，添加显示其他版本资讯！</span>
        /lib/libc.so.6:
                ld-linux.so.2 (GLIBC_PRIVATE) =&gt; /lib/ld-linux.so.2
                ld-linux.so.2 (GLIBC_2.3) =&gt; /lib/ld-linux.so.2
                ld-linux.so.2 (GLIBC_2.1) =&gt; /lib/ld-linux.so.2
</pre></td></tr></tbody></table>

		<p>未来如果你常常升级安装 RPM 的软件时 (下一章节会介绍)，应该常常会发现那个『
		<span class="text_import2">相依属性</span>』的问题吧！没错！我们可以先以
		ldd 来视察『<span class="text_import2">相依函式库</span>』之间的相关性！以先取得了解！
		例如上面的例子中，我们检查了 libc.so.6 这个在 /lib 当中的函式库，结果发现他其实还跟 
		ld-linux.so.2 有关！所以我们就需要来了解一下，那个文件到底是什么软件的函式库呀？使用
		-v 这个参数还可以得知该函式库来自於哪一个软件！像上面的数据中，就可以得到该
		libc.so.6 其实可以支持 GLIBC_2.1 等的版本！</p>
	</div>
</div>


<hr><a name="check"></a><img src="./鸟哥的 Linux 私房菜23 -- 原始码与 Tarball 软件管理员_files/logo.png" alt="大标题的图示" width="35" align="middle" height="34"><span class="text_h1">检验软件正确性</span>
<div class="block1">
	<p>前面提到很多升级与安装需要注意的事项，因为我们需要克服很多的程序漏洞，所以需要前往
	Linux distribution 或者是某些软件开发商的网站，下载最新并且较安全的软件文件来安装才行。
	好了，那么『<span class="text_import2">有没有可能我们下载的文件本身就有问题</span>？』
	是可能的！因为 cracker 无所不在，很多的软件开发商已经公布过他们的网页所放置的文件曾经被窜改过！
	那怎么办？连下载原版的数据都可能有问题了？难道没有办法判断文件的正确性吗？</p>

	<p>这个时候我们就要透过<span class="text_import2">每个文件独特的指纹验证数据</span>了！因为每个文件的内容与文件大小都不相同，
	所以如果一个文件被修改之后，必然会有部分的资讯不一样！利用这个咚咚，我们可以使用
	MD5 这个指纹验证机制来判断该文件有没有被更动过！
	举个例子来说，台湾高速网络中心所提供的 CentOS 5.3 原版光盘下载点：</p>

	<blockquote><a href="http://ftp.twaren.net/Linux/CentOS/5.3/isos/i386/" target="_blank">http://ftp.twaren.net/Linux/CentOS/5.3/isos/i386/</a></blockquote>

	<p>同时提供了 CentOS 5.3 所有光盘/DVD 的 ISO 文件 MD5 编码，透过这个编码的比对，
	我们就可以晓得下载的文件是否有问题。那么万一 CentOS 提供的光盘映象档被下载之后，让有心人士偷偷修改过，再转到
	Internet 上面流传，那么你下载的这个文件偏偏不是原厂提供的，呵呵！
	你能保证该文件的内容完全没有问题吗？当然不能对不对！是的，这个时候就有
	md5sum 与 sha1sum 这个文件指纹的咚咚出现啦！说说他的用法吧！<br><br></p>

	<hr><a name="check_md5sum"></a><img src="./鸟哥的 Linux 私房菜23 -- 原始码与 Tarball 软件管理员_files/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">md5sum / sha1sum</span>
	<div class="block2">
		<p>目前有多种机制可以计算文件的指纹码，我们选择使用较为广泛的 MD5 与 SHA1 加密机制来处理。
		同样的，我们以高速计算机中心谈到的 CentOS 5.3 的网络安装映像档来处理试看看好了。
		在上面的连结网址上面，你会看到几个文件：</p>
		<ul>
		<li>CentOS-5.3-i386-netinstall.iso：CentOS 5.3 的网络安装映像档；</li>
		<li>md5sum.txt： MD5 指纹编码</li>
		<li>sha1sum.txt： SHA1 指纹编码</li>
		</ul>

		<p>如果你下载了 CentOS-5.3-i386-netinstall.iso 后，再以 md5sum 与 sha1sum 去检验这个文件时，
		文件所回传的指纹码应该要与网站上面提供的文件指纹码相同才对！我们由网站上面提供的指纹码知道这个映像档的指纹为：</p>
		<ul style="font-family: &#39;细明体&#39;;">
		<li>MD5&nbsp;: 6ae4077a9fc2dcedca96013701bd2a43</li>
		<li>SHA1: a0c640ae0c68cc0d9558cf4f8855f24671b3dadb</li>
		</ul>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">md5sum/sha1sum [-bct] filename</span>
[root@www ~]# <span class="term_command">md5sum/sha1sum [--status|--warn] --check filename</span>
<span class="term_say">选项与参数：
-b ：使用 binary 的读档方式，默认为 Windows/DOS 文件型态的读取方式；
-c ：检验文件指纹；
-t ：以文字型态来读取文件指纹。</span>

<span class="term_hd">范例一：将刚刚的文件下载后，测试看看指纹码</span>
[root@www ~]# <span class="term_command">wget \</span>
&gt; <span class="term_command" style="font-size: 8pt;">http://ftp.twaren.net/Linux/CentOS/5.3/isos/i386/CentOS-5.3-i386-netinstall.iso</span>
[root@www ~]# <span class="term_command">md5sum CentOS-5.3-i386-netinstall.iso</span>
6ae4077a9fc2dcedca96013701bd2a43  CentOS-5.3-i386-netinstall.iso
[root@www ~]# <span class="term_command">sha1sum CentOS-5.3-i386-netinstall.iso</span>
a0c640ae0c68cc0d9558cf4f8855f24671b3dadb  CentOS-5.3-i386-netinstall.iso
<span class="term_say"># 看！显示的编码是否与上面相同呢？赶紧测试看看！</span>
</pre></td></tr></tbody></table>

		<p>一般而言，每个系统里面的文件内容大概都不相同，例如你的系统中的 /etc/passwd
		这个登陆资讯档与我的一定不一样，因为我们的使用者与口令、 Shell 及家目录等大概都不相同，所以由
		md5sum 这个文件指纹分析程序所自行计算出来的指纹表当然就不相同罗！</p>

		<p>好了，那么如何应用这个东西呢？基本上，你必须要在你的 Linux 系统上为你的这些重要的文件进行指纹数据库的创建
		(好像在做户口调查！)，将底下这些文件创建数据库：</p>

		<ul class="text_import2" style="font-family: &#39;细明体&#39;;">
		<li>/etc/passwd</li>
		<li>/etc/shadow( 假如你不让使用者改口令了 )</li>
		<li>/etc/group</li>
		<li>/usr/bin/passwd</li>
		<li>/sbin/portmap</li>
		<li>/bin/login ( 这个也很容易被骇！ )</li>
		<li>/bin/ls</li>
		<li>/bin/ps</li>
		<li>/usr/bin/top</li></ul>

		<p>这几个文件最容易被修改了！因为很多木马程序运行的时候，还是会有所谓的『运行序,
		PID』为了怕被 root 追查出来，所以他们都会修改这些检查排程的文件，如果你可以替这些文件创建指纹数据库
		(就是使用 md5sum 检查一次，将该文件指纹记录下来，然后常常以
		<a href="http://cn.linux.vbird.org/linux_basic/0340bashshell-scripts.php">shell script</a> 
		的方式由程序自行来检查指纹表是否不同了！)，那么对於文件系统会比较安全啦！</p>
	</div>
</div>


<hr><a name="hint"></a><img src="./鸟哥的 Linux 私房菜23 -- 原始码与 Tarball 软件管理员_files/logo.png" alt="大标题的图示" width="35" align="middle" height="34"><span class="text_h1">重点回顾</span><br>
<div class="block1">
<ul class="text_import2">
	<li>原始码其实大多是纯文字档，需要透过编译器的编译动作后，才能够制作出 Linux 系统能够认识的可运行的 binary file ；</li>
	<li>开放原始码可以加速软件的升级速度，让软件效能更快、漏洞修补更即时；</li>
	<li>在 Linux 系统当中，最标准的 C 语言编译器为 gcc ；</li>
	<li>在编译的过程当中，可以藉由其他软件提供的函式库来使用该软件的相关机制与功能；</li>
	<li>为了简化编译过程当中的复杂的命令输入，可以藉由 make 与 makefile 守则定义，来简化程序的升级、编译与连结等动作；</li>
	<li>Tarball 为使用 tar 与 gzip/bzip2 压缩功能所打包与压缩的，具有原始码的文件；</li>
	<li>一般而言，要使用 Tarball 管理 Linux 系统上的软件，最好需要 gcc, make, autoconfig, kernel source, 
		kernel header 等前驱软件才行，所以在安装 Linux 之初，最好就能够选择 
		Software development 以及 kernel development 之类的群组；</li>
	<li>函式库有动态函式库与静态函式库，动态函式库在升级上具有较佳的优势。动态函式库的扩展名为 *.so 而静态则是 *.a ；</li>
	<li>patch 的主要功能在升级原始码，所以升级原始码之后，还需要进行重新编译的动作才行；</li>
	<li>可以利用 ldconfig 与 /etc/ld.so.conf 来制作动态函式库的连结与缓存！</li>
	<li>透过 MD5 的编码可以判断下载的文件是否为原本厂商所释出的文件。</li>
</ul>
</div>


<hr><a name="ex"></a><img src="./鸟哥的 Linux 私房菜23 -- 原始码与 Tarball 软件管理员_files/logo.png" alt="大标题的图示" width="35" align="middle" height="34"><span class="text_h1">本章习题</span><br>
<div class="block1">
实作题部分：
<ul>
	<li>请前往企鹅游戏网站 <a href="http://xpenguins.seul.org/" target="_blank">http://xpenguins.seul.org/</a>
	下载 xpenguins-2.2.tar.gz 原始码文件，并安装该软件。安装完毕之后，请在 GNOME 图形介面运行 xpenguins ，
	看看有没有出现如同官网上面出现的小企鹅？<br><br></li>
</ul>
<hr>情境模拟题部分：
<ul>
	<li>请依照底下的方式来建置你的系统的重要文件指纹码，并每日比对此重要工作。<br><br>
	<ol>
		<li>将 /etc/{passwd,shadow,group} 以及系统上面所有的 SUID/SGID 文件创建文件列表，该列表档名为『 important.file 』；<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">ls /etc/{passwd,shadow,group} &gt; important.file</span>
[root@www ~]# <span class="term_command">find /bin /sbin /usr/sbin /usr/bin -perm +6000 \</span>
&gt; <span class="term_command">&gt;&gt; important.file</span>
</pre></td></tr></tbody></table><br></li>

		<li>透过这个档名列表，以名为 md5.checkfile.sh 的档名去创建指纹码，并将该指纹码文件『 finger1.file 』配置成为不可修改的属性；<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">vim md5.checkfile.sh</span>
#!/bin/bash
for filename in $(cat important.file)
do
        md5sum $filename &gt;&gt; finger1.file
done

[root@www ~]# <span class="term_command">sh md5.checkfile.sh</span>
[root@www ~]# <span class="term_command">chattr +i finger1.file</span>
</pre></td></tr></tbody></table><br></li>

		<li>透过相同的机制去创建后续的分析数据为 finger_new.file ，并将两者进行比对，若有问题则提供 email 给 root 查阅：<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">vim md5.checkfile.sh</span>
#!/bin/bash
if [ "$1" == "new" ]; then
    for filename in $(cat important.file)
    do
        md5sum $filename &gt;&gt; finger1.file
    done
    echo "New file finger1.file is created."
    exit 0
fi
if [ ! -f finger1.file ]; then
    echo "file: finger1.file NOT exist."
    exit 1
fi

[ -f finger_new.file ] &amp;&amp; rm finger_new.file
for filename in $(cat important.file)
do
    md5sum $filename &gt;&gt; finger_new.file
done

testing=$(diff finger1.file finger_new.file)
if [ "$testing" != "" ]; then
    diff finger1.file finger_new.file | mail -s 'finger trouble..' root
fi

[root@www ~]# <span class="term_command">vim /etc/crontab</span>
30 2 * * * root cd /root; sh md5.checkfile.sh
</pre></td></tr></tbody></table>

		如此一来，每天系统会主动的去分析你认为重要的文件之指纹数据，然后再加以分析，看看有没有被更动过。
		不过，如果该变动是正常的，例如 CentOS 自动的升级时，那么你就得要删除 finger1.file ，
		再重新建置一个新的指纹数据库才行！否则你会每天收到有问题信件的回报喔！</li>
	</ol></li>
</ul>
</div>


<hr><a name="reference"></a><img src="./鸟哥的 Linux 私房菜23 -- 原始码与 Tarball 软件管理员_files/logo.png" alt="大标题的图示" width="35" align="middle" height="34"><span class="text_h1">参考数据与延伸阅读</span><br>
<div class="block1">
<ul>
	<li><a name="ps1"></a>注1：GNU 的 make 网页：<a href="http://www.gnu.org/software/make/manual/make.html" target="_blank">http://www.gnu.org/software/make/manual/make.html</a></li>
	<li>几种常见加密机制的全名：<br>
md5 (Message-Digest algorithm 5) <a href="http://en.wikipedia.org/wiki/MD5" target="_blank">http://en.wikipedia.org/wiki/MD5</a><br>
sha (Secure Hash Algorithm) <a href="http://en.wikipedia.org/wiki/SHA_hash_functions" target="_blank">http://en.wikipedia.org/wiki/SHA_hash_functions</a><br>
des (Data Encryption Standard) <a href="http://en.wikipedia.org/wiki/Data_Encryption_Standard" target="_blank">http://en.wikipedia.org/wiki/Data_Encryption_Standard</a></li>
	<li>洪朝贵老师的 C 程序语言：<a href="http://www.cyut.edu.tw/~ckhung/b/c/" target="_blank">http://www.cyut.edu.tw/~ckhung/b/c/</a></li>
</ul>
</div>



<hr><span class="text_history">
2002/08/21：第一次完成<br>
2003/02/11：重新编排与加入 FAQ<br>
2004/03/25：原本是 Tarball 与 RPM ，本日开始将 Tarball 与 RPM&nbsp; 分开说明与讲解(后续会花好几天喔！)，<br>
　　　　　 最重要的是 Source code 的说明，并提到相关的 gcc compile 功能等等！<br>
2004/04/10：经历了当兵中的无奈生活，终於将这篇给他完工了～(当时的鸟哥在将军渔港与青山港～)<br>
2005/09/30：旧版文章 (Tarball 与 RPM 的简单说明) 移动到 <a href="http://linux.vbird.org/linux_basic/0520softwaremanager/0520rpmtarball.php">此处</a> 。<br>
2005/10/01：将风格作个转变之外，也将一些测试移转到 FC4 上面进行！<br>
2008/01/10：感谢网友 ayttk 的说明，原本的 make 语法网页已经移动到其他地方了，请参考 <a href="http://cn.linux.vbird.org/linux_basic/0520source_code_and_tarball.php#20080110">这里</a>。<br>
2009/06/04：将基於 FC4 撰写的文章移动到 <a href="http://linux.vbird.org/linux_basic/0520source/0520source_code_and_tarball-fc4.php">此处</a><br>
2009/06/20：添加一个小练习，需要使用到 X software development 的软件群组喔！<br>
2009/09/15：加入一个情境模拟，其实有点功力练功练功而已的习题罗！<hr>
</span>
    </td>
    <td style="width: 16px; font-size: 6px;">　</td></tr>
<tr><td style="width: 16px; height: 16px;">　</td>
    <td style="width: 866px; height: 16px;">　</td>
    <td style="width: 16px; height: 16px;">　</td></tr>
</tbody></table>

<div style="padding-top: 0px; text-align: center;">
<span style="font-size: 80%;">
	<a href="http://linux.vbird.org/" target="_top" title="前往鸟哥的首页">http://linux.vbird.org</a>
	is designed by <a href="mailto:vbird@mail.vbird.idv.tw" title="联络鸟哥(我不要广告信！)">VBird</a>
		during 2001-2011. <a href="http://www.ksu.edu.tw/" target="_blank">ksu.edu</a></span>
         ﻿<div id="apDiv4">
      <p>本网页主要以Firefox配合解析度 1024x768 作为设计依据&nbsp;&nbsp;&nbsp;&nbsp; 鸟哥自由软件整合应用研究室</p></div></div>
</div>
</center>

</body></html>